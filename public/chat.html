// /api/json/chat.js
// RAG chat + server-side enrichment from Supabase page_entities.
// Returns: { ok, answer, citations[], structured: { events[], products[] } }

export const config = { runtime: 'nodejs' };

import { createClient } from '@supabase/supabase-js';

/* =========================
   Utilities
========================= */
const need = (k) => {
  const v = process.env[k];
  if (!v || !String(v).trim()) throw new Error(`missing_env:${k}`);
  return v;
};
const asString = (e) => {
  if (!e) return '(unknown)';
  if (typeof e === 'string') return e;
  if (e.message) return e.message;
  try { return JSON.stringify(e); } catch { return String(e); }
};

const send = (res, status, body) => {
  res.setHeader('Content-Type', 'application/json; charset=utf-8');
  res.status(status).send(JSON.stringify(body));
};

const dedupe = (arr) => Array.from(new Set(arr.filter(Boolean)));

const words = (s) =>
  (s || '')
    .toLowerCase()
    .split(/[^a-z0-9]+/g)
    .filter((w) => w.length >= 3);

const siteOf = (u) => {
  try { return new URL(u).origin; } catch { return ''; }
};

const samePageish = (a, b) => {
  // Same origin and share at least first path segment
  try {
    const A = new URL(a), B = new URL(b);
    if (A.origin !== B.origin) return false;
    const aa = A.pathname.split('/').filter(Boolean);
    const bb = B.pathname.split('/').filter(Boolean);
    return aa[0] && bb[0] && aa[0] === bb[0];
  } catch {
    return false;
  }
};

function scoreTitleMatch(a, b) {
  const ta = new Set(words(a));
  const tb = new Set(words(b));
  let s = 0;
  for (const w of ta) if (tb.has(w)) s++;
  return s;
}

/* =========================
   OpenAI helpers
========================= */

async function openaiChat({ system, user }) {
  const key = need('OPENAI_API_KEY');
  const r = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      Authorization: `Bearer ${key}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      model: 'gpt-4o-mini',
      temperature: 0.1,
      messages: [
        { role: 'system', content: system },
        { role: 'user', content: user },
      ],
    }),
  });

  const text = await r.text();
  if (!r.ok) throw new Error(`openai_error:${r.status}:${text.slice(0, 400)}`);
  let j; try { j = JSON.parse(text); } catch { throw new Error('openai_bad_json'); }
  const out = j?.choices?.[0]?.message?.content || '';
  return out.trim();
}

/* =========================
   Retrieval (Supabase)
========================= */
function buildOrIlike(column, tokens) {
  // returns e.g. content.ilike.%foo%,content.ilike.%bar%
  return tokens.map((t) => `${column}.ilike.%${t}%`).join(',');
}

async function retrieveChunks(supa, query, limit = 12) {
  // Simple FTS-ish OR search on content/title; stable without pgvector dependency.
  const toks = dedupe(words(query));
  if (!toks.length) return [];

  const orExpr = buildOrIlike('content', toks) + ',' + buildOrIlike('title', toks);

  const { data, error } = await supa
    .from('page_chunks')
    .select('url, title, content')
    .or(orExpr)
    .limit(limit);

  if (error) throw error;
  return data || [];
}

/* =========================
   Structured enrichment
========================= */

async function fetchEntities(supa, query) {
  const toks = dedupe(words(query));
  if (!toks.length) return { events: [], products: [] };

  // Build OR over title/description/url for both event and product
  const orA =
    buildOrIlike('title', toks) + ',' +
    buildOrIlike('description', toks) + ',' +
    buildOrIlike('url', toks) + ',' +
    buildOrIlike('source_url', toks);

  const { data, error } = await supa
    .from('page_entities')
    .select('kind, title, description, url, source_url, date_start, date_end, price, price_currency, availability')
    .or(orA);

  if (error) throw error;

  const events = [];
  const products = [];
  for (const r of data || []) {
    if (!r) continue;
    if ((r.kind || '').toLowerCase() === 'event') events.push(r);
    else if ((r.kind || '').toLowerCase() === 'product') products.push(r);
  }

  return { events, products };
}

function normalizeUrl(u) {
  // Prefer source_url when it exists (often the canonical/booking page)
  return u?.trim() || null;
}

function pickEventLink(e) {
  // Choose the best link for an event
  return normalizeUrl(e.source_url) || normalizeUrl(e.url);
}

function mapProducts(products) {
  return products.map((p) => ({
    title: p.title || null,
    url: normalizeUrl(p.source_url) || normalizeUrl(p.url),
    price: p.price ?? null,
    currency: p.price_currency || null,
    availability: p.availability || null,
  }));
}

function attachPricesToEvents(events, products) {
  // For each event, try to attach price from best matching product
  const out = [];
  for (const e of events) {
    let link = pickEventLink(e);
    let price = e.price ?? null;
    let currency = e.price_currency || null;

    // If no price on event, try to match a product by:
    // 1) exact/same page-ish
    // 2) title overlap
    if (price == null) {
      let best = null, bestScore = -1;
      for (const p of products) {
        const samePg = (link && (samePageish(link, p.source_url) || samePageish(link, p.url))) ? 2 : 0;
        const score = samePg + scoreTitleMatch(e.title || '', p.title || '');
        if (score > bestScore) { bestScore = score; best = p; }
      }
      if (best && (best.price != null)) {
        price = best.price;
        currency = best.price_currency || best.currency || currency || null;
      }
    }

    out.push({
      title: e.title || null,
      url: link,
      date_start: e.date_start || null,
      date_end: e.date_end || null,
      price,
      currency,
    });
  }
  return out;
}

/* =========================
   Handler
========================= */

export default async function handler(req, res) {
  if (req.method !== 'POST') return send(res, 405, { ok: false, error: 'method_not_allowed' });

  let stage = 'start';
  try {
    stage = 'auth';
    const token = (req.headers['authorization'] || '').trim();
    const needToken = process.env.INGEST_TOKEN;
    if (needToken && token !== `Bearer ${needToken}`) {
      return send(res, 401, { ok: false, error: 'unauthorized', stage });
    }

    stage = 'parse';
    const { query, topK = 8 } = req.body || {};
    if (!query || typeof query !== 'string') return send(res, 400, { ok: false, error: 'Provide "query" string.' });

    stage = 'db';
    const supa = createClient(need('SUPABASE_URL'), need('SUPABASE_SERVICE_ROLE_KEY'));

    /* 1) Retrieve chunks (simple OR/ILIKE) */
    stage = 'retrieve';
    const rows = await retrieveChunks(supa, query, Math.max(6, Math.min(24, Number(topK) || 8)));
    const citations = dedupe(rows.map((r) => r.url));

    const context = rows
      .map((r, i) => `# Doc ${i + 1} â€” ${r.title || r.url}\n${r.content}`)
      .join('\n\n');

    /* 2) Ask OpenAI with the retrieved context */
    stage = 'answer';
    const system =
      'You are a helpful assistant grounded ONLY in the provided context. ' +
      'Cite nothing yourself; the API will attach citations. If date/price not present in context, say it is not specified. ' +
      'Be concise and structured for end users.';
    const user =
      `Question: ${query}\n\n` +
      `Context (excerpts):\n` +
      `${context || '(no context found)'}`;

    const answer = await openaiChat({ system, user });

    /* 3) Structured enrichment from page_entities */
    stage = 'entities';
    const { events, products } = await fetchEntities(supa, query);

    // Map products (normalize)
    const productsOut = mapProducts(products);

    // Attach prices to events when possible + choose best link
    let eventsOut = attachPricesToEvents(events, products);

    // Sort events by date_start if present
    eventsOut = eventsOut.sort((a, b) => {
      const da = a.date_start ? Date.parse(a.date_start) : Infinity;
      const db = b.date_start ? Date.parse(b.date_start) : Infinity;
      return da - db;
    });

    // Add event links to citations (so UI can show per-date links)
    const eventUrls = dedupe(eventsOut.map((e) => e.url).filter(Boolean));
    const finalCitations = dedupe([...(citations || []), ...eventUrls]);

    /* 4) Done */
    stage = 'done';
    return send(res, 200, {
      ok: true,
      answer,
      citations: finalCitations,
      structured: {
        events: eventsOut,
        products: productsOut,
      },
    });
  } catch (err) {
    return send(res, 500, { ok: false, error: asString(err), stage });
  }
}
