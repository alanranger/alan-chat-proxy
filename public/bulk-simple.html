<!DOCTYPE html>
<html>
<head>
  <title>Alan Ranger Photography - Data Pipeline</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; background: #1a1a1a; color: #fff; }
    .container { max-width: 1200px; margin: 0 auto; }
    .header { text-align: center; margin-bottom: 30px; }
    .card { background: #2a2a2a; padding: 20px; margin: 20px 0; border-radius: 8px; }
    .section { margin: 30px 0; }
    .file-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; }
    .file-item { background: #333; padding: 15px; border-radius: 5px; }
    .file-item h4 { margin: 0 0 10px 0; color: #4CAF50; }
    .file-item input[type="file"] { width: 100%; margin: 10px 0; }
    .file-item small { color: #ccc; display: block; margin: 5px 0; }
    .btn { background: #4CAF50; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; margin: 5px; }
    .btn:hover { background: #45a049; }
    .btn-danger { background: #f44336; }
    .btn-danger:hover { background: #da190b; }
    .btn-primary { background: #2196F3; }
    .btn-primary:hover { background: #1976D2; }
    .status { padding: 10px; margin: 10px 0; border-radius: 5px; }
    .status.success { background: #4CAF50; color: white; }
    .status.error { background: #f44336; color: white; }
    .status.info { background: #2196F3; color: white; }
    .status.skipped { background: #f39c12; color: #111; }
    .results { background: #000; padding: 15px; border-radius: 5px; font-family: monospace; white-space: pre-wrap; max-height: 400px; overflow-y: auto; }
    .progress { width: 100%; background: #333; border-radius: 5px; margin: 10px 0; }
    .progress-bar { height: 20px; background: #4CAF50; border-radius: 5px; transition: width 0.3s; }
    .hidden { display: none; }
    .token-section { background: #333; padding: 15px; border-radius: 5px; margin-bottom: 20px; }
    .token-section input { width: 100%; padding: 8px; margin: 5px 0; background: #444; color: white; border: 1px solid #666; border-radius: 3px; }
    
    .stat-box {
      text-align: center;
      padding: 10px;
      background: #2a2a2a;
      border-radius: 5px;
      border: 1px solid #444;
    }
    
    .stat-label {
      font-size: 12px;
      color: #888;
      margin-bottom: 5px;
    }
    
    .stat-value {
      font-size: 18px;
      font-weight: bold;
      color: #fff;
    }
    
    .stat-value.success { color: #51cf66; }
    .stat-value.error { color: #ff6b6b; }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>🎯 Alan Ranger Photography - Data Pipeline</h1>
      <p>Simple CSV Import & Web Scraping Tool</p>
      <small>v1.0.6 - Priority-Based Matching System</small>
    </div>

    <!-- Token Section -->
    <div class="token-section">
      <h3>🔐 Authentication</h3>
      <div class="status success">✅ Token: b6c3f0c9e6f44cce9e1a4f3f2d3a5c76 (Hardcoded)</div>
      <small>Token is automatically configured for this private interface</small>
    </div>

    <!-- CSV Files Section -->
    <div class="section">
      <h2>📁 Upload Your CSV Files</h2>
      <div class="file-grid">
        <div class="file-item">
          <h4>📝 Blog Articles</h4>
          <input type="file" id="blogCsv" accept=".csv" />
          <small>Blog posts with categories, tags, content</small>
        </div>
        <div class="file-item">
          <h4>🎓 Course Events</h4>
          <input type="file" id="courseEventsCsv" accept=".csv" />
          <small>Scheduled course events with dates, times, locations</small>
        </div>
        <div class="file-item">
          <h4>🏞️ Workshop Events</h4>
          <input type="file" id="workshopEventsCsv" accept=".csv" />
          <small>Scheduled workshop events with dates, times, locations</small>
        </div>
        <div class="file-item">
          <h4>🎯 Service Pages</h4>
          <input type="file" id="servicePagesCsv" accept=".csv" />
          <small>Service and course page content</small>
        </div>
        <div class="file-item">
          <h4>🧾 Service Products (prices, availability)</h4>
          <input type="file" id="productsCsv" accept=".csv" />
          <small>Service product CSV (prices, availability)</small>
        </div>
        <div class="file-item">
          <h4>🌐 Site URLs</h4>
          <input type="file" id="siteUrlsCsv" accept=".csv" />
          <small>List of URLs to scrape from your website</small>
        </div>
        <div class="file-item">
          <h4>📄 Landing Pages</h4>
          <input type="file" id="landingPagesCsv" accept=".csv" />
          <small>Landing page content and metadata</small>
        </div>
        <div class="file-item">
          <h4>❓ Test Questions</h4>
          <input type="file" id="testQuestionsCsv" accept=".csv" />
          <small>Test questions for AI bot validation</small>
        </div>
        <div class="file-item">
          <h4>📦 Bulk CSV Upload</h4>
          <input type="file" id="bulkCsvs" accept=".csv" multiple />
          <small>Drop multiple CSVs. Types auto-detected by headers/filename.</small>
          <button class="btn" onclick="bulkUploadCSVs()">📥 Import Selected CSVs</button>
          <div id="bulkPreview" style="margin-top:8px;color:#bbb;font-size:12px"></div>
        </div>
      </div>
    </div>

    <!-- Action Buttons -->
    <div class="section">
      <h2>🚀 Actions (Execute in Order)</h2>
      <div class="card">
        <button class="btn btn-primary" onclick="importAllCSVs()" id="importAllBtn">
          1️⃣ 📥 Import All CSV Files
        </button>
        <button class="btn" onclick="scrapeWebsite()" id="scrapeBtn">
          2️⃣ 🕷️ Scrape Website URLs
        </button>
        <button class="btn" onclick="stopScrape()" id="stopScrapeBtn" style="display:none">
          ⏹️ Stop Scrape
        </button>
        <button class="btn" onclick="runMapping()" id="mappingBtn">
          3️⃣ 🔗 Run Event → Product Mapping
        </button>
        <button class="btn btn-danger" onclick="clearResults()">
          🗑️ Clear Results
        </button>
      </div>
      <div style="margin-top: 10px; padding: 10px; background: #2a2a2a; border-radius: 5px;">
        <small>
          <strong>Workflow:</strong>
          <span id="stepImport" style="padding:2px 6px;border-radius:4px;background:#555;margin-right:6px;">1️⃣ Import CSVs: idle</span>
          <span id="stepScrape" style="padding:2px 6px;border-radius:4px;background:#555;margin-right:6px;">2️⃣ Scrape URLs: idle</span>
          <span id="stepMap" style="padding:2px 6px;border-radius:4px;background:#555;">3️⃣ Create Mappings: idle</span>
          <span id="parityStatus" style="padding:2px 6px;border-radius:4px;background:#444;margin-left:8px;display:inline-block;">Parity: …</span>
          <button class="btn" style="margin-left:8px" onclick="exportMappings()">⬇️ Export Mappings CSV</button>
          <button class="btn" style="margin-left:8px" onclick="exportUnmapped()">⬇️ Export Unmapped CSV</button>
          <button class="btn" style="margin-left:8px" onclick="runTestQuestions()">🤖 Test Questions Batch</button>
        </small>
      </div>
      <div style="margin-top:8px">
        <small>Test Questions CSV (query,expected): </small>
        <input id="testQuestionsCsv" type="file" accept=".csv"/>
      </div>
    </div>

    <!-- Progress Section -->
    <div class="section" id="progressSection" class="hidden">
      <h3>📊 Progress</h3>
      <div class="progress">
        <div class="progress-bar" id="progressBar" style="width: 0%"></div>
      </div>
      <div id="progressText">Ready to start...</div>
    </div>

    <!-- Debug & Control Section -->
    <div class="section">
      <h3>🔧 Debug & Control</h3>
      <div class="card">
        <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; margin-bottom: 10px;">
              <div class="stat-box" title="Total URLs loaded from site_urls.csv for scraping">
                <div class="stat-label">Loaded Rows</div>
                <div class="stat-value" id="loadedRows">0</div>
              </div>
              <div class="stat-box" title="URLs successfully scraped or skipped as duplicates">
                <div class="stat-label">Success</div>
                <div class="stat-value success" id="successCount">0</div>
              </div>
              <div class="stat-box" title="URLs that failed to scrape">
                <div class="stat-label">Failed</div>
                <div class="stat-value error" id="failedCount">0</div>
              </div>
              <div class="stat-box" title="URLs stopped by user">
                <div class="stat-label">Stopped</div>
                <div class="stat-value" id="stoppedCount">0</div>
              </div>
              <div class="stat-box" title="URLs skipped because they were duplicates (already imported from CSVs)">
                <div class="stat-label">Skipped</div>
                <div class="stat-value" id="skippedCount">0</div>
              </div>
            </div>
        <div id="categoryStats" style="margin-top: 10px;">
          <!-- per-category stats will render here -->
        </div>
        <div style="display: flex; gap: 10px;">
          <button class="btn" onclick="copyDebugLog()">📋 Copy Debug Log</button>
          <button class="btn" onclick="downloadDebugLog()">⬇️ Download Debug Log</button>
          <button class="btn" onclick="clearResults()">🗑️ Clear Log</button>
        </div>
      </div>
    </div>

    <!-- Results Section -->
    <div class="section">
      <h2>📋 Results & Debug</h2>
      <div style="margin-bottom: 10px; display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
        <button class="btn" onclick="copyDebugLog()">📋 Copy Debug Log</button>
        <button class="btn" onclick="downloadDebugLog()">⬇️ Download Debug Log</button>
        <button class="btn" onclick="clearResults()">🗑️ Clear Log</button>
        <span style="margin-left:12px;color:#bbb;">Filter:</span>
        <button class="btn" id="filterAll" onclick="setLogFilter('all')">All</button>
        <button class="btn" id="filterSuccess" onclick="setLogFilter('success')">Success</button>
        <button class="btn" id="filterError" onclick="setLogFilter('error')">Failed</button>
        <button class="btn" id="filterSkipped" onclick="setLogFilter('skipped')">Skipped</button>
      </div>
      <div class="results" id="results">
        Ready to import your data. Select your CSV files and click "Import All CSV Files".
      </div>
    </div>

    <!-- QA Spot Checks Section -->
    <div class="section">
      <h2>🧪 QA Spot Checks</h2>
      <div class="card">
        <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap;">
          <button class="btn" onclick="runQaChecks()">Run QA Spot Checks</button>
          <small style="color:#bbb">Checks counts via Supabase REST; no new functions needed.</small>
        </div>
        <div id="qaResults" style="margin-top:10px; font-family: monospace; white-space: pre-wrap;"></div>
      </div>
    </div>

    <!-- Extract Structured JSON Section -->
    <div class="section">
      <h2>🔍 Extract Structured JSON (JSON-LD)</h2>
      <div class="card">
        <div style="margin-bottom: 15px;">
          <label>URL to extract from:</label>
          <input type="text" id="extractUrl" placeholder="https://www.alanranger.com/some-page" style="width: 100%; margin-bottom: 10px;" />
        </div>
        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
          <button class="btn" onclick="extractContent('events')">📅 Events/Courses</button>
          <button class="btn" onclick="extractContent('articles')">📝 Articles</button>
          <button class="btn" onclick="extractContent('products')">🛍️ Products</button>
          <button class="btn" onclick="extractContent('services')">🎯 Services</button>
          <button class="btn" onclick="extractContent('all')">🔍 All Content</button>
          <button class="btn" onclick="clearExtractResults()">🗑️ Clear</button>
        </div>
        <div id="extractResults" style="margin-top: 15px; padding: 10px; background: #1a1a1a; border-radius: 5px; min-height: 100px; font-family: monospace; white-space: pre-wrap;"></div>
      </div>
    </div>

    <!-- Quick Test Section -->
    <div class="section">
      <h2>🧪 Quick Test</h2>
      <div class="card">
        <input type="text" id="testUrl" placeholder="Enter URL to test" style="width: 70%; padding: 8px; margin: 5px; background: #444; color: white; border: 1px solid #666; border-radius: 3px;" />
        <button class="btn" onclick="testSingleUrl()">Test URL</button>
        <br>
        <input type="text" id="testQuery" placeholder="Ask a question" style="width: 70%; padding: 8px; margin: 5px; background: #444; color: white; border: 1px solid #666; border-radius: 3px;" />
        <button class="btn" onclick="testQuery()">Ask AI</button>
      </div>
    </div>
  </div>

  <script>
    // Token management - hardcoded for private use
    function getToken() {
      return 'b6c3f0c9e6f44cce9e1a4f3f2d3a5c76';
    }

    // Results management
    let logEntries = [];
    let logFilter = 'all';

    function setLogFilter(f) {
      logFilter = f;
      renderLog();
    }

    function renderLog() {
      const results = document.getElementById('results');
      const visible = logEntries.filter(e => logFilter === 'all' || e.type === logFilter);
      results.innerHTML = visible.map(e => `<div class="status ${e.type}">[${e.time}] ${e.message}</div>`).join('');
      results.scrollTop = results.scrollHeight;
    }

    function addResult(message, type = 'info') {
      // Promote certain messages to 'skipped' type
      if (type === 'success' && /Skipped duplicate/i.test(message)) type = 'skipped';
      const entry = { time: new Date().toLocaleTimeString(), type, message };
      logEntries.push(entry);
      // fast append if it matches current filter
      if (logFilter === 'all' || logFilter === type) {
        const results = document.getElementById('results');
        results.innerHTML += `<div class="status ${type}">[${entry.time}] ${message}</div>`;
        results.scrollTop = results.scrollHeight;
      }
    }

    function clearResults() {
      logEntries = [];
      document.getElementById('results').innerHTML = 'Results cleared. Ready for new operations.';
    }

    // Copy debug log to clipboard
    function copyDebugLog() {
      const results = document.getElementById('results');
      const logText = results.textContent || results.innerText;
      
      if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard.writeText(logText).then(() => {
          addResult('✅ Debug log copied to clipboard!', 'success');
        }).catch(err => {
          addResult('❌ Failed to copy to clipboard: ' + err.message, 'error');
          fallbackCopyTextToClipboard(logText);
        });
      } else {
        fallbackCopyTextToClipboard(logText);
      }
    }

    // Fallback copy method for older browsers
    function fallbackCopyTextToClipboard(text) {
      const textArea = document.createElement("textarea");
      textArea.value = text;
      textArea.style.top = "0";
      textArea.style.left = "0";
      textArea.style.position = "fixed";
      document.body.appendChild(textArea);
      textArea.focus();
      textArea.select();
      
      try {
        const successful = document.execCommand('copy');
        if (successful) {
          addResult('✅ Debug log copied to clipboard!', 'success');
        } else {
          addResult('❌ Failed to copy to clipboard', 'error');
        }
      } catch (err) {
        addResult('❌ Failed to copy to clipboard: ' + err.message, 'error');
      }
      
      document.body.removeChild(textArea);
    }

    // Progress management
    function updateProgress(percent, text) {
      document.getElementById('progressBar').style.width = percent + '%';
      document.getElementById('progressText').textContent = text;
      document.getElementById('progressSection').classList.remove('hidden');
    }

    // API calls
    async function apiCall(endpoint, data = null, opts = {}) {
      const token = getToken();
      if (!token) {
        addResult('❌ No token found. Please save your token first.', 'error');
        return null;
      }

      try {
        const controller = new AbortController();
        const timeoutMs = opts.timeoutMs || 0;
        let timeoutId = null;
        if (timeoutMs > 0) {
          timeoutId = setTimeout(() => controller.abort(), timeoutMs);
        }
        const response = await fetch(endpoint, {
          method: data ? 'POST' : 'GET',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: data ? JSON.stringify(data) : undefined,
          signal: controller.signal
        });
        if (timeoutId) clearTimeout(timeoutId);
        const text = await response.text();
        try { return JSON.parse(text); } catch { return { ok: response.ok, status: response.status, text }; }
      } catch (error) {
        addResult(`❌ API Error: ${error.message}`, 'error');
        return null;
      }
    }

    // Supabase REST GET with count=exact helper
    async function restCount(path) {
      const token = getToken();
      try {
        // Use hardcoded Supabase URL since process.env doesn't work in browser
        const supabaseUrl = 'https://igzvwbvgvmzvvzoclufx.supabase.co';
        const resp = await fetch(`${supabaseUrl}/rest/v1/${path}`, {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${token}`,
            'apikey': token,
            'Prefer': 'count=exact'
          }
        });
        const total = parseInt(resp.headers.get('content-range')?.split('/')?.[1] || '0', 10);
        return isNaN(total) ? 0 : total;
      } catch (e) {
        return `err:${e.message}`;
      }
    }

    // Fetch total events and mapped events from v_events_for_chat
    async function getMappingCounts() {
      const total = await restCount('v_events_for_chat?select=event_url');
      const mapped = await restCount('v_events_for_chat?select=event_url&product_url=not.is.null');
      return { total: Number(total)||0, mapped: Number(mapped)||0 };
    }

    // Parity: compare distinct URLs in entities vs chunks for each required path
    async function getParity() {
      // Prefer consolidated tools endpoint (service role)
      try {
        const resp = await fetch('/api/tools?action=parity', { headers: { 'Authorization': `Bearer ${getToken()}` } });
        const j = await resp.json();
        if (resp.ok && j && j.ok) return j;
      } catch {}
      // Fallback to REST counts
      const entitiesWorkshops = await restCount('page_entities?select=url&url=ilike.*photographic-workshops-near-me*');
      const chunksWorkshops   = await restCount('page_chunks?select=url&url=ilike.*photographic-workshops-near-me*');
      const entitiesCourses   = await restCount('page_entities?select=url&url=ilike.*beginners-photography-lessons*');
      const chunksCourses     = await restCount('page_chunks?select=url&url=ilike.*beginners-photography-lessons*');
      return { entitiesWorkshops: Number(entitiesWorkshops)||0, chunksWorkshops: Number(chunksWorkshops)||0, entitiesCourses: Number(entitiesCourses)||0, chunksCourses: Number(chunksCourses)||0 };
    }

    async function updateParityPill() {
      try {
        const p = await getParity();
        const pill = document.getElementById('parityStatus');
        if (pill) {
          pill.textContent = `Parity: W ${p.entitiesWorkshops}/${p.chunksWorkshops} | C ${p.entitiesCourses}/${p.chunksCourses}`;
          const ok = (p.entitiesWorkshops>0 && p.entitiesWorkshops<=p.chunksWorkshops) && (p.entitiesCourses>0 && p.entitiesCourses<=p.chunksCourses);
          pill.style.background = ok ? '#2a6' : '#a62';
        }
      } catch (e) {
        const pill = document.getElementById('parityStatus');
        if (pill) { pill.textContent = `Parity: error`; pill.style.background = '#a62'; }
      }
    }

    async function runQaChecks() {
      const el = document.getElementById('qaResults');
      el.textContent = 'Running QA checks...';
      try {
        const token = getToken();
        const resp = await fetch('/api/qa-spot-checks', {
          method: 'GET',
          headers: { 'Authorization': `Bearer ${token}` }
        });
        const text = await resp.text();
        let data;
        try { data = JSON.parse(text); } catch { data = { ok:false, raw:text }; }
        if (!resp.ok || !data?.ok) {
          el.textContent = `QA request failed: ${data?.error || resp.status} ${data?.detail || data?.raw || ''}`;
          return;
        }
        const rows = [];
        const checks = data.checks || {};
        const order = [
          'page_entities','page_chunks','event_product_links_auto',
          'v_events_real_data','v_events_for_chat',
          'v_blog_content','v_service_content','v_product_content'
        ];
        for (const name of order) {
          const c = checks[name];
          const count = (c && c.status === 'ok') ? (c.count ?? 0) : 0;
          rows.push(`${name.padEnd(36)} ${String(count)}`);
        }
        el.textContent = rows.join('\n');
      } catch (e) {
        el.textContent = `QA error: ${e.message}`;
      }
    }

    // CSV Import functions
    async function importCSV(file, contentType) {
      if (!file) {
        addResult(`❌ No ${contentType} file selected`, 'error');
        return false;
      }

      addResult(`📥 Importing ${contentType} data...`);
      const csvText = await file.text();
      
      // Count CSV rows by actually parsing the CSV (excluding header)
      const lines = csvText.split('\n').filter(line => line.trim());
      const headerLine = lines[0];
      
      // Proper CSV parser that handles quoted fields
      function parseCSVLine(line) {
        const result = [];
        let current = '';
        let inQuotes = false;
        let i = 0;
        
        while (i < line.length) {
          const ch = line[i];
          if (ch === '"') {
            if (inQuotes && line[i + 1] === '"') {
              current += '"';
              i += 2;
              continue;
            }
            inQuotes = !inQuotes;
          } else if (ch === ',' && !inQuotes) {
            result.push(current);
            current = '';
            i++;
            continue;
          } else {
            current += ch;
          }
          i++;
        }
        result.push(current);
        return result.map(s => s.replace(/^\s+|\s+$/g, '').replace(/^"|"$/g, ''));
      }
      
      const headers = parseCSVLine(headerLine).map(h => h.toLowerCase());
      
      // Parse CSV properly to get actual row count
      let actualRowCount = 0;
      let i = 1;
      while (i < lines.length) {
        let line = lines[i];
        if (!line.trim()) {
          i++;
          continue;
        }
        
        // Handle multi-line quoted fields
        let quoteCount = (line.match(/"/g) || []).length;
        let j = i + 1;
        while (quoteCount % 2 !== 0 && j < lines.length) {
          line += '\n' + lines[j];
          quoteCount = (line.match(/"/g) || []).length;
          j++;
        }
        
        // Parse the line properly
        const values = parseCSVLine(line);
        if (values.length === headers.length) {
          actualRowCount++;
        } else {
          console.warn(`CSV row ${i} has ${values.length} columns, expected ${headers.length}`);
        }
        
        i = j;
      }
      
      addResult(`📊 CSV has ${actualRowCount} data rows (${lines.length} total lines)`);
      
      // Handle special cases that don't use the multi-import endpoint
      if (contentType === 'site_urls' || contentType === 'landing_pages' || contentType === 'test_questions') {
        // Store CSV count for dashboard display even for reference files (accumulate, don't overwrite)
        const csvKey = contentTypeToCsvKey[contentType] || contentType;
        if (csvRowCounts.hasOwnProperty(csvKey)) {
          // For site_urls, only keep the largest count (main site URLs file)
          if (contentType === 'site_urls') {
            csvRowCounts[csvKey] = Math.max(csvRowCounts[csvKey], actualRowCount);
          } else {
            csvRowCounts[csvKey] += actualRowCount; // Add to existing count
          }
          // Update dashboard immediately
          renderCategoryStats();
        }
        // Cache site_urls for Scrape when coming from bulk box
        if (contentType === 'site_urls') {
          window.__cachedSiteUrlsText = csvText;
          addResult('🔗 Site URLs cached for Scrape step.', 'info');
        }
        addResult(`ℹ️ ${contentType} files are for reference only - not imported to database`, 'info');
        return { success: true, csvRows: actualRowCount, imported: 0 }; // Count as successful since these are reference files
      }
      
      const result = await apiCall('/api/csv-multi-import', { csvData: csvText, contentType });
      
      if (result && result.ok) {
        addResult(`✅ ${contentType} import successful: ${result.imported}/${actualRowCount} records (CSV rows → ingested)`, 'success');
        // Store CSV count for dashboard display (accumulate, don't overwrite)
        const csvKey = contentTypeToCsvKey[contentType] || contentType;
        console.log(`DEBUG: ${contentType} -> ${csvKey}, adding ${actualRowCount} rows`);
        if (csvRowCounts.hasOwnProperty(csvKey)) {
          // For site_urls, only keep the largest count (main site URLs file)
          if (contentType === 'site_urls') {
            csvRowCounts[csvKey] = Math.max(csvRowCounts[csvKey], actualRowCount);
          } else {
            csvRowCounts[csvKey] += actualRowCount; // Add to existing count
          }
          console.log(`DEBUG: csvRowCounts[${csvKey}] is now ${csvRowCounts[csvKey]}`);
          // Update dashboard immediately
          renderCategoryStats();
        } else {
          console.log(`DEBUG: csvRowCounts does not have key: ${csvKey}`);
        }
        // Cache site_urls text for scrape step if it was imported via bulk box
        if (contentType === 'site_urls') {
          try { window.__cachedSiteUrlsText = await file.text(); addResult('🔗 Site URLs cached for Scrape step.', 'info'); } catch {}
        }
        return { success: true, csvRows: actualRowCount, imported: result.imported };
      } else {
        addResult(`❌ ${contentType} import failed: ${result?.error || result?.detail || 'Unknown error'}`, 'error');
        if (result?.detail) {
          addResult(`🔍 Error details: ${JSON.stringify(result.detail)}`, 'error');
        }
        return { success: false, csvRows: actualRowCount, imported: 0 };
      }
    }

    // Main import function
    async function importAllCSVs() {
      const token = getToken();
      addResult('🔐 Using hardcoded token for authentication');
      document.getElementById('stepImport').style.background = '#3a3';
      document.getElementById('stepImport').textContent = '1️⃣ Import CSVs: running';

      updateProgress(0, 'Starting CSV imports...');
      addResult('🚀 Starting CSV import process...');

      const files = [
        { file: document.getElementById('blogCsv').files[0], type: 'blog', name: 'Blog Articles' },
        { file: document.getElementById('courseEventsCsv').files[0], type: 'event', name: 'Course Events' },
        { file: document.getElementById('workshopEventsCsv').files[0], type: 'workshop', name: 'Workshop Events' },
        { file: document.getElementById('servicePagesCsv').files[0], type: 'service', name: 'Service Pages' },
        { file: document.getElementById('productsCsv').files[0], type: 'product', name: 'Physical Products' },
        { file: document.getElementById('siteUrlsCsv').files[0], type: 'site_urls', name: 'Site URLs' },
        { file: document.getElementById('landingPagesCsv').files[0], type: 'landing_pages', name: 'Landing Pages' },
        { file: document.getElementById('testQuestionsCsv').files[0], type: 'test_questions', name: 'Test Questions' }
      ];

      let successCount = 0;
      let totalCount = files.filter(f => f.file).length;
      let totalCsvRows = 0;
      let totalImported = 0;

      if (totalCount === 0) {
        addResult('❌ No CSV files selected', 'error');
        return;
      }

      for (let i = 0; i < files.length; i++) {
        const { file, type, name } = files[i];
        if (file) {
          updateProgress((i / totalCount) * 100, `Importing ${name}...`);
          const result = await importCSV(file, type);
          if (result && result.success) {
            successCount++;
            totalCsvRows += result.csvRows || 0;
            totalImported += result.imported || 0;
          }
        }
      }

      updateProgress(100, `Import complete: ${successCount}/${totalCount} successful`);
      addResult(`🎉 CSV import process complete! ${successCount}/${totalCount} files imported successfully.`, 'success');
      addResult(`📊 Summary: ${totalImported}/${totalCsvRows} records imported (${totalCsvRows - totalImported} CSV rows not imported)`, 'info');
      document.getElementById('stepImport').style.background = successCount===totalCount ? '#2a6' : '#a62';
      document.getElementById('stepImport').textContent = `1️⃣ Import CSVs: ${successCount}/${totalCount} (${totalImported}/${totalCsvRows} records)`;
      
      // Update dashboard with CSV counts
      renderCategoryStats();
    }

    // --- Bulk CSV Upload ---
    function detectTypeFromHeaders(firstLine){
      const h = (firstLine||'').toLowerCase();
      if (h.includes('event_title') && h.includes('start_date') && h.includes('start_time')) return 'event';
      if (h.includes('title,') && h.includes('url') && h.includes('categories') && h.includes('tags')) return 'blog';
      if (h.includes('product url') || h.includes('price')) return 'product';
      if (h.includes('service') || h.includes('mentoring') || h.includes('course') || h.includes('class')) return 'service';
      if (h.startsWith('url') || h.includes('url') && !h.includes('title')) return 'site_urls';
      if (h.includes('landing')) return 'landing_pages';
      return null;
    }

    function detectTypeByName(name){
      const n = (name||'').toLowerCase();
      if (n.includes('workshop')) return 'workshop';
      if (n.includes('event')) return 'event';
      if (n.includes('blog') || n.includes('news')) return 'blog';
      if (n.includes('product')) return 'product';
      if (n.includes('service') || n.includes('mentoring') || n.includes('course') || n.includes('class')) return 'service';
      if (n.includes('site') && n.includes('url')) return 'site_urls';
      if (n.includes('urls') || n.includes('url')) return 'site_urls';
      if (n.includes('landing')) return 'landing_pages';
      if (n.includes('question')) return 'test_questions';
      return null;
    }

    async function bulkUploadCSVs(){
      const input = document.getElementById('bulkCsvs');
      const files = Array.from(input.files||[]);
      if (!files.length){ addResult('❌ No files selected for bulk upload','error'); return; }
      const previewEl = document.getElementById('bulkPreview');
      previewEl.textContent = 'Detecting file types...';

      const plan = [];
      addResult(`🔍 Processing ${files.length} files for bulk upload...`);
      for (const f of files){
        const text = await f.text();
        const first = text.split('\n')[0] || '';
        let type = detectTypeFromHeaders(first) || detectTypeByName(f.name);
        if (type === 'workshop') type = 'workshop';
        if (type === 'event' && f.name.includes('workshop')) type = 'workshop';
        if (!type){
          addResult(`❓ Could not detect type for ${f.name}. Skipping.`, 'error');
          continue;
        }
        addResult(`✅ Detected ${f.name} as ${type}`);
        plan.push({ file: f, type, first });
      }

      if (!plan.length){ addResult('❌ No recognizable CSVs in bulk selection','error'); return; }

      previewEl.innerHTML = plan.map(p => `<div>• ${p.file.name} → <strong>${p.type}</strong></div>`).join('');

      // Show progress bar
      const progressContainer = document.createElement('div');
      progressContainer.id = 'bulkProgressContainer';
      progressContainer.innerHTML = `
        <div style="margin: 10px 0; padding: 10px; background: #1b1b1b; border: 1px solid #333; border-radius: 4px;">
          <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
            <span>Bulk Import Progress</span>
            <span id="bulkProgressText">0/${plan.length}</span>
          </div>
          <div style="width: 100%; background: #333; border-radius: 2px; height: 20px; overflow: hidden;">
            <div id="bulkProgressBar" style="width: 0%; height: 100%; background: linear-gradient(90deg, #51cf66, #69db7c); transition: width 0.3s ease;"></div>
          </div>
        </div>
      `;
      document.getElementById('results').appendChild(progressContainer);
      
      // Force initial display and scroll to progress bar
      addResult('🔄 Starting bulk import with progress tracking...', 'info');
      progressContainer.scrollIntoView({ behavior: 'smooth' });
      
      // Debug: Check if elements exist
      console.log('Progress bar elements:', {
        container: document.getElementById('bulkProgressContainer'),
        bar: document.getElementById('bulkProgressBar'),
        text: document.getElementById('bulkProgressText')
      });

      // Import sequentially for clear logs
      let ok = 0;
      let totalCsvRows = 0;
      let totalImported = 0;
      for (let i=0;i<plan.length;i++){
        const p = plan[i];
        
        // Update progress
        const progress = ((i + 1) / plan.length) * 100;
        const progressBar = document.getElementById('bulkProgressBar');
        const progressText = document.getElementById('bulkProgressText');
        
        if (progressBar && progressText) {
          progressBar.style.width = progress + '%';
          progressText.textContent = `${i + 1}/${plan.length}`;
          console.log(`Progress: ${i + 1}/${plan.length} (${progress.toFixed(1)}%)`);
        } else {
          console.warn('Progress bar elements not found!', { progressBar, progressText });
        }
        
        addResult(`📦 Bulk importing ${p.file.name} as ${p.type}...`);
        try {
          const result = await importCSV(p.file, p.type);
          if (result && result.success) {
            ok++;
            totalCsvRows += result.csvRows || 0;
            totalImported += result.imported || 0;
            addResult(`✅ ${p.file.name} completed successfully`, 'success');
          } else {
            addResult(`❌ ${p.file.name} failed to import`, 'error');
          }
        } catch (error) {
          addResult(`❌ ${p.file.name} threw error: ${error.message}`, 'error');
        }
      }
      
      // Remove progress bar
      const progressEl = document.getElementById('bulkProgressContainer');
      if (progressEl) {
        progressEl.remove();
      }
      
      addResult(`✅ Bulk import finished: ${ok}/${plan.length} files imported`, 'success');
      addResult(`📊 Summary: ${totalImported}/${totalCsvRows} records imported (${totalCsvRows - totalImported} CSV rows not imported)`, 'info');

      // Update dashboard with CSV counts
      renderCategoryStats();
    }

    // Website scraping
    async function scrapeWebsite() {
      const siteUrlsFile = document.getElementById('siteUrlsCsv').files[0];
      if (!siteUrlsFile && !window.__cachedSiteUrlsText) {
        addResult('❌ Please select a Site URLs CSV file first', 'error');
        return;
      }

      // enable stop button
      let stopRequested = false;
      window.__stopScrape = () => { stopRequested = true; addResult('⏹️ Stop requested. Finishing current URL...', 'info'); };
      document.getElementById('stopScrapeBtn').style.display = 'inline-block';

      addResult('🕷️ Starting website scraping...');
      document.getElementById('stepScrape').style.background = '#3a3';
      document.getElementById('stepScrape').textContent = '2️⃣ Scrape URLs: running';
      const csvText = siteUrlsFile ? await siteUrlsFile.text() : String(window.__cachedSiteUrlsText || '');
      const lines = csvText.split('\n').filter(line => line.trim());
      const urls = lines.slice(1).map(line => line.split(',')[0]).filter(url => url && url.startsWith('http'));

      addResult(`📊 Found ${urls.length} URLs to scrape`);

      // stats counters
      stats.loadedRows = urls.length;
      stats.successCount = 0;
      stats.failedCount = 0;
      stats.stoppedCount = 0;
      updateStats();

      // Separate CSV import stats from URL scraping stats for clarity
      const cat = () => ({ success: 0, failed: 0, skipped: 0 });
      let csvImportStats = {
        'blog_articles': cat(),
        'course_events': cat(),
        'workshop_events': cat(),
        'service_pages': cat(),
        'service_products': cat(),
        'landing_pages': cat(),
        'test_questions': cat()
      };
      
      let urlScrapingStats = {
        'blog_articles': cat(),
        'course_events': cat(),
        'workshop_events': cat(),
        'service_pages': cat(),
        'service_products': cat(),
        'website_urls': cat(),
        'json_extraction': cat()
      };

      function categorize(url, result) {
        const u = (url||'').toLowerCase();
        // Broader patterns to catch more content
        if (u.includes('/blog') || u.includes('/news') || u.includes('/blog-on-photography')) return 'blog_articles';
        if (u.includes('/course') || u.includes('/lesson') || u.includes('/beginners-photography-lessons')) return 'course_events';
        if (u.includes('/workshop') || u.includes('/photo-workshop') || u.includes('/photographic-workshops-near-me') || u.includes('/photo-workshops-uk')) return 'workshop_events';
        if (u.includes('/service') || u.includes('/mentoring') || u.includes('/photography-services-near-me')) return 'service_products'; // Changed from service_pages
        if (u.includes('/shop') || u.includes('/product') || u.includes('/photography-shop') || u.includes('/photography-presents')) return 'service_products';
        if (u.includes('/landing') || u.includes('/page')) return 'website_urls'; // Changed from landing_pages
        
        // Check for JSON-LD content in result
        if (result && result.jsonLdFound) return 'json_extraction';
        
        // Everything else is a generic website URL
        return 'website_urls';
      }


      // Parallel worker pool
      const CONCURRENCY = 8;
      const TIMEOUT_MS = 20000;
      let nextIndex = 0;
      let completed = 0;

      async function worker(workerId) {
        while (true) {
          if (stopRequested) break;
          const i = nextIndex++;
          if (i >= urls.length) break;
          const url = urls[i];
          updateProgress((completed / urls.length) * 100, `Scraping ${url}...`);
          const result = await apiCall('/api/ingest-embed-replace', { url }, { timeoutMs: TIMEOUT_MS });
          const category = categorize(url, result);
          
          // Ensure category exists in urlScrapingStats
          if (!urlScrapingStats[category]) {
            urlScrapingStats[category] = { success: 0, failed: 0, skipped: 0 };
            console.log(`Created category ${category} in urlScrapingStats`);
          }
          
          if (result && (result.ok === true || (result.ok === undefined && result.status >= 200 && result.status < 300))) {
            if (result.message && result.message.includes('duplicates')) {
              addResult(`✅ Content already exists: ${url}  (source: site_urls.csv line ${i+2}) — ${result.message}`, 'success');
              urlScrapingStats[category].skipped++;
              stats.skippedCount++;
              console.log(`Updated ${category}: skipped=${urlScrapingStats[category].skipped}`);
              renderCategoryStats();
            } else {
              addResult(`✅ Scraped: ${url}`, 'success');
              stats.successCount++;
              urlScrapingStats[category].success++;
              console.log(`Updated ${category}: success=${urlScrapingStats[category].success}`);
              renderCategoryStats();
            }
          } else {
            const src = lines[i+1] || '';
            const reason = result && (result.error || result.detail || result.text) ? `${result.error || ''} ${result.detail || ''} ${result.text || ''}`.trim() : 'unknown';
            const reasonLc = reason.toLowerCase();
            if (reasonLc.includes('uniq_events_with_date') || reasonLc.includes('duplicate key value')) {
              addResult(`✅ Skipped duplicate: ${url}  (source: site_urls.csv line ${i+2}) — ${reason}`, 'success');
              urlScrapingStats[category].skipped++;
              stats.skippedCount++;
              console.log(`Updated ${category}: skipped=${urlScrapingStats[category].skipped}`);
              renderCategoryStats();
            } else if (reasonLc.includes('aborted') || reasonLc.includes('timeout')) {
              addResult(`❌ Timeout: ${url}  (source: site_urls.csv line ${i+2})`, 'error');
              stats.failedCount++;
              urlScrapingStats[category].failed++;
              console.log(`Updated ${category}: failed=${urlScrapingStats[category].failed}`);
              renderCategoryStats();
            } else {
              addResult(`❌ Failed: ${url}  (source: site_urls.csv line ${i+2}) — ${reason}`, 'error');
              stats.failedCount++;
              urlScrapingStats[category].failed++;
              console.log(`Updated ${category}: failed=${urlScrapingStats[category].failed}`);
              renderCategoryStats();
            }
          }
          completed++;
          updateProgress((completed / urls.length) * 100, `Scraping (${completed}/${urls.length})`);
          updateStats();
        }
      }

      const workers = Array.from({ length: Math.min(CONCURRENCY, urls.length) }, (_, idx) => worker(idx));
      await Promise.all(workers);

      if (stopRequested) {
        stats.stoppedCount = urls.length - completed;
        updateStats();
      }

      updateProgress(100, 'Website scraping complete');
      addResult('🎉 Website scraping complete!', 'success');
      document.getElementById('stepScrape').style.background = stats.failedCount === 0 ? '#2a6' : '#a62';
      document.getElementById('stepScrape').textContent = `2️⃣ Scrape URLs: ${stats.successCount} ok, ${stats.failedCount} failed, ${stats.stoppedCount} stopped`;
      document.getElementById('stopScrapeBtn').style.display = 'none';

      // Update parity after scraping completes
      updateParityPill();
    }

    function stopScrape() {
      if (typeof window.__stopScrape === 'function') window.__stopScrape();
    }

    // Event-Product mapping
    async function runMapping() {
      addResult('🔗 Running event → product mapping...');
      document.getElementById('stepMap').style.background = '#3a3';
      document.getElementById('stepMap').textContent = '3️⃣ Create Mappings: running';
      const token = getToken();
      try {
        // fetch before/after counts for dashboard clarity
        const before = await apiCall('/api/refresh-mappings', { preview: true });
        const result = await apiCall('/api/refresh-mappings', {});
        if (result && result.ok) {
          const mappingsCreated = result.mappingsCreated || 0;
          const afterCount = result.afterCount || 0;
          const beforeCount = before?.afterCount ?? before?.count ?? (afterCount - mappingsCreated);
          // also show live totals from the chat view
          // try consolidated backend counts first (service role), then fallback to REST counts
          let counts;
          try {
            const resp = await fetch('/api/tools?action=counts', { headers: { 'Authorization': `Bearer ${getToken()}` } });
            const j = await resp.json();
            if (resp.ok && j && j.ok) counts = { total: j.total, mapped: j.mapped };
          } catch {}
          if (!counts) counts = await getMappingCounts();
          addResult(`✅ Event → Product mapping complete! Created ${mappingsCreated} new mappings (${afterCount} auto-links). View totals: ${counts.mapped}/${counts.total} mapped.`, 'success');
          if (result.sampleMappings && result.sampleMappings.length > 0) {
            addResult(`📊 Sample mappings: ${result.sampleMappings.map(m => `${m.event_url} → ${m.product_url} (score: ${m.score})`).join(', ')}`, 'info');
          }
          document.getElementById('stepMap').style.background = '#2a6';
          document.getElementById('stepMap').textContent = `3️⃣ Create Mappings: ${counts.mapped}/${counts.total} mapped`;

          // Update parity as well (entities likely increased via backfill/refresh)
          updateParityPill();
        } else {
          const errorDetail = result?.detail || result?.error || 'Unknown error';
          addResult(`❌ Mapping failed: ${errorDetail}`, 'error');
          document.getElementById('stepMap').style.background = '#a62';
          document.getElementById('stepMap').textContent = '3️⃣ Create Mappings: failed';
        }
      } catch (e) {
        addResult(`❌ Mapping error: ${e.message}`, 'error');
        document.getElementById('stepMap').style.background = '#a62';
        document.getElementById('stepMap').textContent = '3️⃣ Create Mappings: failed';
      }
    }

    // Test functions
    async function testSingleUrl() {
      const url = document.getElementById('testUrl').value;
      if (!url) {
        addResult('❌ Please enter a URL to test', 'error');
        return;
      }

      addResult(`🧪 Testing URL: ${url}`);
      const result = await apiCall('/api/ingest-embed-replace', { url });
      if (result && result.ok) {
        addResult(`✅ URL test successful: ${url}`, 'success');
      } else {
        addResult(`❌ URL test failed: ${url}`, 'error');
      }
    }

    async function testQuery() {
      const query = document.getElementById('testQuery').value;
      if (!query) {
        addResult('❌ Please enter a question to test', 'error');
        return;
      }

      addResult(`🤖 Testing AI query: "${query}"`);
      const result = await apiCall('/api/chat', { query });
      if (result && result.answer) {
        addResult(`✅ AI Response: ${result.answer}`, 'success');
      } else {
        addResult(`❌ AI query failed`, 'error');
      }
    }

    // Extract structured JSON functions
    async function extractContent(contentType) {
      const url = document.getElementById('extractUrl').value;
      if (!url) {
        document.getElementById('extractResults').textContent = 'Please enter a URL first';
        return;
      }
      
      document.getElementById('extractResults').textContent = `Extracting ${contentType} from ${url}...`;
      
      try {
        const response = await fetch('/api/ingest-embed-replace', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${getToken()}`
          },
          body: JSON.stringify({ url })
        });
        
        const result = await response.json();
        document.getElementById('extractResults').textContent = JSON.stringify(result, null, 2);
      } catch (error) {
        document.getElementById('extractResults').textContent = `Error: ${error.message}`;
      }
    }
    
    function clearExtractResults() {
      document.getElementById('extractResults').textContent = '';
    }

    // Download debug log
    function downloadDebugLog() {
      const logText = logEntries.map(e => `[${e.time}] ${e.message}`).join('\n');
      const blob = new Blob([logText], { type: 'text/plain;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `debug-log-${new Date().toISOString().replace(/[:.]/g,'-')}.txt`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      addResult('⬇️ Debug log downloaded.', 'success');
    }

    // Export mappings CSV
    async function exportMappings(){
      try{
        const resp = await fetch('/api/tools?action=export', { headers: { 'Authorization': `Bearer ${getToken()}` } });
        if (!resp.ok){ addResult(`❌ Export failed: ${resp.status}`, 'error'); return; }
        const blob = await resp.blob();
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = `event-product-mappings-${new Date().toISOString().replace(/[:.]/g,'-')}.csv`;
        document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
        addResult('⬇️ Exported mappings CSV', 'success');
      }catch(e){ addResult(`❌ Export error: ${e.message}`, 'error'); }
    }

    // Export unmapped events
    async function exportUnmapped(){
      try{
        const resp = await fetch('/api/tools?action=export_unmapped', { headers: { 'Authorization': `Bearer ${getToken()}` } });
        if (!resp.ok){ addResult(`❌ Export unmapped failed: ${resp.status}`, 'error'); return; }
        const blob = await resp.blob();
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = `unmapped-events-${new Date().toISOString().replace(/[:.]/g,'-')}.csv`;
        document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
        addResult('⬇️ Exported unmapped events CSV', 'success');
      }catch(e){ addResult(`❌ Export unmapped error: ${e.message}`, 'error'); }
    }

    // CSV parser (minimal, quoted fields supported)
    function parseCSV(text){
      const rows=[]; let row=[], val='', inQ=false;
      function pushVal(){ row.push(val); val=''; }
      function pushRow(){ if(row.length){ rows.push(row); } row=[]; }
      for(let i=0;i<text.length;i++){
        const ch=text[i];
        if(inQ){
          if(ch==='"'){
            if(text[i+1]==='"'){ val+='"'; i++; } else { inQ=false; }
          } else { val+=ch; }
        } else {
          if(ch==='"'){ inQ=true; }
          else if(ch===','){ pushVal(); }
          else if(ch==='\n'){ pushVal(); pushRow(); }
          else if(ch!=='\r'){ val+=ch; }
        }
      }
      if(val.length||row.length){ pushVal(); pushRow(); }
      if(!rows.length) return [];
      const header = rows[0].map(h => (h||'').trim().toLowerCase());
      return rows.slice(1).map(r => {
        const o={};
        for(let i=0;i<header.length;i++){ o[header[i]]=(r[i]||'').trim(); }
        return o;
      });
    }

    // Test Questions Batch Runner
    async function runTestQuestions(){
      try{
        addResult('🤖 Starting test questions batch...', 'info');
        
        // Load test questions from CSV
        const testQuestionsFile = document.getElementById('testQuestionsCsv').files[0];
        if (!testQuestionsFile) {
          addResult('❌ Please select test questions CSV file first', 'error');
          return;
        }
        
        const csvText = await testQuestionsFile.text();
        const questions = parseCSV(csvText);
        
        if (!questions.length) {
          addResult('❌ No test questions found in CSV', 'error');
          return;
        }
        
        addResult(`📝 Found ${questions.length} test questions`, 'info');
        
        const results = [];
        let processed = 0;
        
        for (const question of questions) {
          if (!question.query) continue;
          
          try {
            addResult(`🤖 Testing: "${question.query}"`, 'info');
            
            // Call the AI bot
            const response = await fetch('/api/chat', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${getToken()}`
              },
              body: JSON.stringify({
                query: question.query,
                topK: 8
              })
            });
            
            if (!response.ok) {
              throw new Error(`HTTP ${response.status}`);
            }
            
            const data = await response.json();
            const answer = data.answer || 'No answer provided';
            const citations = (data.citations || []).join('; ');
            
            results.push({
              query: question.query,
              expected: question.expected || '',
              answer: answer,
              citations: citations,
              timestamp: new Date().toISOString()
            });
            
            processed++;
            addResult(`✅ Completed ${processed}/${questions.length}`, 'success');
            
            // Small delay to avoid overwhelming the API
            await new Promise(resolve => setTimeout(resolve, 500));
            
          } catch (error) {
            addResult(`❌ Failed: "${question.query}" - ${error.message}`, 'error');
            results.push({
              query: question.query,
              expected: question.expected || '',
              answer: `ERROR: ${error.message}`,
              citations: '',
              timestamp: new Date().toISOString()
            });
            processed++;
          }
        }
        
        // Export results to CSV
        const csvHeader = 'query,expected,answer,citations,timestamp\n';
        const csvRows = results.map(r => {
          const escape = (s) => `"${String(s || '').replace(/"/g, '""')}"`;
          return `${escape(r.query)},${escape(r.expected)},${escape(r.answer)},${escape(r.citations)},${escape(r.timestamp)}`;
        }).join('\n');
        
        const csvContent = csvHeader + csvRows;
        const blob = new Blob([csvContent], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `test-questions-results-${new Date().toISOString().replace(/[:.]/g,'-')}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        addResult(`🎉 Test questions complete! Processed ${processed}/${questions.length}. Results exported to CSV.`, 'success');
        
      } catch (error) {
        addResult(`❌ Test questions batch failed: ${error.message}`, 'error');
      }
    }
    
    // Statistics tracking
    let stats = {
      loadedRows: 0,
      successCount: 0,
      failedCount: 0,
      stoppedCount: 0
    };
    
    // CSV row counts for dashboard display
    let csvRowCounts = {
      'blog_articles': 0,
      'course_events': 0,
      'workshop_events': 0,
      'service_products': 0,
      'website_urls': 0
    };
    
    // URL scraping stats for dashboard display
    let urlScrapingStats = {
      'blog_articles': { success: 0, failed: 0, skipped: 0 },
      'course_events': { success: 0, failed: 0, skipped: 0 },
      'workshop_events': { success: 0, failed: 0, skipped: 0 },
      'service_products': { success: 0, failed: 0, skipped: 0 },
      'website_urls': { success: 0, failed: 0, skipped: 0 },
      'json_extraction': { success: 0, failed: 0, skipped: 0 }
    };
    
    // Map import content types to dashboard category keys
    const contentTypeToCsvKey = {
      'blog': 'blog_articles',
      'event': 'course_events',
      'workshop': 'workshop_events',
      'product': 'service_products',
      'site_urls': 'website_urls',
      'test_questions': 'test_questions'
    };
    
    // Global function to render category stats
    function renderCategoryStats() {
      const el = document.getElementById('categoryStats');
      if (!el) return; // Element might not exist yet
      
      // Format category names for display
      const formatCategory = (cat) => {
        const labels = {
          'blog_articles': 'Blog Articles',
          'course_events': 'Course Events',
          'workshop_events': 'Workshop Events',
          'service_products': 'Service Products',
          'website_urls': 'Website URLs',
          'json_extraction': 'JSON Extraction'
        };
        return labels[cat] || cat;
      };
      
      // Combine both stats for display
      const combinedStats = {};
      Object.keys(urlScrapingStats || {}).forEach(key => {
        combinedStats[key] = {
          success: (urlScrapingStats[key]?.success || 0),
          failed: (urlScrapingStats[key]?.failed || 0),
          skipped: (urlScrapingStats[key]?.skipped || 0)
        };
      });
      
      const rows = Object.entries(combinedStats).map(([k,v]) => {
        const csvCount = csvRowCounts[k] || 0;
        const csvDisplay = csvCount > 0 ? ` (${csvCount} CSV)` : '';
        return `<tr><td style="padding:4px 8px;">${formatCategory(k)}${csvDisplay}</td><td style="color:#51cf66">${v.success}</td><td style="color:#ff6b6b">${v.failed}</td><td style="color:#74c0fc">${v.skipped}</td></tr>`;
      }).join('');
      el.innerHTML = `<table style="width:100%;border-collapse:collapse;margin-top:6px;background:#1b1b1b;border:1px solid #333"><thead><tr><th style="text-align:left;padding:4px 8px;">Category</th><th style="text-align:left;padding:4px 8px;">Success</th><th style="text-align:left;padding:4px 8px;">Failed</th><th style="text-align:left;padding:4px 8px;">Skipped</th></tr></thead><tbody>${rows}</tbody></table>`;
    }
    
    function updateStats() {
      document.getElementById('loadedRows').textContent = stats.loadedRows;
      document.getElementById('successCount').textContent = stats.successCount;
      document.getElementById('failedCount').textContent = stats.failedCount;
      document.getElementById('stoppedCount').textContent = stats.stoppedCount;
      const skipped = (stats.loadedRows - (stats.successCount + stats.failedCount + stats.stoppedCount));
      document.getElementById('skippedCount').textContent = skipped;
    }
    
    function resetStats() {
      stats = { loadedRows: 0, successCount: 0, failedCount: 0, stoppedCount: 0 };
      updateStats();
    }

    // Load hardcoded token on page load
    window.onload = function() {
      addResult('✅ Hardcoded token ready for use');
      updateStats();
    };
  </script>
</body>
</html>
