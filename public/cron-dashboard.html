<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cron Job Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: #f5f5f5;
      padding: 20px;
      color: #333;
    }

    .container {
      max-width: 1800px;
      margin: 0 auto;
    }

    .job-section {
      margin-bottom: 30px;
    }

    .job-section-header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 15px 20px;
      border-radius: 8px 8px 0 0;
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 0;
    }

    .job-section-header.analytics {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    }

    .job-section-header.refresh {
      background: linear-gradient(135deg, #00f2fe 0%, #4facfe 100%);
    }

    .job-section-header.maintenance {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    }

    .job-section-header.performance {
      background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
    }

    .job-section-header.health {
      background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
    }

    .job-section-header.system {
      background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
    }

    .job-section-content {
      background: #f8f9fa;
      padding: 20px;
      border-radius: 0 0 8px 8px;
      border: 2px solid #e0e0e0;
    }

    h1 {
      margin-bottom: 30px;
      color: #2c3e50;
    }

    .auth-section {
      background: white;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .auth-section input {
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      width: 300px;
      margin-right: 10px;
    }

    .auth-section button {
      padding: 10px 20px;
      background: #3498db;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    .auth-section button:hover {
      background: #2980b9;
    }

    .controls {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    .btn {
      padding: 10px 20px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }

    .btn-primary {
      background: #3498db;
      color: white;
    }

    .btn-primary:hover {
      background: #2980b9;
    }

    .btn-secondary {
      background: #95a5a6;
      color: white;
    }

    .btn-secondary:hover {
      background: #7f8c8d;
    }

    .debug-log-container {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: #1e1e1e;
      color: #d4d4d4;
      border-top: 2px solid #007acc;
      max-height: 300px;
      display: flex;
      flex-direction: column;
      z-index: 10000;
      font-family: 'Courier New', monospace;
      font-size: 12px;
    }

    .debug-log-header {
      background: #252526;
      padding: 8px 15px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #3e3e42;
    }

    .debug-log-title {
      font-weight: bold;
      color: #4ec9b0;
    }

    .debug-log-controls {
      display: flex;
      gap: 10px;
    }

    .debug-log-content {
      flex: 1;
      overflow-y: auto;
      padding: 10px 15px;
      line-height: 1.6;
    }

    .debug-log-entry {
      margin-bottom: 4px;
      padding: 2px 0;
    }

    .debug-log-entry.error {
      color: #f48771;
    }

    .debug-log-entry.success {
      color: #4ec9b0;
    }

    .debug-log-entry.warning {
      color: #dcdcaa;
    }

    .debug-log-entry.info {
      color: #9cdcfe;
    }

    .debug-log-timestamp {
      color: #808080;
      margin-right: 8px;
    }

    .btn-warning {
      background: #f39c12;
      color: white;
    }

    .btn-warning:hover {
      background: #e67e22;
    }

    .btn-success {
      background: #27ae60;
      color: white;
    }

    .btn-success:hover {
      background: #229954;
    }

    .status-badge {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: bold;
    }

    .status-active {
      background: #2ecc71;
      color: white;
    }

    .status-inactive {
      background: #95a5a6;
      color: white;
    }

    .status-success {
      background: #2ecc71;
      color: white;
    }

    .status-failed {
      background: #e74c3c;
      color: white;
    }

    .badge-success {
      background-color: #4CAF50;
      color: white;
      padding: 3px 8px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: bold;
    }

    .badge-failure {
      background-color: #E53935;
      color: white;
      padding: 3px 8px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: bold;
    }

    .log-panel {
      background: #f7f7f7;
      padding: 10px;
      margin-top: 10px;
      border-radius: 6px;
      font-family: monospace;
      font-size: 12px;
      max-height: 250px;
      overflow-y: auto;
    }


    canvas {
      width: 100% !important;
      height: 100px !important;
    }

    .jobs-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .job-card {
      background: white;
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .job-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }

    .job-header {
      display: flex;
      justify-content: space-between;
      align-items: start;
      margin-bottom: 15px;
    }

    .job-title {
      font-size: 18px;
      font-weight: bold;
      color: #2c3e50;
    }

    .job-id {
      color: #2c3e50;
      font-size: 15px;
      font-weight: 600;
      margin-top: 6px;
      line-height: 1.5;
    }

    .job-description {
      color: #000000;
      font-size: 16px;
      margin-bottom: 15px;
      line-height: 1.6;
      font-weight: 400;
    }

    .frequency-pill {
      display: inline-block;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 13px;
      font-weight: 600;
      margin-bottom: 15px;
      margin-right: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .next-scheduled-pill {
      display: inline-block;
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      color: white;
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 13px;
      font-weight: 600;
      margin-bottom: 15px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .regression-test-section {
      background: #fff3cd;
      border: 1px solid #ffc107;
      border-radius: 6px;
      padding: 12px;
      margin: 15px 0;
      font-size: 13px;
    }

    .regression-test-section.severe {
      background: #f8d7da;
      border-color: #dc3545;
    }

    .regression-test-section.moderate {
      background: #fff3cd;
      border-color: #ffc107;
    }

    .regression-test-section.minor {
      background: #d1ecf1;
      border-color: #17a2b8;
    }

    .regression-test-section.no-regression {
      background: #d4edda;
      border-color: #28a745;
    }

    .regression-summary {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 10px;
    }

    .regression-stat {
      font-size: 12px;
    }

    .regression-stat-label {
      color: #6c757d;
      font-weight: 600;
    }

    .regression-stat-value {
      color: #2c3e50;
      font-weight: bold;
    }

    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
      overflow: auto;
    }

    .modal-content {
      background-color: #fefefe;
      margin: 5% auto;
      padding: 20px;
      border: 1px solid #888;
      border-radius: 8px;
      width: 90%;
      max-width: 1200px;
      max-height: 80vh;
      overflow-y: auto;
    }

    .close {
      color: #aaa;
      float: right;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
    }

    .close:hover {
      color: #000;
    }

    .details-section {
      margin: 20px 0;
      padding: 15px;
      background: #f8f9fa;
      border-radius: 6px;
    }

    .details-section h3 {
      margin-bottom: 10px;
      color: #2c3e50;
    }

    .query-change {
      margin: 10px 0;
      padding: 10px;
      background: white;
      border-left: 4px solid #3498db;
      border-radius: 4px;
    }

    .query-change.severe {
      border-left-color: #e74c3c;
    }

    .query-change.moderate {
      border-left-color: #f39c12;
    }

    .query-change.minor {
      border-left-color: #3498db;
    }

    .article-list {
      margin: 5px 0;
      font-size: 13px;
    }

    .article-removed {
      color: #e74c3c;
    }

    .article-added {
      color: #27ae60;
    }

    .job-schedule {
      background: #ecf0f1;
      padding: 8px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 13px;
      margin-bottom: 15px;
    }

    .job-stats {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin-bottom: 15px;
    }

    .stat-item {
      text-align: center;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 4px;
    }

    .stat-label {
      font-size: 12px;
      color: #7f8c8d;
      margin-bottom: 5px;
    }

    .stat-value {
      font-size: 18px;
      font-weight: bold;
      color: #2c3e50;
    }

    .success-rate {
      font-size: 14px;
      color: #2ecc71;
    }

    .failure-rate {
      font-size: 14px;
      color: #e74c3c;
    }

    .job-actions {
      display: flex;
      gap: 10px;
      margin-top: 15px;
    }

    .btn-small {
      padding: 6px 12px;
      font-size: 12px;
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      z-index: 1000;
      overflow-y: auto;
    }

    .modal.active {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .modal-content {
      background: white;
      border-radius: 8px;
      padding: 30px;
      max-width: 800px;
      width: 100%;
      max-height: 90vh;
      overflow-y: auto;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .modal-title {
      font-size: 24px;
      font-weight: bold;
    }

    .close-btn {
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
      color: #7f8c8d;
    }

    .close-btn:hover {
      color: #2c3e50;
    }

    .form-group {
      margin-bottom: 20px;
    }

    .form-group label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }

    .form-group input {
      width: 100%;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-family: monospace;
    }

    .form-group small {
      color: #7f8c8d;
      font-size: 12px;
    }

    .logs-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
    }

    .logs-table th,
    .logs-table td {
      padding: 10px;
      text-align: left;
      border-bottom: 1px solid #ddd;
    }

    .logs-table th {
      background: #f8f9fa;
      font-weight: bold;
    }

    .logs-table tr:hover {
      background: #f8f9fa;
    }

    .command-preview {
      background: #2c3e50;
      color: #ecf0f1;
      padding: 15px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 12px;
      overflow-x: auto;
      margin-top: 10px;
      max-height: 200px;
      overflow-y: auto;
    }

    .loading {
      text-align: center;
      padding: 40px;
      color: #7f8c8d;
    }

    .error {
      background: #fee;
      color: #c33;
      padding: 15px;
      border-radius: 4px;
      margin-bottom: 20px;
    }

    .success {
      background: #efe;
      color: #3c3;
      padding: 15px;
      border-radius: 4px;
      margin-bottom: 20px;
    }

    .cron-presets {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 10px;
    }

    .preset-btn {
      padding: 6px 12px;
      background: #ecf0f1;
      border: 1px solid #bdc3c7;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }

    .preset-btn:hover {
      background: #bdc3c7;
    }

    .freq-input {
      width: 80px;
      padding: 4px 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      margin: 0 5px;
      font-size: 14px;
    }

    .save-freq-btn {
      padding: 4px 12px;
      background: #3498db;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }

    .save-freq-btn:hover {
      background: #2980b9;
    }

    .next-run-badge {
      display: inline-block;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 600;
      margin-left: 8px;
    }

    .health-status {
      display: inline-block;
      padding: 4px 10px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 600;
      margin-bottom: 10px;
      margin-top: 5px;
    }

    .health-status.health-ok {
      background: #4CAF50;
      color: white;
    }

    .health-status.health-warning {
      background: #ff9900;
      color: white;
    }

    .health-status.health-error {
      background: #ff4d4d;
      color: white;
    }

    .sparkline-container {
      margin-top: 6px;
      position: relative;
    }

    .sparkline-section {
      margin-top: 15px;
      margin-bottom: 10px;
    }

    .sparkline {
      width: 150px;
      height: 50px;
      display: block;
    }

    .view-logs-btn {
      background: #6c757d;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      margin-top: 10px;
    }

    .view-logs-btn:hover {
      background: #5a6268;
    }

    .log-drawer {
      margin-top: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: #f8f9fa;
      padding: 0;
    }

    .log-drawer-header {
      background: #e9ecef;
      padding: 8px 12px;
      font-weight: 600;
      font-size: 13px;
      border-bottom: 1px solid #ddd;
      border-radius: 4px 4px 0 0;
    }

    .log-drawer-content {
      max-height: 220px;
      overflow-y: auto;
      padding: 10px;
    }

    .log-entry {
      padding: 8px;
      margin-bottom: 8px;
      background: white;
      border-radius: 4px;
      border-left: 3px solid #ddd;
    }

    .log-entry-header {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-bottom: 5px;
      font-size: 11px;
    }

    .log-status-badge {
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 10px;
      font-weight: 600;
    }

    .log-status-badge.status-success {
      background: #4CAF50;
      color: white;
    }

    .log-status-badge.status-failed {
      background: #E53935;
      color: white;
    }

    .log-timestamp {
      color: #666;
    }

    .log-duration {
      color: #999;
      font-size: 10px;
    }

    .log-message {
      font-size: 12px;
      color: #333;
      word-wrap: break-word;
    }

    .log-error-message {
      color: #E53935;
    }

    .log-loading {
      padding: 20px;
      text-align: center;
      color: #666;
    }

    .log-empty {
      padding: 20px;
      text-align: center;
      color: #999;
    }

    .log-error {
      padding: 15px;
      color: #E53935;
      background: #fee;
      border-radius: 4px;
      margin: 10px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Cron Job Dashboard</h1>

    <div class="auth-section" id="authSection">
      <h3>Authentication</h3>
      <input type="password" id="authToken" placeholder="Enter admin token (default: b6c3f0c9e6f44cce9e1a4f3f2d3a5c76)" value="b6c3f0c9e6f44cce9e1a4f3f2d3a5c76" />
      <button onclick="setAuthToken()">Authenticate</button>
      <div style="margin-top: 8px; font-size: 12px; color: #666;">Token: Use INGEST_TOKEN or the default token shown above</div>
    </div>

    <div id="dashboard" style="display: none;">
      <div class="controls">
        <button class="btn btn-primary" onclick="loadJobs()">Refresh Jobs</button>
        <button class="btn btn-secondary" onclick="clearAuth()">Logout</button>
      </div>

      <div id="message"></div>
      <div id="jobsContainer" class="loading">Loading cron jobs...</div>
    </div>
  </div>

  <!-- Schedule Modal -->
  <div class="modal" id="scheduleModal">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">Update Schedule</div>
        <button class="close-btn" onclick="closeScheduleModal()">&times;</button>
      </div>
      <div id="scheduleModalContent"></div>
    </div>
  </div>

  <!-- Logs Modal -->
  <div class="modal" id="logsModal">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">Job Logs</div>
        <button class="close-btn" onclick="closeLogsModal()">&times;</button>
      </div>
      <div id="logsModalContent"></div>
    </div>
  </div>

  <script>
    /**
     * @typedef {Object} JobSummary
     * @property {number} jobid
     * @property {string} name
     * @property {number} frequency_minutes
     * @property {string|null} last_run      // ISO string, may be null
     * @property {number} total_runs
     * @property {number} success_count
     * @property {number} failed_count
     * @property {('active'|'paused'|'inactive')} status
     * @property {Array<{ date: string, success: boolean }>} recent_runs
     * @property {string} schedule
     * @property {string} jobname
     * @property {string} command
     */

    const API_BASE = window.location.origin;
    
    // Default admin token (INGEST_TOKEN)
    const DEFAULT_TOKEN = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImlnenZ3YnZndm16dnZ6b2NsdWZ4Iiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc1NzY3NzkyOCwiZXhwIjoyMDczMjUzOTI4fQ.W9tkTSYu6Wml0mUr-gJD6hcLMZDcbaYYaOsyDXuwd8M';
    
    let authToken = localStorage.getItem('cron_dashboard_token') || DEFAULT_TOKEN;

    // State for inline log viewer
    let activeLogJobId = null;
    const jobLogsCache = new Map(); // jobId -> { loading, error, entries }

    // Job descriptions
    const jobDescriptions = {
      13: 'Aggregates daily analytics from chat bot usage logs (user sessions, questions asked, answers given, confidence scores, and response times) for a specific date 7 days ago. Stores the results in chat_analytics_daily for historical reporting.',
      19: 'Analyzes all chat questions from the last 7 days, groups identical questions, counts how many times each was asked, calculates average confidence scores, and tracks which questions have low confidence. Updates the chat_question_frequency table to identify frequently asked questions and which ones need better answers. Powers the Questions tab in analytics.html.',
      20: 'Aggregates today\'s analytics from chat bot usage logs (sessions, questions, interactions, averages) and updates session records with total questions and interactions per session. Powers the Overview tab in analytics.html.',
      21: 'Refreshes the unified products materialized view which consolidates product data from multiple sources (page_entities, product_display_price, CSV metadata) into a single deduplicated view. Resolves product types (workshop vs course), extracts location hints, availability status, and pricing. Then updates display prices for all products by processing them in batches. The refreshed view feeds into v_products_unified_open ‚Üí v_events_for_chat, which provides product pricing for events displayed in the chat bot. Ensures event pricing shown in chat responses is current.',
      22: 'Analyzes chat interactions from the last 30 days to find questions with low confidence scores (< 0.6). Groups identical questions, calculates frequency and average confidence, identifies which questions need better answers, and generates prioritized improvement recommendations (missing content, content gaps, intent confusion, high-impact fixes). Excludes questions already processed. Stores results in content_improvement_tracking table. Powers the Insights tab in analytics.html where you can review recommendations and mark questions as improved or ignored.',
      26: 'Reads all URLs from the site URLs CSV file, makes HEAD requests to check each URL\'s Last-Modified header, compares with database records to detect content changes, and re-ingests only changed URLs (full content extraction, embeddings, page_entities, page_chunks). Processes URLs in batches of 20. Batch 0 handles the first third of URLs plus the camera course URL. Keeps the database in sync with website changes without requiring full re-ingestion.',
      27: 'Reads all URLs from the site URLs CSV file, makes HEAD requests to check each URL\'s Last-Modified header, compares with database records to detect content changes, and re-ingests only changed URLs (full content extraction, embeddings, page_entities, page_chunks). Processes URLs in batches of 20. Batch 1 handles the second third of URLs. Keeps the database in sync with website changes without requiring full re-ingestion.',
      28: 'Reads all URLs from the site URLs CSV file, makes HEAD requests to check each URL\'s Last-Modified header, compares with database records to detect content changes, and re-ingests only changed URLs (full content extraction, embeddings, page_entities, page_chunks). Processes URLs in batches of 20. Batch 2 handles the final third of URLs. Keeps the database in sync with website changes without requiring full re-ingestion.',
      29: 'Deletes old chat data (sessions, interactions, events) older than 90 days to prevent database bloat and maintain performance. Keeps the database size manageable while preserving recent chat history for analytics.',
      30: 'Removes debug logs older than 30 days from the debug_logs table. Prevents the debug logs table from growing indefinitely and consuming excessive storage space.',
      31: 'Identifies and removes orphaned records in the database. Deletes page_chunks that reference non-existent page_entities, and page_entities that reference non-existent csv_metadata records. Maintains data integrity and prevents referential inconsistencies.',
      32: 'Runs VACUUM and ANALYZE on key database tables to reclaim storage space, update query statistics, and optimize query performance. Processes high-traffic tables including chat tables, page entities, events, and products.',
      33: 'Checks the health of all URLs in the system. Identifies broken URLs (HTTP 4xx/5xx errors), stale URLs (not updated in 90+ days), and healthy URLs. Helps maintain content quality and identify pages that need attention.',
      34: 'Validates that all page chunks have proper embeddings for RAG search functionality. Counts total chunks, chunks with embeddings, and chunks missing embeddings. Ensures the chat bot can properly search and retrieve content.',
      35: 'Analyzes content freshness across all URLs. Identifies content that hasn\'t been updated in 60+ days and calculates average content age. Helps identify stale content that may need refreshing or removal.',
      36: 'Backs up daily analytics data to ensure long-term retention. Verifies that yesterday\'s analytics data has been properly stored in chat_analytics_daily table for historical reporting and analysis.',
      37: 'Monitors the health of all active cron jobs. Identifies jobs with recent failures (more than 3 failures in 24 hours = critical, any failures = warning) or jobs that haven\'t succeeded in 48+ hours. Helps detect and alert on system issues early.'
    };

    // Define linked jobs (jobs that run together and are related)
    // Jobs 13, 19, 20, and 22 are all linked together (analytics jobs)
    // Jobs 26, 27, and 28 are all linked together (refresh batches)
    const linkedJobs = {
      13: [19, 20, 22],  // Job 13 is linked to Jobs 19, 20, and 22
      19: [13, 20, 22],  // Job 19 is linked to Jobs 13, 20, and 22
      20: [13, 19, 22],  // Job 20 is linked to Jobs 13, 19, and 22
      22: [13, 19, 20],  // Job 22 is linked to Jobs 13, 19, and 20
      26: [27, 28],  // Job 26 is linked to Jobs 27 and 28
      27: [26, 28],  // Job 27 is linked to Jobs 26 and 28
      28: [26, 27]   // Job 28 is linked to Jobs 26 and 27
    };

    // Custom display names for jobs
    const jobDisplayNames = {
      26: 'Website Pages Refresh Batch 0',
      27: 'Website Pages Refresh Batch 1',
      28: 'Website Pages Refresh Batch 2'
    };

    function setAuthToken() {
      const tokenInput = document.getElementById('authToken');
      const token = tokenInput ? tokenInput.value : DEFAULT_TOKEN;
      if (token) {
        authToken = token;
        localStorage.setItem('cron_dashboard_token', token);
        document.getElementById('authSection').style.display = 'none';
        document.getElementById('dashboard').style.display = 'block';
        loadJobs();
      }
    }

    function clearAuth() {
      authToken = '';
      localStorage.removeItem('cron_dashboard_token');
      document.getElementById('authSection').style.display = 'block';
      const tokenInput = document.getElementById('authToken');
      if (tokenInput) {
        tokenInput.value = DEFAULT_TOKEN;
      }
      document.getElementById('dashboard').style.display = 'none';
    }

    // Auto-authenticate on page load if token is available
    window.addEventListener('DOMContentLoaded', function() {
      const tokenInput = document.getElementById('authToken');
      if (tokenInput) {
        tokenInput.value = DEFAULT_TOKEN;
      }
      
      if (authToken) {
        document.getElementById('authSection').style.display = 'none';
        document.getElementById('dashboard').style.display = 'block';
        loadJobs();
      }
    });

    const buildAuthHeaders = () => ({
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${authToken}`
    });

    /**
     * Normalize API job data to JobSummary shape
     * @param {Object} apiJob - Raw job data from API
     * @returns {JobSummary}
     */
    function normalizeJob(apiJob) {
      return {
        jobid: apiJob.jobid,
        name: apiJob.jobname || apiJob.name || `Job ${apiJob.jobid}`,
        frequency_minutes: apiJob.frequency_minutes || 60,
        last_run: apiJob.last_run || null,
        total_runs: apiJob.total_runs || 0,
        success_count: apiJob.success_count || 0,
        failed_count: apiJob.failed_count || 0,
        status: apiJob.active ? 'active' : 'inactive',
        recent_runs: apiJob.recent_runs || [],
        schedule: apiJob.schedule || '',
        jobname: apiJob.jobname || apiJob.name || `Job ${apiJob.jobid}`,
        command: apiJob.command || ''
      };
    }

    async function loadJobs() {
      addDebugLog('Loading jobs...', 'info');
      const container = document.getElementById('jobsContainer');
      container.innerHTML = '<div class="loading">Loading cron jobs...</div>';

      try {
        const response = await fetch(`${API_BASE}/api/admin?action=cron_jobs`, {
          headers: buildAuthHeaders()
        });
        
        addDebugLog(`Jobs API response: ${response.status} ${response.statusText}`, 'info');

        if (response.status === 401) {
          clearAuth();
          showMessage('Authentication failed. Please login again.', 'error');
          return;
        }

        // Check if response is JSON and handle parsing errors
        let data;
        try {
          const contentType = response.headers.get('content-type');
          if (!contentType || !contentType.includes('application/json')) {
            const text = await response.text();
            throw new Error(`Server returned non-JSON response (${response.status}): ${text.substring(0, 200)}`);
          }
          data = await response.json();
        } catch (parseError) {
          // If JSON parsing fails, try to get the text response
          const text = await response.text().catch(() => 'Unable to read response');
          throw new Error(`Failed to parse server response (${response.status}): ${text.substring(0, 200)}`);
        }

        if (!data || !data.ok) {
          throw new Error(data?.error || data?.detail || 'Failed to load jobs');
        }

        // Normalize jobs to JobSummary shape
        const rawJobs = data.jobs || [];
        const jobs = rawJobs.map(normalizeJob);
        
        addDebugLog(`Loaded ${jobs.length} jobs from API`, 'success', { jobCount: jobs.length, jobIds: jobs.map(j => j.jobid) });
        
        // Log stats for each job
        jobs.forEach(job => {
          addDebugLog(`Job ${job.jobid} (${job.name}): ${job.total_runs} runs, ${job.success_count} succeeded, ${job.failed_count} failed`, 'info', {
            jobid: job.jobid,
            total_runs: job.total_runs,
            success_count: job.success_count,
            failed_count: job.failed_count,
            last_run: job.last_run
          });
        });
        
        const regressionPromises = jobs
          .filter(job => riskyJobs.includes(job.jobid))
          .map(job => loadRegressionTestData(job.jobid).then(data => ({ jobid: job.jobid, data })));
        
        const regressionResults = await Promise.all(regressionPromises);
        regressionResults.forEach(({ jobid, data }) => {
          regressionTestData[jobid] = data;
        });

        await renderJobs(jobs);
        addDebugLog('Jobs rendered successfully', 'success');
      } catch (error) {
        addDebugLog(`Error loading jobs: ${error.message}`, 'error', { error: error.message, stack: error.stack });
        container.innerHTML = `<div class="error">Error loading jobs: ${error.message}</div>`;
      }
    }

    async function renderJobs(jobs) {
      const container = document.getElementById('jobsContainer');
      
      if (jobs.length === 0) {
        container.innerHTML = '<div class="loading">No cron jobs found.</div>';
        return;
      }

      // Build a set of all linked job IDs
      const linkedJobSet = new Set();
      Object.keys(linkedJobs).forEach(jobId => {
        linkedJobSet.add(parseInt(jobId));
        const links = Array.isArray(linkedJobs[jobId]) ? linkedJobs[jobId] : [linkedJobs[jobId]];
        links.forEach(linkId => linkedJobSet.add(linkId));
      });

      // Define job groups
      const analyticsJobs = [13, 19, 20, 22];
      const refreshBatches = [26, 27, 28];
      const dataMaintenanceJobs = [29, 30, 31];
      const databasePerformanceJobs = [32];
      const contentHealthJobs = [33, 34, 35];
      const systemHealthJobs = [36, 37];
      
      // Separate jobs into groups
      const analyticsGroup = jobs.filter(j => analyticsJobs.includes(j.jobid)).sort((a, b) => a.jobid - b.jobid);
      const refreshGroup = jobs.filter(j => refreshBatches.includes(j.jobid)).sort((a, b) => a.jobid - b.jobid);
      const dataMaintenanceGroup = jobs.filter(j => dataMaintenanceJobs.includes(j.jobid)).sort((a, b) => a.jobid - b.jobid);
      const databasePerformanceGroup = jobs.filter(j => databasePerformanceJobs.includes(j.jobid)).sort((a, b) => a.jobid - b.jobid);
      const contentHealthGroup = jobs.filter(j => contentHealthJobs.includes(j.jobid)).sort((a, b) => a.jobid - b.jobid);
      const systemHealthGroup = jobs.filter(j => systemHealthJobs.includes(j.jobid)).sort((a, b) => a.jobid - b.jobid);
      const otherJobs = jobs.filter(j => 
        !analyticsJobs.includes(j.jobid) && 
        !refreshBatches.includes(j.jobid) &&
        !dataMaintenanceJobs.includes(j.jobid) &&
        !databasePerformanceJobs.includes(j.jobid) &&
        !contentHealthJobs.includes(j.jobid) &&
        !systemHealthJobs.includes(j.jobid)
      ).sort((a, b) => a.jobid - b.jobid);

      let html = '';

      // Render Analytics Jobs Section
      if (analyticsGroup.length > 0) {
        html += '<div class="job-section">';
        html += '<div class="job-section-header analytics">üìä Chat Quality Analytics Jobs</div>';
        html += '<div class="job-section-content">';
        html += '<div class="jobs-grid" style="grid-template-columns: repeat(4, 1fr);">';
        
        analyticsGroup.forEach((job) => {
          html += renderJobCard(job, true, 'analytics');
        });
        
        html += '</div></div></div>';
      }

      // Render Refresh Batches Section
      if (refreshGroup.length > 0) {
        html += '<div class="job-section">';
        html += '<div class="job-section-header refresh">üîÑ Website Pages Refresh Batches</div>';
        html += '<div class="job-section-content">';
        html += '<div class="jobs-grid" style="grid-template-columns: repeat(3, 1fr);">';
        
        refreshGroup.forEach((job) => {
          html += renderJobCard(job, true, 'refresh');
        });
        
        html += '</div></div></div>';
      }

      // Render Data Maintenance & Cleanup Section
      if (dataMaintenanceGroup.length > 0) {
        html += '<div class="job-section">';
        html += '<div class="job-section-header maintenance">üßπ Data Maintenance & Cleanup Jobs</div>';
        html += '<div class="job-section-content">';
        html += '<div class="jobs-grid" style="grid-template-columns: repeat(3, 1fr);">';
        
        dataMaintenanceGroup.forEach((job) => {
          html += renderJobCard(job, false, 'maintenance');
        });
        
        html += '</div></div></div>';
      }

      // Render Database Performance Section
      if (databasePerformanceGroup.length > 0) {
        html += '<div class="job-section">';
        html += '<div class="job-section-header performance">‚ö° Database Performance Jobs</div>';
        html += '<div class="job-section-content">';
        html += '<div class="jobs-grid" style="grid-template-columns: repeat(1, 1fr);">';
        
        databasePerformanceGroup.forEach((job) => {
          html += renderJobCard(job, false, 'performance');
        });
        
        html += '</div></div></div>';
      }

      // Render Content Health & Monitoring Section
      if (contentHealthGroup.length > 0) {
        html += '<div class="job-section">';
        html += '<div class="job-section-header health">üè• Content Health & Monitoring Jobs</div>';
        html += '<div class="job-section-content">';
        html += '<div class="jobs-grid" style="grid-template-columns: repeat(3, 1fr);">';
        
        contentHealthGroup.forEach((job) => {
          html += renderJobCard(job, false, 'health');
        });
        
        html += '</div></div></div>';
      }

      // Render System Health & Backup Section
      if (systemHealthGroup.length > 0) {
        html += '<div class="job-section">';
        html += '<div class="job-section-header system">üõ°Ô∏è System Health & Backup Jobs</div>';
        html += '<div class="job-section-content">';
        html += '<div class="jobs-grid" style="grid-template-columns: repeat(2, 1fr);">';
        
        systemHealthGroup.forEach((job) => {
          html += renderJobCard(job, false, 'system');
        });
        
        html += '</div></div></div>';
      }

      // Render Other Jobs
      if (otherJobs.length > 0) {
        html += '<div class="jobs-grid">';
        otherJobs.forEach(job => {
          html += renderJobCard(job, false, '');
        });
        html += '</div>';
      }

      container.innerHTML = html;
      
      // Fetch run history and render sparklines for each job
      for (const job of jobs) {
        try {
          const logRes = await fetch(`${API_BASE}/api/admin?action=get_job_logs&jobid=${job.jobid}`, {
            headers: buildAuthHeaders()
          });
          const { logs } = await logRes.json();
          
          if (logs && logs.length > 0) {
            // Build recent_runs array for sparkline
            const recentRuns = logs.slice(0, 14).map(log => ({
              date: log.start_time || log.end_time || new Date().toISOString(),
              success: log.status === 'succeeded' || log.status === 'success'
            }));
            
            // Update job with recent_runs
            job.recent_runs = recentRuns;
            
            // Render sparkline
            renderSparkline(job.jobid, recentRuns);
          }
        } catch (error) {
          console.error(`Error fetching logs for job ${job.jobid}:`, error);
        }
      }
      
      // Setup event handlers for frequency save buttons
      document.querySelectorAll('.save-freq-btn').forEach(btn => {
        btn.addEventListener('click', async function() {
          const jobid = parseInt(this.dataset.jobid);
          const input = document.querySelector(`.freq-input[data-jobid="${jobid}"]`);
          const newValue = parseInt(input.value, 10);
          
          if (!newValue || newValue < 1) {
            showMessage('Frequency must be at least 1 minute', 'error');
            return;
          }
          
          try {
            const response = await fetch(`${API_BASE}/api/admin?action=update_schedule`, {
              method: 'POST',
              headers: buildAuthHeaders(),
              body: JSON.stringify({ jobid, frequency_minutes: newValue })
            });
            
            const data = await response.json();
            if (!data.ok) {
              throw new Error(data.error || 'Failed to update frequency');
            }
            
            showMessage('Frequency updated successfully!', 'success');
            loadJobs(); // Refresh job list
          } catch (error) {
            showMessage(`Error updating frequency: ${error.message}`, 'error');
          }
        });
      });
      
      // Setup event handlers for view logs buttons (inline drawer)
      document.querySelectorAll('.view-logs-btn').forEach(btn => {
        btn.addEventListener('click', async function() {
          const jobid = parseInt(this.dataset.jobid);
          await toggleLogDrawer(jobid);
        });
      });
      
      
      // Restore active log drawer if it was open
      if (activeLogJobId !== null) {
        const drawer = document.getElementById(`log-drawer-${activeLogJobId}`);
        const btn = document.querySelector(`.view-logs-btn[data-jobid="${activeLogJobId}"]`);
        if (drawer && btn) {
          drawer.style.display = 'block';
          btn.textContent = 'Hide Logs';
          // Re-render logs if cached
          if (jobLogsCache.has(activeLogJobId)) {
            const cached = jobLogsCache.get(activeLogJobId);
            if (cached.entries) {
              renderLogDrawer(activeLogJobId, cached.entries);
            }
          }
        }
      }
    }
    
    

    // Parse cron schedule to human-readable frequency
    function parseCronFrequency(cron) {
      const parts = cron.trim().split(/\s+/);
      if (parts.length !== 5) return cron;
      
      const [minute, hour, dayOfMonth, month, dayOfWeek] = parts;
      
      // Every minute
      if (minute === '*' && hour === '*' && dayOfMonth === '*' && month === '*' && dayOfWeek === '*') {
        return 'Every minute';
      }
      
      // Every hour at specific minute (e.g., "0 * * * *")
      if (minute !== '*' && hour === '*' && dayOfMonth === '*' && month === '*' && dayOfWeek === '*') {
        if (minute === '0') {
          return 'Every hour';
        }
        return `Every hour (at :${minute.padStart(2, '0')})`;
      }
      
      // Every N hours (e.g., "0 */4 * * *" or "1 */4 * * *")
      if (hour.startsWith('*/') && dayOfMonth === '*' && month === '*' && dayOfWeek === '*') {
        const hours = hour.substring(2);
        const minText = minute !== '0' ? ` at :${minute.padStart(2, '0')}` : '';
        return `Every ${hours} hour${hours !== '1' ? 's' : ''}${minText}`;
      }
      
      // Daily at specific time (e.g., "0 2 * * *")
      if (minute !== '*' && hour !== '*' && dayOfMonth === '*' && month === '*' && dayOfWeek === '*') {
        const h = parseInt(hour);
        const m = minute.padStart(2, '0');
        const ampm = h >= 12 ? 'PM' : 'AM';
        const h12 = h > 12 ? h - 12 : (h === 0 ? 12 : h);
        return `Daily at ${h12}:${m} ${ampm}`;
      }
      
      // Weekly (specific day of week, e.g., "0 2 * * 1")
      if (dayOfWeek !== '*' && dayOfWeek !== '0' && dayOfWeek !== '7' && dayOfMonth === '*' && month === '*') {
        const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
        const day = parseInt(dayOfWeek);
        const dayName = days[day] || dayOfWeek;
        if (hour !== '*' && minute !== '*') {
          const h = parseInt(hour);
          const m = minute.padStart(2, '0');
          const ampm = h >= 12 ? 'PM' : 'AM';
          const h12 = h > 12 ? h - 12 : (h === 0 ? 12 : h);
          return `Every ${dayName} at ${h12}:${m} ${ampm}`;
        }
        return `Every ${dayName}`;
      }
      
      // Monthly
      if (dayOfMonth !== '*' && dayOfMonth !== '0' && month === '*' && dayOfWeek === '*') {
        if (hour !== '*' && minute !== '*') {
          const h = parseInt(hour);
          const m = minute.padStart(2, '0');
          const ampm = h >= 12 ? 'PM' : 'AM';
          const h12 = h > 12 ? h - 12 : (h === 0 ? 12 : h);
          return `Monthly on day ${dayOfMonth} at ${h12}:${m} ${ampm}`;
        }
        return `Monthly on day ${dayOfMonth}`;
      }
      
      // Fallback: return the cron expression
      return cron;
    }

    // Calculate next scheduled run time from cron expression
    function getNextScheduledTime(cron, jobActive = true, lastRun = null) {
      if (!cron || !jobActive) return null;
      
      try {
        const parts = cron.trim().split(/\s+/);
        if (parts.length !== 5) return null;
        
        const [minute, hour, dayOfMonth, month, dayOfWeek] = parts;
        const now = new Date();
        const nextRun = new Date(now);
        nextRun.setSeconds(0);
        nextRun.setMilliseconds(0);
        
        // Helper to check if a value matches cron pattern
        const matches = (value, pattern) => {
          if (pattern === '*') return true;
          if (pattern.startsWith('*/')) {
            const interval = parseInt(pattern.substring(2));
            return value % interval === 0;
          }
          return parseInt(pattern) === value;
        };
        
        // Every hour at specific minute
        if (minute !== '*' && hour === '*' && dayOfMonth === '*' && month === '*' && dayOfWeek === '*') {
          const targetMinute = parseInt(minute);
          nextRun.setMinutes(targetMinute);
          if (nextRun <= now) {
            nextRun.setHours(nextRun.getHours() + 1);
          }
          return nextRun;
        }
        
        // Every N hours
        if (hour.startsWith('*/') && dayOfMonth === '*' && month === '*' && dayOfWeek === '*') {
          const hours = parseInt(hour.substring(2));
          const targetMinute = minute === '*' ? 0 : parseInt(minute);
          
          // Set to current hour with target minute
          nextRun.setMinutes(targetMinute);
          
          // If the minute has passed this hour, move to next interval
          if (nextRun <= now) {
            const currentHour = now.getHours();
            const currentMinute = now.getMinutes();
            
            // Calculate how many hours until next run
            const hoursSinceLastRun = currentHour % hours;
            let hoursToAdd = hours - hoursSinceLastRun;
            
            // If we're at the exact hour but minute hasn't passed, don't add hours
            if (hoursSinceLastRun === 0 && currentMinute < targetMinute) {
              hoursToAdd = 0;
            }
            
            nextRun.setHours(currentHour + hoursToAdd);
            
            // If we've gone past midnight, adjust
            if (nextRun.getHours() < currentHour) {
              nextRun.setDate(nextRun.getDate() + 1);
            }
          }
          
          return nextRun;
        }
        
        // Daily at specific time
        if (minute !== '*' && hour !== '*' && dayOfMonth === '*' && month === '*' && dayOfWeek === '*') {
          const targetHour = parseInt(hour);
          const targetMinute = parseInt(minute);
          nextRun.setHours(targetHour);
          nextRun.setMinutes(targetMinute);
          
          if (nextRun <= now) {
            nextRun.setDate(nextRun.getDate() + 1);
          }
          return nextRun;
        }
        
        // Weekly (specific day of week)
        if (dayOfWeek !== '*' && dayOfWeek !== '0' && dayOfWeek !== '7' && dayOfMonth === '*' && month === '*') {
          const targetDay = parseInt(dayOfWeek);
          const targetHour = hour === '*' ? 0 : parseInt(hour);
          const targetMinute = minute === '*' ? 0 : parseInt(minute);
          
          const currentDay = now.getDay();
          let daysUntilNext = (targetDay - currentDay + 7) % 7;
          if (daysUntilNext === 0) {
            // Same day - check if time has passed
            nextRun.setHours(targetHour);
            nextRun.setMinutes(targetMinute);
            if (nextRun <= now) {
              daysUntilNext = 7;
            }
          }
          
          nextRun.setDate(now.getDate() + daysUntilNext);
          nextRun.setHours(targetHour);
          nextRun.setMinutes(targetMinute);
          return nextRun;
        }
        
        // For other patterns, try a simple increment approach
        // This is a fallback and may not be 100% accurate for all cron patterns
        return null;
      } catch (e) {
        console.error('Error calculating next scheduled time:', e);
        return null;
      }
    }

    // Format next scheduled time for display
    function formatNextScheduledTime(cron, jobActive, lastRun = null) {
      if (!jobActive) return 'Paused';
      
      const nextRun = getNextScheduledTime(cron, jobActive, lastRun);
      if (!nextRun) return 'Unknown';
      
      const now = new Date();
      const diffMs = nextRun - now;
      const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
      const diffMinutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
      
      // If less than 24 hours away, show relative time
      if (diffMs < 24 * 60 * 60 * 1000) {
        if (diffHours > 0) {
          return `In ${diffHours}h ${diffMinutes}m`;
        } else if (diffMinutes > 0) {
          return `In ${diffMinutes}m`;
        } else {
          return 'Now';
        }
      }
      
      // Otherwise show date and time
      return nextRun.toLocaleString();
    }

    // Risky jobs that have regression testing
    const riskyJobs = [21, 26, 27, 28, 31];
    const regressionTestData = {};

    async function loadRegressionTestData(jobid) {
      if (!riskyJobs.includes(jobid)) return null;
      
      try {
        const response = await fetch(`${API_BASE}/api/admin?action=regression_test_results&jobid=${jobid}`, {
          headers: buildAuthHeaders()
        });
        
        if (response.ok) {
          const data = await response.json();
          if (data.ok && data.has_results) {
            return data;
          }
        }
      } catch (error) {
        console.error(`Error loading regression data for job ${jobid}:`, error);
      }
      return null;
    }

    function renderRegressionTestSummary(regressionData, jobId = null) {
      if (!regressionData || !regressionData.has_results) {
        return '<div class="regression-test-section"><em>No regression test results yet</em></div>';
      }

      const { baseline, after, comparison, test_run } = regressionData;
      
      // Calculate stats
      const baselineStats = baseline ? {
        success_rate: baseline.total_questions > 0 
          ? ((baseline.successful_tests / baseline.total_questions) * 100).toFixed(1)
          : 0,
        avg_confidence: (baseline.avg_confidence * 100).toFixed(1),
        total_questions: baseline.total_questions || 40
      } : null;
      
      const afterStats = after ? {
        success_rate: after.total_questions > 0 
          ? ((after.successful_tests / after.total_questions) * 100).toFixed(1)
          : 0,
        avg_confidence: (after.avg_confidence * 100).toFixed(1),
        total_questions: after.total_questions || 40
      } : null;
      
      // Show baseline only if no after test yet
      if (baseline && !after) {
        return `
          <div class="regression-test-section no-regression">
            <div style="font-weight: bold; margin-bottom: 8px;">
              üìä Baseline Test Complete
            </div>
            <div class="regression-summary">
              <div class="regression-stat">
                <div class="regression-stat-label">Baseline Success Rate</div>
                <div class="regression-stat-value">${baselineStats.success_rate}%</div>
              </div>
              <div class="regression-stat">
                <div class="regression-stat-label">Baseline Confidence</div>
                <div class="regression-stat-value">${baselineStats.avg_confidence}%</div>
              </div>
              <div class="regression-stat">
                <div class="regression-stat-label">Total Questions</div>
                <div class="regression-stat-value">${baselineStats.total_questions}</div>
              </div>
              <div class="regression-stat">
                <div class="regression-stat-label">Status</div>
                <div class="regression-stat-value">Waiting for job run</div>
              </div>
            </div>
            <div style="margin-top: 8px; font-size: 11px; color: #155724;">
              Baseline established. Will compare against this when job runs.
            </div>
          </div>
        `;
      }
      
      // Show both baseline and latest run results
      if (baseline && after) {
        const severity = comparison ? (comparison.regression_severity || 'none') : 'none';
        const detected = comparison ? (comparison.regression_detected || false) : false;
        const details = comparison ? (comparison.regression_details || {}) : {};
        const comparisonBaselineStats = comparison ? (comparison.baseline_stats || {}) : {};
        const comparisonCurrentStats = comparison ? (comparison.current_stats || {}) : {};
        
        const severityClass = detected ? severity : 'no-regression';
        const severityIcon = detected 
          ? (severity === 'severe' ? 'üî¥' : severity === 'moderate' ? 'üü°' : 'üü†')
          : '‚úÖ';
        
        // Use passed jobId parameter
        const displayJobId = jobId || (regressionData && regressionData.test_run ? regressionData.test_run.job_id : 
                     (regressionData && regressionData.baseline ? regressionData.baseline.job_id : null));
        
        return `
          <div class="regression-test-section ${severityClass}">
            <div style="font-weight: bold; margin-bottom: 8px;">
              ${comparison ? `${severityIcon} Regression Test: ${detected ? severity.toUpperCase() + ' REGRESSION DETECTED' : 'No Regression'}` : 'üìä Baseline vs Latest Run'}
            </div>
            <div class="regression-summary">
              <div class="regression-stat">
                <div class="regression-stat-label">Baseline Success Rate</div>
                <div class="regression-stat-value">${comparison ? parseFloat(comparisonBaselineStats.success_rate || baselineStats.success_rate || 0).toFixed(1) : baselineStats.success_rate}%</div>
              </div>
              <div class="regression-stat">
                <div class="regression-stat-label">Latest Run Success Rate</div>
                <div class="regression-stat-value">${comparison ? parseFloat(comparisonCurrentStats.success_rate || afterStats.success_rate || 0).toFixed(1) : afterStats.success_rate}%</div>
              </div>
              <div class="regression-stat">
                <div class="regression-stat-label">Baseline Confidence</div>
                <div class="regression-stat-value">${comparison ? parseFloat(comparisonBaselineStats.avg_confidence || baselineStats.avg_confidence || 0).toFixed(3) : baselineStats.avg_confidence}%</div>
              </div>
              <div class="regression-stat">
                <div class="regression-stat-label">Latest Run Confidence</div>
                <div class="regression-stat-value">${comparison ? parseFloat(comparisonCurrentStats.avg_confidence || afterStats.avg_confidence || 0).toFixed(3) : afterStats.avg_confidence}%</div>
              </div>
              ${comparison ? `
              <div class="regression-stat">
                <div class="regression-stat-label">Article Changes</div>
                <div class="regression-stat-value">${details.article_change_count || 0} queries</div>
              </div>
              <div class="regression-stat">
                <div class="regression-stat-label">Severe Changes</div>
                <div class="regression-stat-value">${details.severe_article_changes || 0}</div>
              </div>
              ` : `
              <div class="regression-stat">
                <div class="regression-stat-label">Baseline Questions</div>
                <div class="regression-stat-value">${baselineStats.total_questions}</div>
              </div>
              <div class="regression-stat">
                <div class="regression-stat-label">Latest Run Questions</div>
                <div class="regression-stat-value">${afterStats.total_questions}</div>
              </div>
              `}
            </div>
            ${comparison && detected ? `<div style="margin-top: 8px; font-size: 11px; color: #721c24;"><strong>Action:</strong> ${severity === 'severe' || severity === 'moderate' ? 'ROLLBACK RECOMMENDED' : 'Review recommended'}</div>` : ''}
            ${!comparison ? `<div style="margin-top: 8px; font-size: 11px; color: #155724;">Comparison analysis pending...</div>` : ''}
            ${comparison && displayJobId ? `<div style="margin-top: 10px;"><button class="btn btn-primary btn-small" onclick="showRegressionDetails(${displayJobId})">View Details</button></div>` : ''}
          </div>
        `;
      }
      
      if (!baseline) {
        return `<div class="regression-test-section">
          <em>No baseline test found for job ${jobId}.</em>
          <div style="margin-top: 8px; font-size: 11px; color: #856404;">
            <strong>To create a baseline:</strong> The baseline test is automatically created the first time this job runs with regression testing enabled. 
            If no baseline exists, it means the job hasn't been run with regression testing yet, or the baseline test wasn't created properly.
            <br><br>
            <strong>Note:</strong> The wrapper function <code>refresh_v_products_unified_with_regression_test()</code> should create a baseline test automatically on the first run.
          </div>
        </div>`;
      }
      
      return '<div class="regression-test-section"><em>Regression test in progress...</em></div>';
    }

    async function showRegressionDetails(jobId) {
      const modal = document.getElementById('regressionDetailsModal');
      const modalContent = document.getElementById('regressionDetailsContent');
      
      if (!modal || !modalContent) return;
      
      // Load fresh comparison data
      try {
        const response = await fetch(`${API_BASE}/api/admin?action=regression_test_results&jobid=${jobId}`, {
          headers: buildAuthHeaders()
        });
        
        if (!response.ok) {
          modalContent.innerHTML = '<p>Error loading regression details.</p>';
          modal.style.display = 'block';
          return;
        }
        
        const data = await response.json();
        if (!data.ok || !data.has_results || !data.comparison) {
          modalContent.innerHTML = '<p>No comparison data available.</p>';
          modal.style.display = 'block';
          return;
        }
        
        const comparison = data.comparison;
        const articleChanges = comparison.article_changes || [];
        const answerQualityChanges = comparison.answer_quality_changes || [];
        const queryRegressions = comparison.query_regressions || [];
        const details = comparison.regression_details || {};
        
        let html = `
          <h2>Regression Test Details - Job ${jobId}</h2>
          <div class="details-section">
            <h3>Overall Summary</h3>
            <p><strong>Regression Detected:</strong> ${comparison.regression_detected ? 'Yes' : 'No'}</p>
            <p><strong>Severity:</strong> ${comparison.regression_severity || 'none'}</p>
            <p><strong>Success Rate Change:</strong> ${parseFloat(details.success_rate_diff || 0).toFixed(2)}%</p>
            <p><strong>Confidence Change:</strong> ${parseFloat(details.confidence_diff || 0).toFixed(3)}</p>
            <p><strong>Total Article Changes:</strong> ${details.article_change_count || 0} queries</p>
            <p><strong>Severe Article Changes:</strong> ${details.severe_article_changes || 0}</p>
            <p><strong>Answer Quality Degradations:</strong> ${details.answer_quality_degradations || 0}</p>
          </div>
        `;
        
        if (queryRegressions.length > 0) {
          html += `
            <div class="details-section">
              <h3>Query-Specific Regressions (${queryRegressions.length})</h3>
          `;
          
          queryRegressions.forEach(qr => {
            const severity = qr.severity || 'minor';
            html += `
              <div class="query-change ${severity}">
                <strong>Query:</strong> ${qr.query || 'Unknown'}<br>
                <strong>Severity:</strong> ${severity}<br>
                <strong>Article Changes:</strong> ${qr.article_changes || 0}<br>
                <strong>Answer Degradation:</strong> ${qr.answer_degradation ? 'Yes' : 'No'}
              </div>
            `;
          });
          
          html += `</div>`;
        }
        
        if (articleChanges.length > 0) {
          html += `
            <div class="details-section">
              <h3>Article Changes by Query (${articleChanges.length})</h3>
          `;
          
          articleChanges.forEach(ac => {
            const removed = ac.removed_articles || [];
            const added = ac.added_articles || [];
            
            html += `
              <div class="query-change">
                <strong>Query:</strong> ${ac.query || 'Unknown'}<br>
                <strong>Baseline Articles:</strong> ${ac.baseline_article_count || 0}<br>
                <strong>Current Articles:</strong> ${ac.current_article_count || 0}<br>
            `;
            
            if (removed.length > 0) {
              html += `<div class="article-list"><strong>Removed Articles (${ac.removed_count || 0}):</strong><ul>`;
              removed.forEach(article => {
                html += `<li class="article-removed">${article.title || article.id || 'Unknown'} (ID: ${article.id || 'N/A'})</li>`;
              });
              html += `</ul></div>`;
            }
            
            if (added.length > 0) {
              html += `<div class="article-list"><strong>Added Articles (${ac.added_count || 0}):</strong><ul>`;
              added.forEach(article => {
                html += `<li class="article-added">${article.title || article.id || 'Unknown'} (ID: ${article.id || 'N/A'})</li>`;
              });
              html += `</ul></div>`;
            }
            
            html += `</div>`;
          });
          
          html += `</div>`;
        }
        
        if (answerQualityChanges.length > 0) {
          html += `
            <div class="details-section">
              <h3>Answer Quality Changes (${answerQualityChanges.length})</h3>
          `;
          
          answerQualityChanges.forEach(aq => {
            html += `
              <div class="query-change">
                <strong>Query:</strong> ${aq.query || 'Unknown'}<br>
                <strong>Baseline Answer Length:</strong> ${aq.baseline_answer_length || 0} chars<br>
                <strong>Current Answer Length:</strong> ${aq.current_answer_length || 0} chars<br>
                <strong>Length Difference:</strong> ${aq.answer_length_diff || 0} chars<br>
                <strong>Baseline Confidence:</strong> ${parseFloat(aq.baseline_confidence || 0).toFixed(3)}<br>
                <strong>Current Confidence:</strong> ${parseFloat(aq.current_confidence || 0).toFixed(3)}<br>
                <strong>Confidence Difference:</strong> ${parseFloat(aq.confidence_diff || 0).toFixed(3)}
              </div>
            `;
          });
          
          html += `</div>`;
        }
        
        modalContent.innerHTML = html;
        modal.style.display = 'block';
      } catch (error) {
        modalContent.innerHTML = `<p>Error loading details: ${error.message}</p>`;
        modal.style.display = 'block';
      }
    }

    function closeRegressionDetails() {
      const modal = document.getElementById('regressionDetailsModal');
      if (modal) {
        modal.style.display = 'none';
      }
    }

    async function runJobNow(jobId, jobName) {
      addDebugLog(`Run job now requested: ${jobName} (ID: ${jobId})`, 'info', { jobId, jobName });
      
      const modal = document.getElementById('jobExecutionModal');
      const modalContent = document.getElementById('jobExecutionContent');
      
      if (!modal || !modalContent) {
        addDebugLog('Modal elements not found', 'error');
        return;
      }
      
      // Show loading state
      modalContent.innerHTML = `
        <h2>Running Job: ${jobName} (ID: ${jobId})</h2>
        <div style="text-align: center; padding: 40px;">
          <div style="font-size: 18px; margin-bottom: 20px;">‚è≥ Executing job...</div>
          <div style="color: #7f8c8d;">This may take a few moments</div>
        </div>
      `;
      modal.style.display = 'block';
      
      try {
        addDebugLog(`Sending run job request for job ${jobId}`, 'info');
        const response = await fetch(`${API_BASE}/api/admin?action=run_cron_job`, {
          method: 'POST',
          headers: buildAuthHeaders(),
          body: JSON.stringify({ jobid: jobId })
        });
        
        addDebugLog(`Run job API response: ${response.status} ${response.statusText}`, 'info');
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        addDebugLog('Run job API response data received', 'info', data);
        
        if (!data.ok) {
          throw new Error(data.error || 'Job execution failed');
        }
        
        const { job, execution, regression_test } = data;
        addDebugLog(`Job execution completed: success=${execution.success}, duration=${execution.duration}s`, 
          execution.success ? 'success' : 'error', { execution });
        
        const isRiskyJob = [21, 26, 27, 28, 31].includes(parseInt(jobId));
        
        let html = `
          <h2>Job Execution Results: ${job.name || jobName} (ID: ${job.id || jobId})</h2>
          <div class="details-section">
            <h3>Execution Summary</h3>
            <p><strong>Status:</strong> <span style="color: ${execution.success ? '#27ae60' : '#e74c3c'}; font-weight: bold;">
              ${execution.success ? '‚úÖ Success' : '‚ùå Failed'}
            </span></p>
            <p><strong>Duration:</strong> ${execution.duration ? execution.duration.toFixed(2) : 'N/A'} seconds</p>
            <p><strong>Start Time:</strong> ${new Date(execution.start_time).toLocaleString()}</p>
            <p><strong>End Time:</strong> ${new Date(execution.end_time).toLocaleString()}</p>
        `;
        
        if (execution.error) {
          html += `<p><strong>Error:</strong> <span style="color: #e74c3c;">${execution.error}</span></p>`;
        }
        
        if (execution.result) {
          if (typeof execution.result === 'string') {
            html += `<p><strong>Result:</strong> ${execution.result}</p>`;
          } else if (Array.isArray(execution.result) && execution.result.length > 0) {
            html += `<h4>Results:</h4><pre style="background: #f4f4f4; padding: 10px; border-radius: 4px; overflow-x: auto; max-height: 300px; overflow-y: auto;">${JSON.stringify(execution.result, null, 2)}</pre>`;
          } else if (typeof execution.result === 'object') {
            html += `<h4>Results:</h4><pre style="background: #f4f4f4; padding: 10px; border-radius: 4px; overflow-x: auto; max-height: 300px; overflow-y: auto;">${JSON.stringify(execution.result, null, 2)}</pre>`;
          }
        }
        
        if (execution.records_affected) {
          html += `<h4>Records Affected:</h4>`;
          if (typeof execution.records_affected === 'object') {
            Object.entries(execution.records_affected).forEach(([key, value]) => {
              html += `<p><strong>${key}:</strong> ${value}</p>`;
            });
          } else {
            html += `<p>${execution.records_affected}</p>`;
          }
        }
        
        html += `</div>`;
        
        // Show regression test results for risky jobs
        if (isRiskyJob && regression_test && regression_test.test_run) {
          const testRun = regression_test.test_run;
          const comparison = regression_test.comparison;
          
          html += `
            <div class="details-section">
              <h3>Regression Test Results</h3>
              <p><strong>Test Run Status:</strong> ${testRun.status || 'Unknown'}</p>
              <p><strong>Baseline Test ID:</strong> ${testRun.baseline_test_id || 'N/A'}</p>
              <p><strong>After Test ID:</strong> ${testRun.after_test_id || 'N/A'}</p>
          `;
          
          if (comparison) {
            const detected = comparison.regression_detected || false;
            const severity = comparison.regression_severity || 'none';
            const details = comparison.regression_details || {};
            
            html += `
              <p><strong>Regression Detected:</strong> <span style="color: ${detected ? '#e74c3c' : '#27ae60'};">
                ${detected ? 'Yes' : 'No'}
              </span></p>
              <p><strong>Severity:</strong> ${severity}</p>
              <p><strong>Success Rate Change:</strong> ${parseFloat(details.success_rate_diff || 0).toFixed(2)}%</p>
              <p><strong>Confidence Change:</strong> ${parseFloat(details.confidence_diff || 0).toFixed(3)}</p>
              <p><strong>Article Changes:</strong> ${details.article_change_count || 0} queries</p>
              <p><strong>Severe Changes:</strong> ${details.severe_article_changes || 0}</p>
            `;
            
            if (detected) {
              html += `<p style="color: #e74c3c; font-weight: bold; margin-top: 10px;">
                ${severity === 'severe' || severity === 'moderate' ? '‚ö†Ô∏è ROLLBACK RECOMMENDED' : 'Review recommended'}
              </p>`;
            }
          } else {
            html += `<p>Comparison analysis pending or not available.</p>`;
          }
          
          html += `</div>`;
        }
        
        // Show command executed
        html += `
          <div class="details-section">
            <h3>Command Executed</h3>
            <pre style="background: #f4f4f4; padding: 10px; border-radius: 4px; overflow-x: auto;">${job.command || 'N/A'}</pre>
          </div>
        `;
        
        modalContent.innerHTML = html;
        
        // Refresh jobs list to update stats immediately
        addDebugLog('Refreshing jobs after execution to update stats...', 'info');
          loadJobs();
        
      } catch (error) {
        addDebugLog(`Error running job: ${error.message}`, 'error', { error: error.message, stack: error.stack });
        modalContent.innerHTML = `
          <h2>Error Running Job: ${jobName}</h2>
          <div class="details-section">
            <p style="color: #e74c3c;"><strong>Error:</strong> ${error.message}</p>
            <p>Please check the job configuration and try again.</p>
          </div>
        `;
      }
    }

    function closeJobExecutionModal() {
      const modal = document.getElementById('jobExecutionModal');
      if (modal) {
        modal.style.display = 'none';
      }
    }

    /**
     * Calculate next run in minutes
     * @param {JobSummary} job
     * @param {Date} now
     * @returns {number|null} Minutes until next run, or null if not scheduled
     */
    function calculateNextRunInMinutes(job, now = new Date()) {
      if (!job.frequency_minutes || job.frequency_minutes <= 0) return null;

      if (!job.last_run) return job.frequency_minutes; // first run: assume full interval

      const lastRun = new Date(job.last_run);
      const diffMs = lastRun.getTime() + job.frequency_minutes * 60_000 - now.getTime();
      const diffMinutes = Math.ceil(diffMs / 60_000);

      // if negative (overdue), clamp to 0 so health logic handles "overdue"
      return diffMinutes < 0 ? 0 : diffMinutes;
    }

    /**
     * Get job health status
     * @param {JobSummary} job
     * @param {number|null} nextRunInMinutes
     * @returns {{ level: 'ok'|'warning'|'error', label: string, reason: string }}
     */
    function getJobHealth(job, nextRunInMinutes) {
      const now = new Date();
      const lastRun = job.last_run ? new Date(job.last_run) : null;
      const minutesSinceLastRun = lastRun ? Math.floor((now - lastRun) / (1000 * 60)) : null;
      const freqMinutes = job.frequency_minutes || 60;

      // Error conditions
      if (job.failed_count > 0 && job.success_count === 0) {
        return { level: 'error', label: 'Error', reason: 'Always fails - no successful runs' };
      }
      if (nextRunInMinutes === 0 && lastRun && minutesSinceLastRun > freqMinutes * 3) {
        return { level: 'error', label: 'Error', reason: 'Severely overdue - last run was ' + Math.floor(minutesSinceLastRun / freqMinutes) + 'x scheduled interval ago' };
      }

      // Warning conditions
      if (job.total_runs === 0 && job.status === 'active') {
        return { level: 'warning', label: 'Warning', reason: 'Never run - job is active but has no execution history' };
      }
      if (job.failed_count > 0 && job.failed_count < job.success_count) {
        return { level: 'warning', label: 'Warning', reason: 'Some failures detected - ' + job.failed_count + ' failed, ' + job.success_count + ' succeeded' };
      }
      if (nextRunInMinutes === 0 && lastRun && minutesSinceLastRun > freqMinutes * 2) {
        return { level: 'warning', label: 'Warning', reason: 'Possibly stuck - overdue by ' + Math.floor(minutesSinceLastRun / freqMinutes) + 'x scheduled interval' };
      }

      // OK conditions (all must be true)
      const hasRuns = job.total_runs > 0;
      const noFailures = job.failed_count === 0;
      const notOverdue = nextRunInMinutes === null || nextRunInMinutes <= 1.5 * freqMinutes;

      if (hasRuns && noFailures && notOverdue) {
        return { level: 'ok', label: 'OK', reason: 'All runs successful, on schedule' };
      }

      // Default to warning if conditions not met
      return { level: 'warning', label: 'Warning', reason: 'Check job status' };
    }

    /**
     * Render sparkline chart for job runs (SVG-based for tooltips)
     * @param {string|number} jobId
     * @param {Array<{ date: string, success: boolean }>} runHistory
     */
    function renderSparkline(jobId, runHistory) {
      const container = document.getElementById(`sparkline-${jobId}`);
      if (!container) return;
      
      container.innerHTML = '';
      
      const width = 150;
      const height = 50;
      const barWidth = 6;
      const gap = 2;
      
      const lastRuns = (runHistory || []).slice(-14);
      if (lastRuns.length === 0) return;
      
      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('width', width);
      svg.setAttribute('height', height);
      svg.style.display = 'block';
      
      lastRuns.forEach((run, index) => {
        const isSuccess = run.success === true || run.status === 'succeeded' || run.status === 'success';
        const barHeight = isSuccess ? 35 : 12;
        const color = isSuccess ? '#5cb85c' : '#d9534f';
        
        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        rect.setAttribute('x', index * (barWidth + gap));
        rect.setAttribute('y', height - barHeight);
        rect.setAttribute('width', barWidth);
        rect.setAttribute('height', barHeight);
        rect.setAttribute('fill', color);
        rect.setAttribute('data-index', index);
        rect.setAttribute('data-success', isSuccess);
        
        svg.appendChild(rect);
      });
      
      container.appendChild(svg);
      
      // Add tooltips after rendering
      addSparklineTooltips(jobId);
    }

    /**
     * Add tooltips on sparkline bar hover
     * @param {string|number} jobId
     */
    function addSparklineTooltips(jobId) {
      const container = document.getElementById(`sparkline-${jobId}`);
      if (!container) return;

      const svg = container.querySelector('svg');
      if (!svg) return;

      const bars = svg.querySelectorAll('rect');

      bars.forEach((bar, idx) => {
        const success = bar.getAttribute('fill') === '#5cb85c';
        const tooltipText = success
          ? `Run #${idx + 1}: Success`
          : `Run #${idx + 1}: Failed`;

        bar.style.cursor = 'pointer';
        
        bar.addEventListener('mouseenter', (e) => {
          const tooltip = document.createElement('div');
          tooltip.id = `sparkline-tooltip-${jobId}-${idx}`;
          tooltip.textContent = tooltipText;
          tooltip.style.position = 'absolute';
          tooltip.style.background = 'rgba(0,0,0,0.75)';
          tooltip.style.padding = '4px 6px';
          tooltip.style.color = 'white';
          tooltip.style.fontSize = '11px';
          tooltip.style.borderRadius = '4px';
          tooltip.style.pointerEvents = 'none';
          tooltip.style.zIndex = '1000';
          tooltip.style.whiteSpace = 'nowrap';
          
          // Position tooltip near the bar
          const rect = bar.getBoundingClientRect();
          const containerRect = container.getBoundingClientRect();
          tooltip.style.left = (rect.left - containerRect.left + rect.width / 2) + 'px';
          tooltip.style.top = (rect.top - containerRect.top - 25) + 'px';
          tooltip.style.transform = 'translateX(-50%)';
          
          container.appendChild(tooltip);
        });

        bar.addEventListener('mouseleave', () => {
          const tooltip = document.getElementById(`sparkline-tooltip-${jobId}-${idx}`);
          if (tooltip) tooltip.remove();
        });
      });
    }

    /**
     * Render a single job card
     * @param {JobSummary} job
     * @param {boolean} isLinked
     * @param {string} groupType
     * @returns {string}
     */
    function renderJobCard(job, isLinked, groupType) {
      const successRate = job.total_runs > 0 
        ? ((job.success_count / job.total_runs) * 100).toFixed(1)
        : 0;
      const failureRate = job.total_runs > 0
        ? ((job.failed_count / job.total_runs) * 100).toFixed(1)
        : 0;
      const lastRun = job.last_run 
        ? new Date(job.last_run).toLocaleString()
        : 'Never';
      const description = jobDescriptions[job.jobid] || 'No description available.';
      const linkedJobIds = linkedJobs[job.jobid];
      const isLinkedJob = linkedJobIds !== undefined;
      const linkedIdsArray = Array.isArray(linkedJobIds) ? linkedJobIds : [linkedJobIds];
      const linkedIdsText = linkedIdsArray.join(', ');
      const displayName = jobDisplayNames[job.jobid] || job.name || `Job ${job.jobid}`;
      const frequency = parseCronFrequency(job.schedule);
      
      // Calculate next run and health
      const nextRunInMinutes = calculateNextRunInMinutes(job);
      let nextRunText = '';
      if (nextRunInMinutes === null) {
        nextRunText = 'Not scheduled';
      } else if (nextRunInMinutes === 0) {
        nextRunText = 'Due now';
      } else {
        nextRunText = `Next run in ${nextRunInMinutes}m`;
      }
      
      const health = getJobHealth(job, nextRunInMinutes);
      
      // Load regression test data for risky jobs (use pre-loaded data)
      let regressionSummary = '';
      if (riskyJobs.includes(job.jobid)) {
        const regressionData = regressionTestData[job.jobid] || null;
        regressionSummary = renderRegressionTestSummary(regressionData, job.jobid);
      }
      
      const borderColor = 
        groupType === 'analytics' ? '#f5576c' : 
        groupType === 'refresh' ? '#00f2fe' : 
        groupType === 'maintenance' ? '#f5576c' :
        groupType === 'performance' ? '#4facfe' :
        groupType === 'health' ? '#43e97b' :
        groupType === 'system' ? '#fa709a' :
        '#3498db';
      
      const currentFreqMinutes = job.frequency_minutes || 60;
      const isLogDrawerOpen = activeLogJobId === job.jobid;
      
      return `
        <div class="job-card" data-job-card-id="${job.jobid}" ${isLinkedJob ? `style="border: 2px solid ${borderColor};"` : ''}>
          <div class="job-header">
            <div>
              <div class="job-title">${displayName}</div>
              <div class="job-id">ID: ${job.jobid}${isLinkedJob ? ` <span style="color: ${borderColor}; font-size: 16px; font-weight: 700;">‚Üî Linked to Jobs ${linkedIdsText}</span>` : ''}</div>
            </div>
            <span class="status-badge ${job.status === 'active' ? 'status-active' : 'status-inactive'}">
              ${job.status === 'active' ? 'Active' : 'Inactive'}
            </span>
          </div>
          <div class="health-status health-${health.level}" title="${health.reason}">${health.label}</div>
          <div style="margin-bottom: 15px;">
            <div class="frequency-pill">‚è∞ ${frequency}</div>
            <div class="next-run-badge">${nextRunText}</div>
          </div>
          <div style="margin-bottom: 10px;">
            <label>Frequency (minutes)</label>
            <input type="number" class="freq-input" data-jobid="${job.jobid}" min="1" value="${currentFreqMinutes}">
            <button class="save-freq-btn" data-jobid="${job.jobid}">Save</button>
          </div>
          ${regressionSummary}
          <div class="job-description">${description}</div>
          <div class="job-schedule">Schedule: ${job.schedule}</div>
          <div class="job-stats">
            <div class="stat-item">
              <div class="stat-label">Last Run</div>
              <div class="stat-value" style="font-size: 12px;">${lastRun}</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">Total Runs</div>
              <div class="stat-value">${job.total_runs}</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">Success Rate</div>
              <div class="stat-value success-rate">${successRate > 50 ? `<span class="badge-success">${successRate}%</span>` : `<span class="badge-failure">${successRate}%</span>`}</div>
              <div style="font-size: 11px; color: #7f8c8d;">${job.success_count} succeeded</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">Failure Rate</div>
              <div class="stat-value failure-rate">${failureRate > 50 ? `<span class="badge-failure">${failureRate}%</span>` : `<span class="badge-success">${failureRate}%</span>`}</div>
              <div style="font-size: 11px; color: #7f8c8d;">${job.failed_count} failed</div>
            </div>
          </div>
          <div class="sparkline-section">
            <div style="font-size: 12px; font-weight: 600; margin-bottom: 5px; color: #666;">Last runs</div>
            <div class="sparkline-container" id="sparkline-${job.jobid}"></div>
          </div>
          <button class="view-logs-btn" data-jobid="${job.jobid}">${isLogDrawerOpen ? 'Hide Logs' : 'View Logs'}</button>
          <div id="log-drawer-${job.jobid}" class="log-drawer" style="display: ${isLogDrawerOpen ? 'block' : 'none'};"></div>
          <div class="job-actions">
            <button class="btn btn-primary btn-small" onclick="runJobNow(${job.jobid}, '${displayName}')">‚ñ∂ Run Now</button>
            <button class="btn btn-secondary btn-small" onclick="editSchedule(${job.jobid}, '${job.schedule}', '${displayName}')">Edit Schedule</button>
            <button class="btn btn-secondary btn-small" onclick="resetJobStats(${job.jobid}, '${displayName}')" title="Reset success/fail counts">üîÑ Reset Stats</button>
            <button class="btn ${job.status === 'active' ? 'btn-warning' : 'btn-success'} btn-small" onclick="toggleJob(${job.jobid}, ${job.status !== 'active'}, '${displayName}')">
              ${job.status === 'active' ? '‚è∏ Pause' : '‚ñ∂ Resume'}
            </button>
          </div>
        </div>
      `;
    }

    function showMessage(message, type = 'success') {
      const messageDiv = document.getElementById('message');
      messageDiv.className = type;
      messageDiv.textContent = message;
      messageDiv.style.display = 'block';
      setTimeout(() => {
        messageDiv.style.display = 'none';
      }, 5000);
    }

    /**
     * Toggle inline log drawer for a job
     * @param {number} jobid
     */
    async function toggleLogDrawer(jobid) {
      const drawer = document.getElementById(`log-drawer-${jobid}`);
      const btn = document.querySelector(`.view-logs-btn[data-jobid="${jobid}"]`);
      
      if (!drawer || !btn) return;
      
      // If same job is already active, toggle (collapse)
      if (activeLogJobId === jobid) {
        activeLogJobId = null;
        drawer.style.display = 'none';
        btn.textContent = 'View Logs';
        return;
      }
      
      // Close any other open drawer
      if (activeLogJobId !== null) {
        const prevDrawer = document.getElementById(`log-drawer-${activeLogJobId}`);
        const prevBtn = document.querySelector(`.view-logs-btn[data-jobid="${activeLogJobId}"]`);
        if (prevDrawer) prevDrawer.style.display = 'none';
        if (prevBtn) prevBtn.textContent = 'View Logs';
      }
      
      // Open this drawer
      activeLogJobId = jobid;
      drawer.style.display = 'block';
      btn.textContent = 'Hide Logs';
      
      // Check cache
      if (jobLogsCache.has(jobid)) {
        const cached = jobLogsCache.get(jobid);
        if (cached.entries) {
          renderLogDrawer(jobid, cached.entries);
          return;
        }
      }
      
      // Fetch logs
      drawer.innerHTML = '<div class="log-loading">Loading logs...</div>';
      jobLogsCache.set(jobid, { loading: true, error: null, entries: null });
      
      try {
        const response = await fetch(`${API_BASE}/api/admin?action=get_job_logs&jobid=${jobid}`, {
          headers: buildAuthHeaders()
        });
        
        const { logs } = await response.json();
        
        if (!logs || logs.length === 0) {
          drawer.innerHTML = '<div class="log-empty">No logs found for this job.</div>';
          jobLogsCache.set(jobid, { loading: false, error: null, entries: [] });
          return;
        }
        
        jobLogsCache.set(jobid, { loading: false, error: null, entries: logs });
        renderLogDrawer(jobid, logs);
      } catch (error) {
        drawer.innerHTML = `
          <div class="log-error">
            Failed to load logs: ${error.message}
            <a href="#" onclick="toggleLogDrawer(${jobid}); return false;" style="color: #3498db; text-decoration: underline; margin-left: 10px;">Retry</a>
          </div>
        `;
        jobLogsCache.set(jobid, { loading: false, error: error.message, entries: null });
      }
    }

    /**
     * Render log entries in the drawer
     * @param {number} jobid
     * @param {Array} logs
     */
    function renderLogDrawer(jobid, logs) {
      const drawer = document.getElementById(`log-drawer-${jobid}`);
      if (!drawer) return;
      
      // Get job name
      const jobCard = document.querySelector(`[data-job-card-id="${jobid}"]`);
      const jobName = jobCard ? (jobCard.querySelector('.job-title')?.textContent || `Job ${jobid}`) : `Job ${jobid}`;
      
      const logsHtml = logs.map(log => {
        const startTime = new Date(log.start_time).toLocaleString();
        const endTime = log.end_time ? new Date(log.end_time).toLocaleString() : 'N/A';
        const duration = log.end_time 
          ? ((new Date(log.end_time) - new Date(log.start_time)) / 1000).toFixed(2) + 's'
          : 'N/A';
        const isSuccess = log.status === 'succeeded' || log.status === 'success';
        const statusClass = isSuccess ? 'status-success' : 'status-failed';
        const statusText = isSuccess ? 'Success' : 'Fail';
        const message = log.return_message || 'No message';
        
        return `
          <div class="log-entry">
            <div class="log-entry-header">
              <span class="log-status-badge ${statusClass}">${statusText}</span>
              <span class="log-timestamp">${startTime}</span>
              <span class="log-duration">${duration}</span>
            </div>
            <div class="log-message ${!isSuccess ? 'log-error-message' : ''}">${message}</div>
          </div>
        `;
      }).join('');
      
      drawer.innerHTML = `
        <div class="log-drawer-header">Recent logs for: ${jobName}</div>
        <div class="log-drawer-content">${logsHtml}</div>
      `;
    }


    function editSchedule(jobid, currentSchedule, jobname) {
      const modal = document.getElementById('scheduleModal');
      const content = document.getElementById('scheduleModalContent');
      
      const cronPresets = [
        { label: 'Every minute', value: '* * * * *' },
        { label: 'Every 5 minutes', value: '*/5 * * * *' },
        { label: 'Every 15 minutes', value: '*/15 * * * *' },
        { label: 'Every 30 minutes', value: '*/30 * * * *' },
        { label: 'Every hour', value: '0 * * * *' },
        { label: 'Every 4 hours', value: '0 */4 * * *' },
        { label: 'Every 8 hours', value: '0 */8 * * *' },
        { label: 'Every 12 hours', value: '0 */12 * * *' },
        { label: 'Daily at midnight', value: '0 0 * * *' },
        { label: 'Daily at 6 AM', value: '0 6 * * *' },
        { label: 'Weekly (Monday 2 AM)', value: '0 2 * * 1' }
      ];

      content.innerHTML = `
        <h3>${jobname || `Job ${jobid}`}</h3>
        <div class="form-group">
          <label>Current Schedule</label>
          <input type="text" value="${currentSchedule}" readonly style="background: #f5f5f5;" />
        </div>
        <div class="form-group">
          <label>New Schedule (Cron Format)</label>
          <input type="text" id="newSchedule" value="${currentSchedule}" placeholder="* * * * *" />
          <small>Format: minute hour day month weekday (e.g., "0 */8 * * *" for every 8 hours)</small>
          <div class="cron-presets">
            ${cronPresets.map(preset => 
              `<button class="preset-btn" onclick="document.getElementById('newSchedule').value='${preset.value}'">${preset.label}</button>`
            ).join('')}
          </div>
        </div>
        <div class="job-actions">
          <button class="btn btn-primary" onclick="updateSchedule(${jobid})">Update Schedule</button>
          <button class="btn btn-secondary" onclick="closeScheduleModal()">Cancel</button>
        </div>
      `;
      
      modal.classList.add('active');
    }

    function closeScheduleModal() {
      document.getElementById('scheduleModal').classList.remove('active');
    }

    async function resetJobStats(jobid, jobname) {
      addDebugLog(`Reset stats requested for job ${jobid} (${jobname})`, 'info', { jobid, jobname });
      
      if (!confirm(`Are you sure you want to reset the success/fail statistics for "${jobname}" (Job ${jobid})?\n\nThis will delete all execution history for this job.`)) {
        addDebugLog('Reset stats cancelled by user', 'warning');
        return;
      }

      try {
        addDebugLog(`Sending reset request for job ${jobid}`, 'info');
        const response = await fetch(`${API_BASE}/api/admin?action=reset_job_stats`, {
          method: 'POST',
          headers: buildAuthHeaders(),
          body: JSON.stringify({ jobid: jobid })
        });

        addDebugLog(`Reset API response: ${response.status} ${response.statusText}`, 'info');

        if (!response.ok) {
          const errorText = await response.text();
          let errorData;
          try {
            errorData = JSON.parse(errorText);
          } catch {
            errorData = { message: errorText };
          }
          addDebugLog(`Reset API error response`, 'error', { status: response.status, statusText: response.statusText, error: errorData });
          throw new Error(`HTTP ${response.status}: ${errorData.detail || errorData.error || errorData.message || response.statusText}`);
        }

        const data = await response.json();
        addDebugLog('Reset API response data', 'info', data);
        
        if (!data.ok) {
          throw new Error(data.error || 'Failed to reset job statistics');
        }

        const deletedCount = data.deleted_count || 0;
        const remainingCount = data.remaining_count || 0;
        const beforeCount = data.before_count || 0;
        
        addDebugLog(`Reset stats result: before=${beforeCount}, deleted=${deletedCount}, remaining=${remainingCount}`, 
          remainingCount > 0 ? 'warning' : 'success', data);
        
        if (remainingCount > 0) {
          showMessage(`Warning: Reset completed but ${remainingCount} records still remain for "${jobname}" (Job ${jobid}). Deleted: ${deletedCount}`, 'error');
        } else {
          showMessage(`Successfully reset statistics for "${jobname}" (Job ${jobid}). Deleted ${deletedCount} records.`, 'success');
        }
        
        // Small delay to ensure database has updated before refreshing
        addDebugLog('Waiting 500ms before refreshing jobs...', 'info');
        setTimeout(() => {
          addDebugLog('Refreshing jobs after reset...', 'info');
          loadJobs();
        }, 500);
      } catch (error) {
        addDebugLog(`Error resetting job stats: ${error.message}`, 'error', { error: error.message, stack: error.stack });
        console.error('Error resetting job stats:', error);
        showMessage(`Error resetting statistics: ${error.message}`, 'error');
      }
    }

    async function toggleJob(jobid, active, jobname) {
      const action = active ? 'activate' : 'pause';
      if (!confirm(`Are you sure you want to ${action} "${jobname}" (Job ${jobid})?`)) {
        return;
      }

      try {
        const response = await fetch(`${API_BASE}/api/admin?action=toggle_cron_job`, {
          method: 'POST',
          headers: buildAuthHeaders(),
          body: JSON.stringify({ jobid, active })
        });

        const data = await response.json();
        if (!data.ok) {
          throw new Error(data.error || `Failed to ${action} job`);
        }

        showMessage(`Job ${active ? 'activated' : 'paused'} successfully!`, 'success');
        loadJobs();
      } catch (error) {
        showMessage(`Error ${action}ing job: ${error.message}`, 'error');
      }
    }

    // Helper function to calculate frequency_minutes from cron schedule
    function calculateFrequencyMinutes(cronSchedule) {
      const parts = cronSchedule.trim().split(/\s+/);
      if (parts.length !== 5) return null;
      
      const [minute, hour, dayOfMonth, month, dayOfWeek] = parts;
      
      // Every minute
      if (minute === '*' && hour === '*' && dayOfMonth === '*' && month === '*' && dayOfWeek === '*') {
        return 1;
      }
      
      // Every N minutes
      if (minute.startsWith('*/') && hour === '*' && dayOfMonth === '*' && month === '*' && dayOfWeek === '*') {
        return parseInt(minute.substring(2)) || null;
      }
      
      // Every hour at specific minute
      if (minute !== '*' && hour === '*' && dayOfMonth === '*' && month === '*' && dayOfWeek === '*') {
        return 60;
      }
      
      // Every N hours
      if (hour.startsWith('*/') && dayOfMonth === '*' && month === '*' && dayOfWeek === '*') {
        const hours = parseInt(hour.substring(2)) || 1;
        return hours * 60;
      }
      
      // Daily
      if (dayOfMonth === '*' && month === '*' && dayOfWeek === '*') {
        return 1440; // 24 hours
      }
      
      // Weekly
      if (dayOfWeek !== '*' && dayOfMonth === '*' && month === '*') {
        return 10080; // 7 days
      }
      
      // Monthly
      if (dayOfMonth !== '*' && month === '*' && dayOfWeek === '*') {
        return 43200; // ~30 days
      }
      
      return null;
    }

    async function updateSchedule(jobid) {
      const newSchedule = document.getElementById('newSchedule').value.trim();
      
      if (!newSchedule) {
        showMessage('Please enter a schedule', 'error');
        return;
      }

      try {
        // Update cron schedule
        const scheduleResponse = await fetch(`${API_BASE}/api/admin?action=update_cron_schedule`, {
          method: 'POST',
          headers: buildAuthHeaders(),
          body: JSON.stringify({ jobid, schedule: newSchedule })
        });

        const scheduleData = await scheduleResponse.json();
        if (!scheduleData.ok) {
          throw new Error(scheduleData.error || 'Failed to update schedule');
        }

        // Calculate and update frequency_minutes
        const frequencyMinutes = calculateFrequencyMinutes(newSchedule);
        if (frequencyMinutes !== null) {
          try {
            await fetch(`${API_BASE}/api/admin?action=update_schedule`, {
              method: 'POST',
              headers: buildAuthHeaders(),
              body: JSON.stringify({
                jobId: jobid,
                frequency_minutes: frequencyMinutes
              })
            });
          } catch (freqError) {
            // If frequency update fails, log but don't fail the whole operation
            console.warn('Failed to update frequency_minutes:', freqError);
          }
        }

        showMessage('Schedule updated successfully!', 'success');
        closeScheduleModal();
        loadJobs();
      } catch (error) {
        showMessage(`Error updating schedule: ${error.message}`, 'error');
      }
    }

    // Close modals when clicking outside
    window.onclick = function(event) {
      const scheduleModal = document.getElementById('scheduleModal');
      const logsModal = document.getElementById('logsModal');
      if (event.target === scheduleModal) {
        closeScheduleModal();
      }
      if (event.target === logsModal) {
        closeLogsModal();
      }
    }
  </script>

  <!-- Regression Details Modal -->
  <div id="regressionDetailsModal" class="modal">
    <div class="modal-content">
      <span class="close" onclick="closeRegressionDetails()">&times;</span>
      <div id="regressionDetailsContent"></div>
    </div>
  </div>

  <!-- Job Execution Results Modal -->
  <div id="jobExecutionModal" class="modal">
    <div class="modal-content" style="max-width: 1000px;">
      <span class="close" onclick="closeJobExecutionModal()">&times;</span>
      <div id="jobExecutionContent"></div>
    </div>
  </div>

  <script>
    // Close modals when clicking outside
    window.onclick = function(event) {
      const regressionModal = document.getElementById('regressionDetailsModal');
      const executionModal = document.getElementById('jobExecutionModal');
      
      if (event.target == regressionModal) {
        closeRegressionDetails();
      }
      if (event.target == executionModal) {
        closeJobExecutionModal();
      }
    }
  </script>

  <!-- Log Modal -->
  <div id="logModal" class="modal hidden">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">Run Logs for <span id="logJobName"></span></div>
        <button class="close-btn" onclick="closeLogModal()">&times;</button>
      </div>
      <pre id="logContent"></pre>
      <div style="margin-top: 15px;">
        <button class="btn btn-secondary" id="closeLogModalBtn">Close</button>
      </div>
    </div>
  </div>

  <!-- Debug Log -->
  <div class="debug-log-container" id="debugLogContainer">
    <div class="debug-log-header">
      <div class="debug-log-title">üîç Debug Log</div>
      <div class="debug-log-controls">
        <button class="btn btn-secondary btn-small" onclick="clearDebugLog()" style="padding: 4px 8px; font-size: 11px;">Clear</button>
        <button class="btn btn-primary btn-small" onclick="copyDebugLog()" style="padding: 4px 8px; font-size: 11px;">üìã Copy Log</button>
        <button class="btn btn-secondary btn-small" onclick="toggleDebugLog()" style="padding: 4px 8px; font-size: 11px;">‚ñº Hide</button>
      </div>
    </div>
    <div class="debug-log-content" id="debugLogContent"></div>
  </div>

  <script>
    // Global debug log
    const debugLog = [];
    const MAX_LOG_ENTRIES = 500;

    function addDebugLog(message, type = 'info', data = null) {
      const timestamp = new Date().toLocaleTimeString();
      const entry = {
        timestamp,
        message,
        type,
        data
      };
      
      debugLog.push(entry);
      
      // Keep only last MAX_LOG_ENTRIES
      if (debugLog.length > MAX_LOG_ENTRIES) {
        debugLog.shift();
      }
      
      // Update UI
      updateDebugLogDisplay();
    }

    function updateDebugLogDisplay() {
      const content = document.getElementById('debugLogContent');
      if (!content) return;
      
      const html = debugLog.map(entry => {
        const dataStr = entry.data ? `\n${JSON.stringify(entry.data, null, 2)}` : '';
        return `<div class="debug-log-entry ${entry.type}">
          <span class="debug-log-timestamp">[${entry.timestamp}]</span>
          ${entry.message}${dataStr ? `<pre style="margin: 4px 0 4px 20px; color: #808080; font-size: 11px;">${escapeHtml(dataStr)}</pre>` : ''}
        </div>`;
      }).join('');
      
      content.innerHTML = html;
      content.scrollTop = content.scrollHeight;
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function clearDebugLog() {
      debugLog.length = 0;
      updateDebugLogDisplay();
      addDebugLog('Debug log cleared', 'info');
    }

    function copyDebugLog() {
      const logText = debugLog.map(entry => {
        const dataStr = entry.data ? `\n${JSON.stringify(entry.data, null, 2)}` : '';
        return `[${entry.timestamp}] ${entry.type.toUpperCase()}: ${entry.message}${dataStr}`;
      }).join('\n\n');
      
      navigator.clipboard.writeText(logText).then(() => {
        addDebugLog('Debug log copied to clipboard', 'success');
      }).catch(err => {
        addDebugLog('Failed to copy log: ' + err.message, 'error');
      });
    }

    function toggleDebugLog() {
      const container = document.getElementById('debugLogContainer');
      const content = document.getElementById('debugLogContent');
      const btn = event.target;
      
      if (content.style.display === 'none') {
        content.style.display = 'block';
        container.style.maxHeight = '300px';
        btn.textContent = '‚ñº Hide';
      } else {
        content.style.display = 'none';
        container.style.maxHeight = '40px';
        btn.textContent = '‚ñ≤ Show';
      }
    }

    // Initialize debug log
    addDebugLog('Debug log initialized', 'info');
  </script>
</body>
</html>


