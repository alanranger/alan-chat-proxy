<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cron Job Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: #f5f5f5;
      padding: 20px;
      color: #333;
    }

    .container {
      max-width: 1800px;
      margin: 0 auto;
    }

    .job-section {
      margin-bottom: 30px;
    }

    .job-section-header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 15px 20px;
      border-radius: 8px 8px 0 0;
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 0;
    }

    .job-section-header.analytics {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    }

    .job-section-header.refresh {
      background: linear-gradient(135deg, #00f2fe 0%, #4facfe 100%);
    }

    .job-section-header.maintenance {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    }

    .job-section-header.performance {
      background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
    }

    .job-section-header.health {
      background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
    }

    .job-section-header.system {
      background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
    }

    .job-section-header.db-health {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }

    /* Summary Dashboard Styles */
    .summary-dashboard {
      background: white;
      border-radius: 12px;
      padding: 25px;
      margin-bottom: 30px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }

    .summary-dashboard h2 {
      margin: 0 0 20px 0;
      color: #2c3e50;
      font-size: 24px;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .summary-groups {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 20px;
      margin-bottom: 25px;
    }

    .summary-group {
      background: #f8f9fa;
      border-radius: 10px;
      padding: 18px;
      border: 2px solid #e0e0e0;
      transition: all 0.3s ease;
      cursor: pointer;
    }

    .summary-group:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
      border-color: #667eea;
    }

    .summary-group-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 15px;
    }

    .summary-group-title {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 16px;
      font-weight: 700;
      color: #2c3e50;
    }

    .summary-group-icon {
      font-size: 24px;
    }

    .summary-group-traffic-light {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      border: 2px solid #fff;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }

    .summary-group-traffic-light.green {
      background: #28a745;
      box-shadow: 0 0 10px rgba(40, 167, 69, 0.5);
    }

    .summary-group-traffic-light.amber {
      background: #ffc107;
      box-shadow: 0 0 10px rgba(255, 193, 7, 0.5);
    }

    .summary-group-traffic-light.red {
      background: #dc3545;
      box-shadow: 0 0 10px rgba(220, 53, 69, 0.5);
    }

    .summary-group-stats {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      font-size: 14px;
    }

    .summary-group-stat {
      display: flex;
      flex-direction: column;
      align-items: center;
      flex: 1;
    }

    .summary-group-stat-label {
      color: #6c757d;
      font-size: 11px;
      text-transform: uppercase;
      font-weight: 600;
      margin-bottom: 4px;
    }

    .summary-group-stat-value {
      font-size: 20px;
      font-weight: 700;
      color: #2c3e50;
    }

    .summary-group-jobs {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 12px;
    }

    .summary-job-indicator {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      background: white;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 600;
      border: 1px solid #dee2e6;
      transition: all 0.2s ease;
    }

    .summary-job-indicator:hover {
      transform: scale(1.05);
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .summary-job-indicator.green {
      border-color: #28a745;
      color: #28a745;
    }

    .summary-job-indicator.amber {
      border-color: #ffc107;
      color: #ff9800;
    }

    .summary-job-indicator.red {
      border-color: #dc3545;
      color: #dc3545;
    }

    .summary-job-indicator-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      display: inline-block;
    }

    .summary-job-indicator-dot.green {
      background: #28a745;
      box-shadow: 0 0 6px rgba(40, 167, 69, 0.6);
    }

    .summary-job-indicator-dot.amber {
      background: #ffc107;
      box-shadow: 0 0 6px rgba(255, 193, 7, 0.6);
    }

    .summary-job-indicator-dot.red {
      background: #dc3545;
      box-shadow: 0 0 6px rgba(220, 53, 69, 0.6);
    }

    .summary-heatmap {
      margin-top: 25px;
      padding-top: 25px;
      border-top: 2px solid #e0e0e0;
    }

    .summary-heatmap-title {
      font-size: 18px;
      font-weight: 700;
      color: #2c3e50;
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .summary-heatmap-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
      gap: 8px;
    }

    .summary-heatmap-cell {
      aspect-ratio: 1;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      font-weight: 700;
      color: white;
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
    }

    .summary-heatmap-cell:hover {
      transform: scale(1.1);
      z-index: 10;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }

    .summary-heatmap-cell.green {
      background: #28a745;
    }

    .summary-heatmap-cell.amber {
      background: #ffc107;
    }

    .summary-heatmap-cell.red {
      background: #dc3545;
    }

    .summary-heatmap-cell.inactive {
      background: #6c757d;
      opacity: 0.5;
    }

    .db-health-tile {
      background: white;
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      color: #000;
    }

    .db-health-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }

    .db-health-stat {
      background: #f8f9fa;
      padding: 12px;
      border-radius: 6px;
      border-left: 3px solid #667eea;
    }

    .db-health-stat-label {
      font-size: 14px;
      color: #000;
      margin-bottom: 6px;
      font-weight: 500;
    }

    .db-health-stat-value {
      font-size: 22px;
      font-weight: 700;
      color: #000;
    }

    .db-health-table {
      margin-top: 15px;
    }

    .db-health-table table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
      color: #000;
    }

    .db-health-table th,
    .db-health-table td {
      padding: 10px;
      text-align: left;
      border-bottom: 1px solid #e0e0e0;
      color: #000;
    }

    .db-health-table th {
      background: #f8f9fa;
      font-weight: 700;
      color: #000;
      font-size: 15px;
    }

    .db-health-table tr:hover {
      background: #f8f9fa;
    }

    .bloat-warning {
      color: #d9534f;
      font-weight: 700;
    }

    /* Traffic light colors for risk scores */
    .risk-green {
      background-color: #4CAF50;
      color: white;
    }

    .risk-amber {
      background-color: #FF9800;
      color: white;
    }

    .risk-red {
      background-color: #F44336;
      color: white;
    }

    .risk-badge {
      display: inline-block;
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 700;
      margin-left: 8px;
    }

    .db-health-risk-header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 15px 20px;
      border-radius: 8px 8px 0 0;
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .db-health-risk-score {
      font-size: 24px;
      font-weight: 700;
      padding: 8px 16px;
      border-radius: 8px;
    }

    .db-health-cards {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }

    .db-health-card {
      background: white;
      border-radius: 8px;
      padding: 15px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      border-left: 4px solid #ddd;
    }

    .db-health-card.risk-green {
      border-left-color: #4CAF50;
    }

    .db-health-card.risk-amber {
      border-left-color: #FF9800;
    }

    .db-health-card.risk-red {
      border-left-color: #F44336;
    }

    .db-health-card-title {
      font-size: 14px;
      font-weight: 600;
      color: #666;
      margin-bottom: 8px;
    }

    .db-health-card-value {
      font-size: 20px;
      font-weight: 700;
      color: #000;
    }

    .db-health-issues {
      background: #fff3cd;
      border: 1px solid #ffc107;
      border-radius: 6px;
      padding: 15px;
      margin-top: 15px;
    }

    .db-health-issues h3 {
      font-size: 16px;
      font-weight: 700;
      color: #000;
      margin-bottom: 10px;
    }

    .db-health-issues ul {
      margin: 0;
      padding-left: 20px;
    }

    .db-health-issues li {
      font-size: 14px;
      color: #000;
      margin-bottom: 6px;
    }

    .db-health-issues li.critical {
      color: #d9534f;
      font-weight: 600;
    }

    .db-health-issues li.warning {
      color: #f0ad4e;
      font-weight: 500;
    }

    .job-section-content {
      background: #f8f9fa;
      padding: 20px;
      border-radius: 0 0 8px 8px;
      border: 2px solid #e0e0e0;
    }

    h1 {
      margin-bottom: 30px;
      color: #2c3e50;
    }

    .auth-section {
      background: white;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .auth-section input {
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      width: 300px;
      margin-right: 10px;
    }

    .auth-section button {
      padding: 10px 20px;
      background: #3498db;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    .auth-section button:hover {
      background: #2980b9;
    }

    .controls {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    .btn {
      padding: 10px 20px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }

    .btn-primary {
      background: #3498db;
      color: white;
    }

    .btn-primary:hover {
      background: #2980b9;
    }

    .btn-secondary {
      background: #95a5a6;
      color: white;
    }

    .btn-secondary:hover {
      background: #7f8c8d;
    }

    .debug-log-container {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: #1e1e1e;
      color: #d4d4d4;
      border-top: 2px solid #007acc;
      max-height: 300px;
      display: flex;
      flex-direction: column;
      z-index: 10000;
      font-family: 'Courier New', monospace;
      font-size: 12px;
    }

    .debug-log-header {
      background: #252526;
      padding: 8px 15px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #3e3e42;
    }

    .debug-log-title {
      font-weight: bold;
      color: #4ec9b0;
    }

    .debug-log-controls {
      display: flex;
      gap: 10px;
    }

    .debug-log-content {
      flex: 1;
      overflow-y: auto;
      padding: 10px 15px;
      line-height: 1.6;
    }

    .debug-log-entry {
      margin-bottom: 4px;
      padding: 2px 0;
    }

    .debug-log-entry.error {
      color: #f48771;
    }

    .debug-log-entry.success {
      color: #4ec9b0;
    }

    .debug-log-entry.warning {
      color: #dcdcaa;
    }

    .debug-log-entry.info {
      color: #9cdcfe;
    }

    .debug-log-timestamp {
      color: #808080;
      margin-right: 8px;
    }

    .btn-warning {
      background: #f39c12;
      color: white;
    }

    .btn-warning:hover {
      background: #e67e22;
    }

    .btn-danger {
      background: #e74c3c;
      color: white;
    }

    .btn-danger:hover {
      background: #c0392b;
    }

    .btn-success {
      background: #27ae60;
      color: white;
    }

    .btn-success:hover {
      background: #229954;
    }

    .status-badge {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: bold;
    }

    .status-active {
      background: #2ecc71;
      color: white;
    }

    .status-inactive {
      background: #95a5a6;
      color: white;
    }

    .status-success {
      background: #2ecc71;
      color: white;
    }

    .status-failed {
      background: #e74c3c;
      color: white;
    }

    .badge-success {
      background-color: #4CAF50;
      color: white;
      padding: 3px 8px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: bold;
    }

    .badge-failure {
      background-color: #E53935;
      color: white;
      padding: 3px 8px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: bold;
    }

    .log-panel {
      background: #f7f7f7;
      padding: 10px;
      margin-top: 10px;
      border-radius: 6px;
      font-family: monospace;
      font-size: 12px;
      max-height: 250px;
      overflow-y: auto;
    }


    canvas {
      width: 100% !important;
      height: 100px !important;
    }

    .jobs-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .job-card {
      background: white;
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .job-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }

    .job-header {
      display: flex;
      justify-content: space-between;
      align-items: start;
      margin-bottom: 15px;
    }

    .job-title {
      font-size: 18px;
      font-weight: bold;
      color: #2c3e50;
    }

    .job-id {
      color: #2c3e50;
      font-size: 15px;
      font-weight: 600;
      margin-top: 6px;
      line-height: 1.5;
    }

    .job-description {
      color: #000000;
      font-size: 16px;
      margin-bottom: 15px;
      line-height: 1.6;
      font-weight: 400;
    }

    .frequency-pill {
      display: inline-block;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 13px;
      font-weight: 600;
      margin-bottom: 15px;
      margin-right: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .next-scheduled-pill {
      display: inline-block;
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      color: white;
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 13px;
      font-weight: 600;
      margin-bottom: 15px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .regression-test-section {
      background: #fff3cd;
      border: 1px solid #ffc107;
      border-radius: 6px;
      padding: 12px;
      margin: 15px 0;
      font-size: 13px;
    }

    .regression-test-section.severe {
      background: #f8d7da;
      border-color: #dc3545;
    }

    .regression-test-section.moderate {
      background: #fff3cd;
      border-color: #ffc107;
    }

    .regression-test-section.minor {
      background: #d1ecf1;
      border-color: #17a2b8;
    }

    .regression-test-section.no-regression {
      background: #d4edda;
      border-color: #28a745;
    }

    .regression-summary {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 10px;
    }

    .regression-stat {
      font-size: 12px;
    }

    .regression-stat-label {
      color: #6c757d;
      font-weight: 600;
    }

    .regression-stat-value {
      color: #2c3e50;
      font-weight: bold;
    }

    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
      overflow: auto;
    }

    .modal-content {
      background-color: #fefefe;
      margin: 5% auto;
      padding: 20px;
      border: 1px solid #888;
      border-radius: 8px;
      width: 90%;
      max-width: 1200px;
      max-height: 80vh;
      overflow-y: auto;
    }

    .close {
      color: #aaa;
      float: right;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
    }

    .close:hover {
      color: #000;
    }

    .details-section {
      margin: 20px 0;
      padding: 15px;
      background: #f8f9fa;
      border-radius: 6px;
    }

    .details-section h3 {
      margin-bottom: 10px;
      color: #2c3e50;
    }

    .query-change {
      margin: 10px 0;
      padding: 10px;
      background: white;
      border-left: 4px solid #3498db;
      border-radius: 4px;
    }

    .query-change.severe {
      border-left-color: #e74c3c;
    }

    .query-change.moderate {
      border-left-color: #f39c12;
    }

    .query-change.minor {
      border-left-color: #3498db;
    }

    .article-list {
      margin: 5px 0;
      font-size: 13px;
    }

    .article-removed {
      color: #e74c3c;
    }

    .article-added {
      color: #27ae60;
    }

    .job-schedule {
      background: #ecf0f1;
      padding: 8px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 13px;
      margin-bottom: 15px;
    }

    .job-stats {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin-bottom: 15px;
    }

    .stat-item {
      text-align: center;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 4px;
    }

    .stat-label {
      font-size: 12px;
      color: #7f8c8d;
      margin-bottom: 5px;
    }

    .stat-value {
      font-size: 18px;
      font-weight: bold;
      color: #2c3e50;
    }

    .success-rate {
      font-size: 14px;
      color: #2ecc71;
    }

    .failure-rate {
      font-size: 14px;
      color: #e74c3c;
    }

    .job-actions {
      display: flex;
      gap: 10px;
      margin-top: 15px;
    }

    .btn-small {
      padding: 6px 12px;
      font-size: 12px;
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      z-index: 1000;
      overflow-y: auto;
    }

    .modal.active {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .modal-content {
      background: white;
      border-radius: 8px;
      padding: 30px;
      max-width: 800px;
      width: 100%;
      max-height: 90vh;
      overflow-y: auto;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .modal-title {
      font-size: 24px;
      font-weight: bold;
    }

    .close-btn {
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
      color: #7f8c8d;
    }

    .close-btn:hover {
      color: #2c3e50;
    }

    .form-group {
      margin-bottom: 20px;
    }

    .form-group label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }

    .form-group input {
      width: 100%;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-family: monospace;
    }

    .form-group small {
      color: #7f8c8d;
      font-size: 12px;
    }

    .logs-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
    }

    .logs-table th,
    .logs-table td {
      padding: 10px;
      text-align: left;
      border-bottom: 1px solid #ddd;
    }

    .logs-table th {
      background: #f8f9fa;
      font-weight: bold;
    }

    .logs-table tr:hover {
      background: #f8f9fa;
    }

    .command-preview {
      background: #2c3e50;
      color: #ecf0f1;
      padding: 15px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 12px;
      overflow-x: auto;
      margin-top: 10px;
      max-height: 200px;
      overflow-y: auto;
    }

    .loading {
      text-align: center;
      padding: 40px;
      color: #7f8c8d;
    }

    .error {
      background: #fee;
      color: #c33;
      padding: 15px;
      border-radius: 4px;
      margin-bottom: 20px;
    }

    .success {
      background: #efe;
      color: #3c3;
      padding: 15px;
      border-radius: 4px;
      margin-bottom: 20px;
    }

    .cron-presets {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 10px;
    }

    .preset-btn {
      padding: 6px 12px;
      background: #ecf0f1;
      border: 1px solid #bdc3c7;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }

    .preset-btn:hover {
      background: #bdc3c7;
    }


    .next-run-badge {
      display: inline-block;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 600;
      margin-left: 8px;
    }

    .health-status {
      display: inline-block;
      padding: 4px 10px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 600;
      margin-bottom: 10px;
      margin-top: 5px;
    }

    .health-status.health-ok {
      background: #4CAF50;
      color: white;
    }

    .health-status.health-warning {
      background: #ff9900;
      color: white;
    }

    .health-status.health-error {
      background: #ff4d4d;
      color: white;
    }

    .sparkline-container {
      margin-top: 6px;
      position: relative;
    }
    
    /* Remove duplicate malformed graph */
    .sparkline-wrapper canvas:last-of-type {
      display: none;
    }
    
    /* Progress bar styles */
    .job-progress {
      margin-top: 6px;
      background: #f7f7f7;
      padding: 6px;
      border-radius: 6px;
      display: none;
    }
    
    .progress-bar-container {
      width: 100%;
      background: #ddd;
      border-radius: 4px;
      height: 6px;
      overflow: hidden;
    }
    
    .progress-bar {
      width: 0%;
      height: 6px;
      background-color: #4caf50;
      transition: width 0.3s;
    }
    
    .progress-message {
      display: block;
      font-size: 0.85rem;
      color: #666;
      margin-top: 4px;
    }

    .active-jobs-banner {
      margin: 12px 0;
      padding: 10px 12px;
      border-radius: 6px;
      background: #fff7e6;
      border: 1px solid #ffe0a3;
      font-size: 13px;
      color: #8a5400;
      display: none;
    }

    .active-job-pill {
      display: inline-block;
      margin: 3px 6px 3px 0;
      padding: 4px 8px;
      border-radius: 999px;
      background: #ffbf69;
      color: #7a3d00;
      font-size: 12px;
      font-weight: 600;
    }

    .db-maint-summary {
      margin-top: 12px;
      padding: 10px 12px;
      background: #f5f7fb;
      border-radius: 6px;
      border: 1px solid rgba(0,0,0,0.05);
      color: #111;
    }

    .db-maint-summary-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 8px 16px;
    }

    .db-maint-summary-item .label {
      font-size: 12px;
      color: #333;
    }

    .db-maint-summary-item .value {
      font-size: 15px;
      font-weight: 600;
      color: #000;
    }

    .db-maint-top-tables {
      margin-top: 10px;
      padding: 10px 12px;
      background: #ffffff;
      border-radius: 6px;
      border: 1px solid rgba(0,0,0,0.05);
      color: #111;
    }

    .db-maint-top-tables-header {
      font-size: 13px;
      font-weight: 600;
      margin-bottom: 6px;
      color: #111;
    }

    .db-maint-top-tables table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
      color: #111;
    }

    .db-maint-top-tables th,
    .db-maint-top-tables td {
      padding: 4px;
      text-align: left;
      color: #111;
    }

    .db-maint-top-tables th {
      border-bottom: 1px solid #e0e4ef;
      font-weight: 600;
      color: #000;
    }

    .db-maint-top-tables td.name {
      font-weight: 500;
    }

    .db-maint-top-tables .index-size {
      font-weight: 500;
    }

    .db-maint-top-tables tr.db-maint-big-index td.index-size {
      color: #d9534f;
      font-weight: 700;
    }

    .db-maint-top-tables-note {
      margin-top: 6px;
      font-size: 10px;
      color: #4a4f58;
    }

    .sparkline-section {
      margin-top: 15px;
      margin-bottom: 10px;
    }

    .sparkline {
      width: 150px;
      height: 50px;
      display: block;
    }

    .view-logs-btn {
      background: #6c757d;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      margin-top: 10px;
    }

    .view-logs-btn:hover {
      background: #5a6268;
    }

    .log-copy-btn {
      margin-left: auto;
      border: none;
      background: transparent;
      color: #3498db;
      cursor: pointer;
      font-size: 12px;
      padding: 0 4px;
    }

    .log-copy-btn:hover {
      text-decoration: underline;
    }

    .log-drawer {
      margin-top: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: #f8f9fa;
      padding: 0;
    }

    .log-drawer-header {
      background: #e9ecef;
      padding: 8px 12px;
      font-weight: 600;
      font-size: 13px;
      border-bottom: 1px solid #ddd;
      border-radius: 4px 4px 0 0;
    }

    .log-drawer-content {
      max-height: 220px;
      overflow-y: auto;
      padding: 10px;
    }

    .log-entry {
      padding: 8px;
      margin-bottom: 8px;
      background: white;
      border-radius: 4px;
      border-left: 3px solid #ddd;
    }

    .log-entry-header {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-bottom: 5px;
      font-size: 11px;
    }

    .log-status-badge {
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 10px;
      font-weight: 600;
    }

    .log-status-badge.status-success {
      background: #4CAF50;
      color: white;
    }

    .log-status-badge.status-failed {
      background: #E53935;
      color: white;
    }

    .log-timestamp {
      color: #666;
    }

    .log-duration {
      color: #999;
      font-size: 10px;
    }

    .log-message {
      font-size: 12px;
      color: #333;
      word-wrap: break-word;
    }

    .log-error-message {
      color: #E53935;
    }

    .log-loading {
      padding: 20px;
      text-align: center;
      color: #666;
    }

    .log-empty {
      padding: 20px;
      text-align: center;
      color: #999;
    }

    .log-error {
      padding: 15px;
      color: #E53935;
      background: #fee;
      border-radius: 4px;
      margin: 10px;
    }
  </style>
  <script>
    // Immediate auto-auth script - runs before DOMContentLoaded
    (function() {
      const DEFAULT_TOKEN = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImlnenZ3YnZndm16dnZ6b2NsdWZ4Iiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc1NzY3NzkyOCwiZXhwIjoyMDczMjUzOTI4fQ.W9tkTSYu6Wml0mUr-gJD6hcLMZDcbaYYaOsyDXuwd8M';
      try {
        if (DEFAULT_TOKEN) {
          localStorage.setItem('cron_dashboard_token', DEFAULT_TOKEN);
        }
      } catch(e) {
        console.warn('Could not set token in localStorage:', e);
      }
    })();
  </script>
</head>
<body>
  <div class="container">
    <h1>Cron Job Dashboard</h1>

    <div class="auth-section" id="authSection">
      <h3>Authentication</h3>
      <input type="password" id="authToken" placeholder="Enter admin token (default: b6c3f0c9e6f44cce9e1a4f3f2d3a5c76)" value="b6c3f0c9e6f44cce9e1a4f3f2d3a5c76" />
      <button onclick="setAuthToken()">Authenticate</button>
      <div style="margin-top: 8px; font-size: 12px; color: #666;">Token: Use INGEST_TOKEN or the default token shown above</div>
    </div>

    <div id="dashboard" style="display: none;">
      <div class="controls">
        <button class="btn btn-primary" onclick="loadJobs()">Refresh Jobs</button>
        <button class="btn btn-secondary" onclick="clearAuth()">Logout</button>
      </div>

      <div id="message"></div>
      <div id="jobsContainer" class="loading">Loading cron jobs...</div>
    </div>
  </div>

  <!-- Schedule Modal -->
  <div class="modal" id="scheduleModal">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">Update Schedule</div>
        <button class="close-btn" onclick="closeScheduleModal()">&times;</button>
      </div>
      <div id="scheduleModalContent"></div>
    </div>
  </div>

  <!-- Logs Modal -->
  <div class="modal" id="logsModal">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">Job Logs</div>
        <button class="close-btn" onclick="closeLogsModal()">&times;</button>
      </div>
      <div id="logsModalContent"></div>
    </div>
  </div>

  <script>
    /**
     * @typedef {Object} JobSummary
     * @property {number} jobid
     * @property {string} name
     * @property {number} frequency_minutes
     * @property {string|null} last_run      // ISO string, may be null
     * @property {number} total_runs
     * @property {number} success_count
     * @property {number} failed_count
     * @property {('active'|'paused'|'inactive')} status
     * @property {Array<{ date: string, success: boolean }>} recent_runs
     * @property {string} schedule
     * @property {string} jobname
     * @property {string} command
     */

    const API_BASE = window.location.origin;
    
    // Default admin token (INGEST_TOKEN)
    const DEFAULT_TOKEN = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImlnenZ3YnZndm16dnZ6b2NsdWZ4Iiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc1NzY3NzkyOCwiZXhwIjoyMDczMjUzOTI4fQ.W9tkTSYu6Wml0mUr-gJD6hcLMZDcbaYYaOsyDXuwd8M';
    
    let authToken = localStorage.getItem('cron_dashboard_token') || DEFAULT_TOKEN;

    // State for inline log viewer
    let activeLogJobId = null;
    const jobLogsCache = new Map(); // jobId -> { loading, error, entries }

    // Job descriptions
    const jobDescriptions = {
      13: 'Aggregates daily analytics from chat bot usage logs (user sessions, questions asked, answers given, confidence scores, and response times) for a specific date 7 days ago. Stores the results in chat_analytics_daily for historical reporting.',
      19: 'Analyzes all chat questions from the last 7 days, groups identical questions, counts how many times each was asked, calculates average confidence scores, and tracks which questions have low confidence. Updates the chat_question_frequency table to identify frequently asked questions and which ones need better answers. Powers the Questions tab in analytics.html.',
      20: 'Aggregates today\'s analytics from chat bot usage logs (sessions, questions, interactions, averages) and updates session records with total questions and interactions per session. Powers the Overview tab in analytics.html.',
      21: 'Refreshes the unified products materialized view which consolidates product data from multiple sources (page_entities, product_display_price, CSV metadata) into a single deduplicated view. Resolves product types (workshop vs course), extracts location hints, availability status, and pricing. Then updates display prices for all products by processing them in batches. The refreshed view feeds into v_products_unified_open → v_events_for_chat, which provides product pricing for events displayed in the chat bot. Ensures event pricing shown in chat responses is current.',
      22: 'Analyzes chat interactions from the last 30 days to find questions with low confidence scores (< 0.6). Groups identical questions, calculates frequency and average confidence, identifies which questions need better answers, and generates prioritized improvement recommendations (missing content, content gaps, intent confusion, high-impact fixes). Excludes questions already processed. Stores results in content_improvement_tracking table. Powers the Insights tab in analytics.html where you can review recommendations and mark questions as improved or ignored.',
      26: 'MASTER BATCH: Runs the complete light refresh process: 1) Executes 40Q regression test (before), 2) Runs Batch 0 (first third of URLs), which automatically chains to Batch 1 (second third), which chains to Batch 2 (final third), 3) Executes 40Q regression test (after) to verify no regressions. All three batches run sequentially from a single schedule trigger. Keeps the database in sync with website changes without requiring full re-ingestion.',
      27: 'AUTO-CHAINED: This batch runs automatically after Batch 0 completes. Handles the second third of URLs. Do not schedule this job separately - it is triggered automatically by Batch 0.',
      28: 'AUTO-CHAINED: This batch runs automatically after Batch 1 completes. Handles the final third of URLs. Do not schedule this job separately - it is triggered automatically by Batch 1.',
      29: 'Deletes old chat data (sessions, interactions, events) older than 90 days to prevent database bloat and maintain performance. Keeps the database size manageable while preserving recent chat history for analytics.',
      30: 'Removes debug logs older than 30 days from the debug_logs table. Prevents the debug logs table from growing indefinitely and consuming excessive storage space.',
      31: 'Identifies and removes orphaned records in the database. Deletes page_chunks that reference non-existent page_entities, and page_entities that reference non-existent csv_metadata records. Maintains data integrity and prevents referential inconsistencies.',
      32: 'Runs VACUUM and ANALYZE on key database tables to reclaim storage space, update query statistics, and optimize query performance. Processes high-traffic tables including chat tables, page entities, events, and products.',
      33: 'Checks the health of all URLs in the system. Identifies broken URLs (HTTP 4xx/5xx errors), stale URLs (not updated in 90+ days), and healthy URLs. Helps maintain content quality and identify pages that need attention.',
      34: 'Validates that all page chunks have proper embeddings for RAG search functionality. Counts total chunks, chunks with embeddings, and chunks missing embeddings. Ensures the chat bot can properly search and retrieve content.',
      35: 'Analyzes content freshness across all URLs. Identifies content that hasn\'t been updated in 60+ days and calculates average content age. Helps identify stale content that may need refreshing or removal.',
      36: 'Backs up daily analytics data to ensure long-term retention. Verifies that yesterday\'s analytics data has been properly stored in chat_analytics_daily table for historical reporting and analysis.',
      37: 'Monitors the health of all active cron jobs. Identifies jobs with recent failures (more than 3 failures in 24 hours = critical, any failures = warning) or jobs that haven\'t succeeded in 48+ hours. Helps detect and alert on system issues early.',
      38: 'Purges stale database health snapshots and alerts so the db_health tables remain lightweight while preserving the most recent history for reporting.',
      39: 'Monitors database health metrics and creates snapshots every 6 hours. Collects database size, table counts, debug log counts, table bloat percentages, and chunk counts. Calculates risk scores for debug logs, table bloat, and chunking health. Creates alerts when thresholds are exceeded (e.g., debug logs >20k, bloat >4%, 0 chunks). Stores historical snapshots in db_health_snapshots and alerts in db_health_alerts tables for trend analysis and early warning detection.',
      40: 'Builds a weekly database summary combining health scores, maintenance activity, and storage trends so you can spot regressions at a glance.',
      41: 'Cleans up expired rows in daily page_html tables (older rendered HTML snapshots) to keep storage lean and prevent duplicate content from accumulating.',
      42: 'Analyzes the latest page_html captures to detect structure changes, extract metadata, and flag any pages that need a re-ingest or manual review.',
      43: 'Drops temporary regression tables used for troubleshooting so each new regression run starts from a clean slate.'
    };

    // Define linked jobs (jobs that run together and are related)
    // Jobs 13, 19, 20, and 22 are all linked together (analytics jobs)
    // Jobs 26, 27, and 28 are all linked together (refresh batches)
    const linkedJobs = {
      13: [19, 20, 22],  // Job 13 is linked to Jobs 19, 20, and 22
      19: [13, 20, 22],  // Job 19 is linked to Jobs 13, 20, and 22
      20: [13, 19, 22],  // Job 20 is linked to Jobs 13, 19, and 22
      22: [13, 19, 20],  // Job 22 is linked to Jobs 13, 19, and 20
      26: [27, 28],  // Job 26 is linked to Jobs 27 and 28
      27: [26, 28],  // Job 27 is linked to Jobs 26 and 28
      28: [26, 27]   // Job 28 is linked to Jobs 26 and 27
    };

    // All jobs now support progress tracking - this list is kept for backward compatibility
    // but progress containers are rendered for all jobs
    const jobsWithProgressTracking = [13, 19, 20, 21, 22, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43];
    let activeJobs = [];

    // Regression tests for Jobs 27/28 mirror Job 26 results
    const regressionMirrorMap = {
      27: 26,
      28: 26
    };

    function getRegressionSourceJobId(jobId) {
      return regressionMirrorMap[jobId] || jobId;
    }

    // Custom display names for jobs
    const jobDisplayNames = {
      26: 'Website Pages Refresh Batch 0',
      27: 'Website Pages Refresh Batch 1',
      28: 'Website Pages Refresh Batch 2'
    };

    function formatDuration(seconds = 0) {
      if (!seconds || seconds < 1) return '<1s';
      if (seconds < 60) return `${Math.round(seconds)}s`;
      const mins = Math.floor(seconds / 60);
      const secs = Math.round(seconds % 60);
      return `${mins}m ${secs}s`;
    }

    async function loadActiveJobs() {
      try {
        const response = await fetch(`${API_BASE}/api/admin?action=active_jobs`, {
          headers: buildAuthHeaders()
        });
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        const data = await response.json();
        activeJobs = data.ok ? (data.jobs || []) : [];
        addDebugLog(`Active jobs loaded: ${activeJobs.length}`, 'info');
        // If jobs are already rendered, start polling for active ones
        if (document.getElementById('jobsContainer')) {
          startPollingForActiveJobs();
        }
      } catch (error) {
        activeJobs = [];
        addDebugLog(`Failed to load active jobs: ${error.message}`, 'warning');
      }
    }

    function renderActiveJobsBanner() {
      const banner = document.getElementById('activeJobsBanner');
      if (!banner) return;
      if (!activeJobs.length) {
        banner.style.display = 'none';
        banner.innerHTML = '';
        return;
      }
      const pills = activeJobs.map(job => {
        const label = job.job_hint || (job.query ? job.query.trim().replace(/\s+/g, ' ').slice(0, 80) + '…' : 'Active query');
        const duration = job.duration_seconds ? formatDuration(job.duration_seconds) : '';
        const wait = job.wait_event ? ` • waiting on ${job.wait_event}` : '';
        return `<span class="active-job-pill">${label}${duration ? ` (${duration})` : ''}${wait}</span>`;
      }).join('');
      banner.innerHTML = `<strong>Active jobs:</strong> ${pills}`;
      banner.style.display = 'block';
    }

    function setAuthToken() {
      const tokenInput = document.getElementById('authToken');
      const token = tokenInput ? tokenInput.value : DEFAULT_TOKEN;
      if (token) {
        authToken = token;
        localStorage.setItem('cron_dashboard_token', token);
        document.getElementById('authSection').style.display = 'none';
        document.getElementById('dashboard').style.display = 'block';
        loadJobs();
      }
    }
    
    // Progress polling function (live updating every 2 seconds)
    const MAX_PROGRESS_RETRIES = 10;
    const progressRetryState = new Map(); // jobid -> { attempts, timer }
    const activeJobStartTimes = new Map(); // jobid -> timestamp when first detected as active

    function getProgressContainer(jobid) {
      return document.querySelector(`#progress-${jobid}`);
    }

    function showProgressContainer(jobid, initialMessage = 'Queued...') {
      const container = getProgressContainer(jobid);
      if (!container) return null;
      container.style.display = 'block';
      container.onclick = null;
      const bar = container.querySelector('.progress-bar');
      const msg = container.querySelector('.progress-message');
      if (bar) bar.style.width = '0%';
      if (msg) msg.textContent = initialMessage;
      return container;
    }

    function extractJobIdFromHint(job_hint) {
      if (!job_hint) return null;
      const match = job_hint.match(/Job\s+(\d+)/i);
      return match ? parseInt(match[1], 10) : null;
    }

    function mergeProgressWithActiveJob(jobid, prog) {
      // ALWAYS prioritize actual progress data from API over any fallback
      if (prog && prog.progress !== undefined && prog.progress !== null) {
        // If progress is 100%, job is complete
        if (prog.progress >= 100) {
          return prog;
        }
        // If we have actual progress data, use it (even if job is no longer active)
        return prog;
      }
      
      const active = activeJobs.find(job => {
        if (!job.job_hint) return false;
        const hintJobId = extractJobIdFromHint(job.job_hint);
        return hintJobId === jobid;
      });
      if (!active) {
        // Job no longer in active list
        // If API returned null/undefined, it means no progress record exists
        // Check if we have a start time for fallback
        const startTime = activeJobStartTimes.get(jobid);
        if (startTime) {
          const elapsed = (Date.now() - startTime) / 1000;
          return {
            progress: 5,
            message: `Running (${formatDuration(elapsed)}) - may have completed`,
            activeFallback: true
          };
        }
        return null;
      }
      
      // Use database duration if available, otherwise calculate from start time
      let duration = active.duration_seconds;
      if (!duration || duration < 0) {
        const startTime = activeJobStartTimes.get(jobid);
        if (startTime) {
          duration = (Date.now() - startTime) / 1000;
        } else {
          // First time seeing this job, record start time
          activeJobStartTimes.set(jobid, Date.now());
          duration = active.duration_seconds || 0;
        }
      } else {
        // Update start time based on current duration
        activeJobStartTimes.set(jobid, Date.now() - (duration * 1000));
      }
      
      // Warn if job has been running for more than 10 minutes
      const isLongRunning = duration > 600;
      const warningPrefix = isLongRunning ? '⚠️ ' : '';
      
      return {
        progress: 5,
        message: active.wait_event
          ? `${warningPrefix}Running (${formatDuration(duration)}), waiting on ${active.wait_event}`
          : `${warningPrefix}Running (${formatDuration(duration)})`,
        activeFallback: true
      };
    }

    function startPollingForActiveJobs() {
      // Extract job IDs from active jobs and start polling for any job with a progress container
      activeJobs.forEach(activeJob => {
        if (!activeJob.job_hint) return;
        const jobId = extractJobIdFromHint(activeJob.job_hint);
        if (!jobId) return;
        
        // Check if we're already polling this job
        if (progressRetryState.has(jobId)) return;
        
        // Show progress container immediately and start polling (all jobs have progress containers now)
        const container = getProgressContainer(jobId);
        if (container) {
          showProgressContainer(jobId, 'Checking status...');
          addDebugLog(`Starting progress polling for active job ${jobId}`, 'info');
          pollJobProgress(jobId);
        }
      });
    }

    async function pollJobProgress(jobid, attempt = 0) {
      try {
        addDebugLog(`Polling progress for job ${jobid}`, 'info');
        
        // Refresh active jobs data every 5 polls (every ~10 seconds) to get fresh duration
        if (attempt % 5 === 0) {
          await loadActiveJobs();
        }
        
        const res = await fetch(`${API_BASE}/api/admin?action=job_progress&jobid=${jobid}`);
        const json = await res.json();
        const prog = mergeProgressWithActiveJob(jobid, json.progress);
        
        addDebugLog(`Progress data for job ${jobid}:`, 'info', { progress: prog });
        
        const container = getProgressContainer(jobid) || showProgressContainer(jobid, 'Queued...');
        if (!container) {
          addDebugLog(`Progress container not found for job ${jobid}`, 'warning');
          console.warn(`Progress container not found for job ${jobid}`);
          return;
        }
        
        const bar = container.querySelector('.progress-bar');
        const msg = container.querySelector('.progress-message');
        
        // If no progress data yet, keep polling (job might be starting)
      if (!prog) {
          const nextAttempt = attempt + 1;
          showProgressContainer(jobid, `Queued... (waiting ${nextAttempt}/${MAX_PROGRESS_RETRIES})`);
          if (nextAttempt < MAX_PROGRESS_RETRIES) {
            const delay = Math.min(2000 * Math.pow(1.5, nextAttempt), 15000);
            progressRetryState.set(jobid, { attempts: nextAttempt });
            setTimeout(() => pollJobProgress(jobid, nextAttempt), delay);
          } else {
            if (msg) {
              msg.textContent = 'No progress yet. Click to retry.';
              container.onclick = () => {
                container.onclick = null;
                progressRetryState.set(jobid, { attempts: 0 });
                pollJobProgress(jobid, 0);
              };
            }
          }
          return;
        }
        
        // Show progress
        addDebugLog(`Updating progress for job ${jobid}: ${prog.progress}% - ${prog.message}`, 'info');
        container.style.display = "block";
        container.onclick = null;
        if (bar) {
          bar.style.width = `${prog.progress}%`;
        }
        if (msg) {
          msg.textContent = prog.message || `Progress: ${prog.progress}%`;
        }
        
        // If progress is 100%, job is complete - stop polling and refresh
        if (prog.progress >= 100) {
          addDebugLog(`Job ${jobid} completed (100%)`, 'success');
          activeJobStartTimes.delete(jobid); // Clean up
          progressRetryState.delete(jobid); // Stop polling
          // Refresh jobs list to show updated stats
          setTimeout(() => loadJobs(), 1000);
          return;
        }
        
        // If using fallback and job is no longer active, check if it actually completed
        // Stop polling after a few attempts if job is no longer active
        if (prog.activeFallback && prog.message && prog.message.includes('may have completed')) {
          // Job is no longer in activeJobs - check actual progress one more time
          // If still no progress data after 3 attempts, assume it completed and stop polling
          const fallbackAttempts = progressRetryState.get(jobid)?.fallbackAttempts || 0;
          if (fallbackAttempts >= 3) {
            addDebugLog(`Job ${jobid} no longer active after ${fallbackAttempts} checks, assuming completed`, 'info');
            activeJobStartTimes.delete(jobid);
            progressRetryState.delete(jobid);
            setTimeout(() => loadJobs(), 1000);
            return;
          }
          progressRetryState.set(jobid, { attempts: 0, fallbackAttempts: fallbackAttempts + 1 });
          // Check again in 5 seconds
          setTimeout(() => pollJobProgress(jobid, attempt + 1), 5000);
          return;
        }
        
        // Continue polling if not complete
        progressRetryState.set(jobid, { attempts: 0 });
        if (prog.progress < 100 || (prog.message && prog.message.toLowerCase().includes('waiting'))) {
          const delay = prog.message && prog.message.toLowerCase().includes('waiting') ? 5000 : 2000;
          setTimeout(() => pollJobProgress(jobid, attempt + 1), delay);
        } else {
          // Job might be complete but progress not updated - refresh jobs list
          addDebugLog(`Job ${jobid} may have completed, refreshing jobs list`, 'info');
          activeJobStartTimes.delete(jobid);
          progressRetryState.delete(jobid);
          setTimeout(() => loadJobs(), 1000);
        }
      } catch (err) {
        addDebugLog(`Failed to poll progress for job ${jobid}: ${err.message}`, 'error', { error: err });
        console.warn(`Failed to poll progress for job ${jobid}:`, err);
        const nextAttempt = attempt + 1;
        const delay = Math.min(2000 * Math.pow(1.5, nextAttempt), 15000);
        setTimeout(() => pollJobProgress(jobid, nextAttempt), delay);
      }
    }

    function clearAuth() {
      authToken = '';
      localStorage.removeItem('cron_dashboard_token');
      document.getElementById('authSection').style.display = 'block';
      const tokenInput = document.getElementById('authToken');
      if (tokenInput) {
        tokenInput.value = DEFAULT_TOKEN;
      }
      document.getElementById('dashboard').style.display = 'none';
    }

    // Auto-authenticate on page load if token is available
    window.addEventListener('DOMContentLoaded', function() {
      try {
        const tokenInput = document.getElementById('authToken');
        if (tokenInput) {
          tokenInput.value = DEFAULT_TOKEN;
        }
        
        // Always use DEFAULT_TOKEN for auto-auth
        if (DEFAULT_TOKEN) {
          authToken = DEFAULT_TOKEN;
          localStorage.setItem('cron_dashboard_token', DEFAULT_TOKEN);
          
          // Hide auth section and show dashboard
          const authSection = document.getElementById('authSection');
          const dashboard = document.getElementById('dashboard');
          
          if (authSection) {
            authSection.style.display = 'none';
          }
          if (dashboard) {
            dashboard.style.display = 'block';
          }
          
          // Load jobs after a small delay to ensure DOM is ready
          setTimeout(function() {
            if (typeof loadJobs === 'function') {
              loadJobs();
            }
          }, 100);
        }
      } catch (error) {
        console.error('Error during auto-authentication:', error);
        // If there's an error, show auth section
        const authSection = document.getElementById('authSection');
        const dashboard = document.getElementById('dashboard');
        if (authSection) {
          authSection.style.display = 'block';
        }
        if (dashboard) {
          dashboard.style.display = 'none';
        }
      }
    });

    const buildAuthHeaders = () => ({
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${authToken}`
    });

    /**
     * Normalize API job data to JobSummary shape
     * @param {Object} apiJob - Raw job data from API
     * @returns {JobSummary}
     */
    function normalizeJob(apiJob) {
      // Parse schedule to get human-readable description
      const schedule = apiJob.schedule || '';
      const scheduleDescription = parseCronFrequency(schedule);
      
      return {
        jobid: apiJob.jobid,
        name: apiJob.jobname || apiJob.name || `Job ${apiJob.jobid}`,
        last_run: apiJob.last_run || null,
        last_run_status: apiJob.last_run_status || null, // Preserve last_run_status from API
        total_runs: apiJob.total_runs || 0,
        success_count: apiJob.success_count || 0,
        failed_count: apiJob.failed_count || 0,
        status: apiJob.active ? 'active' : 'inactive',
        recent_runs: apiJob.recent_runs || [],
        schedule: schedule,
        schedule_description: scheduleDescription,
        jobname: apiJob.jobname || apiJob.name || `Job ${apiJob.jobid}`,
        command: apiJob.command || '',
        maintenanceSummary: apiJob.maintenanceSummary || null,
        maintenanceTopTables: apiJob.maintenanceTopTables || null
      };
    }

    // Global variable to store database health data for use across the dashboard
    let globalDatabaseHealthData = null;

    async function loadDatabaseHealth() {
      try {
        // Try extended endpoint first, fallback to basic
        const response = await fetch(`${API_BASE}/api/db-health-extended`, {
          headers: buildAuthHeaders()
        });

        if (response.status === 401) {
          globalDatabaseHealthData = null;
          return null;
        }

        if (!response.ok) {
          // Fallback to basic endpoint
          const basicResponse = await fetch(`${API_BASE}/api/db-health`, {
            headers: buildAuthHeaders()
          });
          if (basicResponse.ok) {
            const data = await basicResponse.json();
            globalDatabaseHealthData = data;
            return data || null;
          }
          console.warn('Failed to load database health:', response.status);
          globalDatabaseHealthData = null;
          return null;
        }

        const data = await response.json();
        globalDatabaseHealthData = data;
        return data || null;
      } catch (error) {
        console.warn('Error loading database health:', error);
        globalDatabaseHealthData = null;
        return null;
      }
    }

    async function refreshDatabaseHealth() {
      // Clear cached data to force fresh fetch
      globalDatabaseHealthData = null;
      // Reload database health data with cache busting
      const timestamp = new Date().getTime();
      try {
        const response = await fetch(`${API_BASE}/api/db-health-extended?t=${timestamp}`, {
          headers: buildAuthHeaders(),
          cache: 'no-store'
        });
        if (response.ok) {
          const data = await response.json();
          globalDatabaseHealthData = data;
        }
      } catch (error) {
        console.error('Error refreshing database health:', error);
      }
      // Reload jobs to refresh the display
      await loadJobs();
    }

    function getRiskColor(risk) {
      if (risk <= 25) return 'risk-green';
      if (risk <= 60) return 'risk-amber';
      return 'risk-red';
    }

    function getRiskLabel(risk) {
      if (risk <= 25) return '🟢 Healthy';
      if (risk <= 60) return '🟠 Warning';
      return '🔴 Critical';
    }

    function renderDatabaseHealthTile(healthData) {
      if (!healthData) {
        return '<div class="db-health-tile"><div class="error">Failed to load database health data</div></div>';
      }

      const formatBytes = (bytes) => {
        if (bytes === 0) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
      };

      const formatDate = (dateStr) => {
        if (!dateStr) return 'N/A';
        try {
          return new Date(dateStr).toLocaleString();
        } catch {
          return dateStr;
        }
      };

      // Check if we have extended data (with risk scores)
      // Handle both direct jsonb response and wrapped response
      const actualData = healthData.db_health_extended || healthData;
      const hasExtended = actualData.risk_scores !== undefined;
      const riskScores = actualData.risk_scores || {};
      const totalRisk = riskScores.total_risk || 0;
      const riskColor = getRiskColor(totalRisk);
      const riskLabel = getRiskLabel(totalRisk);

      // Map API response structure to expected format
      const dbSize = actualData.db_size || {};
      const tableBloat = actualData.table_bloat || [];
      const debugLogs = actualData.debug_logs || {};
      const chunks = actualData.chunks || {};
      const pageHtml = actualData.page_html || {};

      let html = '';
      
      // Risk header (if extended data available) - render outside tile
      if (hasExtended) {
        const refreshedAt = actualData.refreshed_at || null;
        const refreshTime = refreshedAt ? new Date(refreshedAt).toLocaleString() : '';
        
        html += `<div class="db-health-risk-header" style="margin-bottom: 0; display: flex; justify-content: space-between; align-items: center;">
          <div>
            <span>💾 Database Health</span>
            ${refreshTime ? `<div style="font-size: 12px; opacity: 0.7; margin-top: 4px; text-align: right;">Last refreshed: ${refreshTime}</div>` : ''}
          </div>
          <div style="display: flex; align-items: center; gap: 12px;">
            <span class="db-health-risk-score ${riskColor}">
              Total Risk: ${totalRisk} ${riskLabel}
            </span>
            <button 
              onclick="refreshDatabaseHealth()" 
              style="padding: 6px 12px; background: #4A6CF7; color: white; border-radius: 6px; border: none; cursor: pointer; font-size: 14px;"
              title="Refresh database health data"
            >
              🔄 Refresh
            </button>
          </div>
        </div>`;
      }
      
      html += '<div class="db-health-tile">';

      // Traffic light cards (if extended data available)
      if (hasExtended) {
        const debugRisk = riskScores.debug_log_risk || 0;
        const bloatRisk = riskScores.bloat_risk || 0;
        const chunkRisk = riskScores.chunk_risk || 0;

        html += '<div class="db-health-cards">';
        html += `<div class="db-health-card ${getRiskColor(0)}">
          <div class="db-health-card-title" title="Total physical size including heap + toast + indexes">Database Size ℹ️</div>
          <div class="db-health-card-value">${dbSize.total_size_pretty || '0 B'}</div>
          <div style="font-size: 12px; color: #666; margin-top: 4px;">${dbSize.table_count || 0} tables</div>
        </div>`;
        html += `<div class="db-health-card ${getRiskColor(debugRisk)}">
          <div class="db-health-card-title" title="Number of debug logs remaining. High = ingestion or error spam.">Debug Log Health ℹ️</div>
          <div class="db-health-card-value">${(debugLogs.log_count || 0).toLocaleString()}</div>
          <div style="font-size: 12px; color: #666; margin-top: 4px;">Risk: ${debugRisk}</div>
        </div>`;
        html += `<div class="db-health-card ${getRiskColor(bloatRisk)}">
          <div class="db-health-card-title" title="Bloat % on large tables. >2.5% requires VACUUM FULL.">Table Bloat Health ℹ️</div>
          <div class="db-health-card-value">${pageHtml.dead_row_pct?.toFixed(1) || 0}%</div>
          <div style="font-size: 12px; color: #666; margin-top: 4px;">Risk: ${bloatRisk}</div>
        </div>`;
        html += `<div class="db-health-card ${getRiskColor(chunkRisk)}">
          <div class="db-health-card-title" title="Health of Supabase page_chunks ingestion. 0 chunks = broken.">Chunking Health ℹ️</div>
          <div class="db-health-card-value">${(chunks.chunk_count || 0).toLocaleString()}</div>
          <div style="font-size: 12px; color: #666; margin-top: 4px;">Risk: ${chunkRisk}</div>
        </div>`;
        html += '</div>';

        // Top Issues panel
        const issues = [];
        if (debugRisk > 30) {
          const level = debugRisk > 60 ? 'critical' : 'warning';
          const logCount = (debugLogs.log_count || 0).toLocaleString();
          const logMessage = debugRisk > 60 ? 'Ingestion likely looping.' : 'Consider cleanup.';
          issues.push({ level, text: 'Debug logs at ' + logCount + '. ' + logMessage });
        }
        if (bloatRisk > 30) {
          const level = bloatRisk > 60 ? 'critical' : 'warning';
          const tableName = pageHtml.dead_row_pct ? 'page_html' : 'tables';
          const bloatPct = (pageHtml.dead_row_pct || 0).toFixed(1);
          issues.push({ level, text: tableName + ' bloat at ' + bloatPct + '%. Vacuum recommended.' });
        }
        if (chunkRisk > 30) {
          const level = chunkRisk > 60 ? 'critical' : 'warning';
          if (chunks.chunk_count === 0) {
            issues.push({ level, text: '0 page_chunks present — ingestion chunking disabled or broken.' });
          } else {
            const maxSize = formatBytes(chunks.max_chunk_size || 0);
            issues.push({ level, text: 'Chunk size issues detected. Max: ' + maxSize });
          }
        }

        if (issues.length > 0) {
          html += '<div class="db-health-issues">';
          html += '<h3>⚠️ Top Issues</h3>';
          html += '<ul>';
          issues.forEach(issue => {
            html += `<li class="${issue.level}">${issue.text}</li>`;
          });
          html += '</ul>';
          html += '</div>';
        }
      } else {
        // Fallback to basic stats grid
        html += '<div class="db-health-stats">';
        html += `<div class="db-health-stat">
          <div class="db-health-stat-label">Database Size</div>
          <div class="db-health-stat-value">${dbSize.total_size_pretty || '0 B'}</div>
        </div>`;
        html += `<div class="db-health-stat">
          <div class="db-health-stat-label">Table Count</div>
          <div class="db-health-stat-value">${dbSize.table_count || 0}</div>
        </div>`;
        html += `<div class="db-health-stat">
          <div class="db-health-stat-label">Debug Logs</div>
          <div class="db-health-stat-value">${(debugLogs.log_count || 0).toLocaleString()}</div>
        </div>`;
        html += `<div class="db-health-stat">
          <div class="db-health-stat-label">Page Chunks</div>
          <div class="db-health-stat-value">${(chunks.chunk_count || chunks.total_chunks || 0).toLocaleString()}</div>
        </div>`;
        html += '</div>';
      }

      // Top 20 largest tables (from extended data) or top 10 (from basic)
      const tablesToShow = tableBloat.length > 0 ? tableBloat : (actualData.largest_tables || []).slice(0, 10);
      if (tablesToShow && tablesToShow.length > 0) {
        html += '<div class="db-health-table">';
        html += `<h3 style="margin-bottom: 12px; font-size: 16px; font-weight: 700; color: #000;">Top ${tablesToShow.length} Largest Tables</h3>`;
        html += '<table>';
        html += '<thead><tr><th>Table</th><th>Size</th><th>Dead Row %</th><th>Scans</th>';
        if (hasExtended) {
          html += '<th>Risk</th>';
        }
        html += '</tr></thead>';
        html += '<tbody>';
        tablesToShow.forEach(table => {
          const deadRowPct = table.dead_row_pct || 0;
          const tableSizeBytes = table.total_bytes || 0;
          const isSignificantTable = tableSizeBytes >= 1048576; // >= 1 MB
          // Only mark as Critical if table is >= 1 MB AND has high bloat
          // Small tables with high bloat are not a real concern
          const bloatClass = (deadRowPct > 20 && isSignificantTable) ? 'bloat-warning' : '';
          const tableRisk = (deadRowPct > 20 && isSignificantTable) ? 90 : 
                           (deadRowPct > 10 && isSignificantTable) ? 60 : 
                           (deadRowPct > 3 && isSignificantTable) ? 30 : 10;
          const riskBadge = hasExtended ? `<td><span class="risk-badge ${getRiskColor(tableRisk)}">${getRiskLabel(tableRisk).replace(/[🟢🟠🔴]/g, '').trim()}</span></td>` : '';
          
          // Heatmap color based on bloat percentage
          function getBloatColor(pct) {
            if (pct >= 10) return "rgb(200,0,0)";       // red
            if (pct >= 5) return "rgb(255,150,0)";     // amber
            return "rgb(0,180,0)";                     // green
          }
          const bloatColor = getBloatColor(deadRowPct);
          
          html += `<tr>
            <td style="font-weight: 500;">${table.table_name || 'N/A'}</td>
            <td style="font-weight: 500;">${table.total_pretty || table.total_size_pretty || '0 B'}</td>
            <td class="${bloatClass}" style="font-weight: 600; color: ${bloatColor};">${deadRowPct.toFixed(1)}%</td>
            <td style="font-weight: 500; font-size: 12px;">Idx: ${(table.idx_scan || 0).toLocaleString()}<br>Seq: ${(table.seq_scan || 0).toLocaleString()}</td>
            ${riskBadge}
          </tr>`;
        });
        html += '</tbody></table>';
        html += '</div>';
      }

      // Debug log stats
      if (debugLogs) {
        html += '<div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #e0e0e0;">';
        html += '<h3 style="margin-bottom: 10px; font-size: 16px; font-weight: 700; color: #000;">Debug Logs</h3>';
        html += `<div style="font-size: 14px; color: #000;">
          <div style="font-weight: 500;">Count: ${(debugLogs.log_count || 0).toLocaleString()}</div>
          <div style="margin-top: 6px; font-weight: 500;">Oldest: ${formatDate(debugLogs.oldest_log)}</div>
          <div style="margin-top: 6px; font-weight: 500;">Newest: ${formatDate(debugLogs.newest_log)}</div>
        </div>`;
        html += '</div>';
      }

      // Page chunk stats
      if (chunks) {
        html += '<div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #e0e0e0;">';
        html += '<h3 style="margin-bottom: 10px; font-size: 16px; font-weight: 700; color: #000;">Page Chunks</h3>';
        html += `<div style="font-size: 14px; color: #000;">
          <div style="font-weight: 500;">Total: ${(chunks.chunk_count || chunks.total_chunks || 0).toLocaleString()}</div>
          <div style="margin-top: 6px; font-weight: 500;">Avg Size: ${formatBytes(chunks.avg_chunk_size || chunks.avg_chunk || 0)}</div>
          <div style="margin-top: 6px; font-weight: 500;">Max Size: ${formatBytes(chunks.max_chunk_size || chunks.max_chunk || 0)}</div>
          ${chunks.newest_chunk ? `<div style="margin-top: 6px; font-weight: 500;">Newest: ${formatDate(chunks.newest_chunk)}</div>` : ''}
          ${chunks.oldest_chunk ? `<div style="margin-top: 6px; font-weight: 500;">Oldest: ${formatDate(chunks.oldest_chunk)}</div>` : ''}
        </div>`;
        html += '</div>';
      }

      html += '</div>';
      return html;
    }

    async function loadJobs() {
      addDebugLog('Loading jobs...', 'info');
      const container = document.getElementById('jobsContainer');
      container.innerHTML = '<div class="loading">Loading cron jobs...</div>';

      try {
        // Add cache-busting timestamp to ensure fresh data
        const timestamp = new Date().getTime();
        const response = await fetch(`${API_BASE}/api/admin?action=cron_jobs&t=${timestamp}`, {
          headers: buildAuthHeaders(),
          cache: 'no-store'
        });
        
        addDebugLog(`Jobs API response: ${response.status} ${response.statusText}`, 'info');

        if (response.status === 401) {
          clearAuth();
          showMessage('Authentication failed. Please login again.', 'error');
          return;
        }

        // Check if response is JSON and handle parsing errors
        let data;
        try {
          const contentType = response.headers.get('content-type');
          if (!contentType || !contentType.includes('application/json')) {
            const text = await response.text();
            throw new Error(`Server returned non-JSON response (${response.status}): ${text.substring(0, 200)}`);
          }
          data = await response.json();
        } catch (parseError) {
          // If JSON parsing fails, try to get the text response
          const text = await response.text().catch(() => 'Unable to read response');
          throw new Error(`Failed to parse server response (${response.status}): ${text.substring(0, 200)}`);
        }

        if (!data || !data.ok) {
          throw new Error(data?.error || data?.detail || 'Failed to load jobs');
        }

        // Normalize jobs to JobSummary shape
        const rawJobs = data.jobs || [];
        const jobs = rawJobs.map(normalizeJob);
        
        // Debug: Log job 26 details to verify last_run_status is present
        const job26 = jobs.find(j => j.jobid === 26);
        if (job26) {
          addDebugLog(`Job 26 details: last_run=${job26.last_run}, last_run_status=${job26.last_run_status}, failed_count=${job26.failed_count}, success_count=${job26.success_count}`, 'info');
        }
        
        addDebugLog(`Loaded ${jobs.length} jobs from API`, 'success', { jobCount: jobs.length, jobIds: jobs.map(j => j.jobid) });
        
        // Log stats for each job
        jobs.forEach(job => {
          addDebugLog(`Job ${job.jobid} (${job.name}): ${job.total_runs} runs, ${job.success_count} succeeded, ${job.failed_count} failed`, 'info', {
            jobid: job.jobid,
            total_runs: job.total_runs,
            success_count: job.success_count,
            failed_count: job.failed_count,
            last_run: job.last_run
          });
        });
        
        const regressionJobIds = Array.from(new Set(
          jobs
            .filter(job => riskyJobs.includes(job.jobid))
            .map(job => getRegressionSourceJobId(job.jobid))
        ));

        const regressionPromises = regressionJobIds
          .map(jobid => loadRegressionTestData(jobid).then(data => ({ jobid, data })));
        
        const regressionResults = await Promise.all(regressionPromises);
        regressionResults.forEach(({ jobid, data }) => {
          regressionTestData[jobid] = data;
        });

        // Also load fixed baseline info for all risky jobs to show on tiles
        const fixedBaselinePromises = Array.from(new Set(
          jobs
            .filter(job => riskyJobs.includes(job.jobid))
            .map(job => getRegressionSourceJobId(job.jobid))
        )).map(jobid => loadFixedBaselineInfo(jobid).then(info => ({ jobid, info })));
        
        const fixedBaselineResults = await Promise.all(fixedBaselinePromises);
        fixedBaselineResults.forEach(({ jobid, info }) => {
          if (!regressionTestData[jobid]) {
            regressionTestData[jobid] = { has_results: false };
          }
          regressionTestData[jobid].fixed_baseline_info = info;
        });

        // Load database health data + active jobs before rendering
        await loadDatabaseHealth();
        await loadActiveJobs();
        
        // Debug: Log database health data availability
        if (globalDatabaseHealthData) {
          const actualData = globalDatabaseHealthData.db_health_extended || globalDatabaseHealthData;
          const riskScores = actualData.risk_scores || {};
          const totalRisk = riskScores.total_risk || 0;
          addDebugLog(`Database health loaded: Total Risk = ${totalRisk}`, 'info');
        } else {
          addDebugLog('Warning: Database health data not available', 'warning');
        }
        
        await renderJobs(jobs);
        renderActiveJobsBanner();
        // Start polling progress for any active jobs that support progress tracking
        startPollingForActiveJobs();
        addDebugLog('Jobs rendered successfully', 'success');
      } catch (error) {
        addDebugLog(`Error loading jobs: ${error.message}`, 'error', { error: error.message, stack: error.stack });
        container.innerHTML = `<div class="error">Error loading jobs: ${error.message}</div>`;
      }
    }

    /**
     * Render summary dashboard at the top
     * @param {Array<JobSummary>} jobs
     * @returns {string}
     */
    function renderSummaryDashboard(jobs) {
      // Define job groups with icons
      const groups = [
        {
          id: 'db-health',
          name: 'Database Health',
          icon: '💾',
          jobIds: [39, 32],
          color: '#667eea'
        },
        {
          id: 'analytics',
          name: 'Chat Quality Analytics',
          icon: '📊',
          jobIds: [13, 19, 20, 22],
          color: '#f5576c'
        },
        {
          id: 'refresh',
          name: 'Website Pages Refresh',
          icon: '🔄',
          jobIds: [26, 27, 28],
          color: '#00f2fe'
        },
        {
          id: 'maintenance',
          name: 'Data Maintenance & Cleanup',
          icon: '🧹',
          jobIds: [29, 30, 31],
          color: '#f5576c'
        },
        {
          id: 'health',
          name: 'Content Health & Monitoring',
          icon: '🏥',
          jobIds: [33, 34, 35],
          color: '#43e97b'
        },
        {
          id: 'system',
          name: 'System Health & Backup',
          icon: '🛡️',
          jobIds: [36, 37],
          color: '#fa709a'
        }
      ];

      let html = '<div class="summary-dashboard">';
      html += '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">';
      html += '<h2 style="margin: 0;">📊 Dashboard Overview</h2>';
      html += '<button id="resetAllStatsBtn" class="btn btn-danger" onclick="resetAllJobStats()" style="padding: 8px 16px; font-size: 14px; border-radius: 6px; cursor: pointer; background: #dc3545; color: white; border: none;">🗑️ Reset All Stats</button>';
      html += '</div>';
      html += '<div id="activeJobsBanner" class="active-jobs-banner"></div>';
      html += '<div class="summary-groups">';

      // Calculate group health and stats
      groups.forEach(group => {
        const groupJobs = jobs.filter(j => group.jobIds.includes(j.jobid));
        
        if (groupJobs.length === 0) return;

        // Calculate group health (worst health determines group status)
        let groupHealth = 'green'; // ok
        let healthCounts = { ok: 0, warning: 0, error: 0 };
        let totalRuns = 0;
        let totalSuccess = 0;
        let totalFailed = 0;

        groupJobs.forEach(job => {
          const nextRunInMinutes = job.next_run_minutes || calculateNextRunInMinutes(job);
          const health = getJobHealth(job, nextRunInMinutes);
          
          if (health.level === 'error') {
            groupHealth = 'red';
            healthCounts.error++;
          } else if (health.level === 'warning' && groupHealth !== 'red') {
            groupHealth = 'amber';
            healthCounts.warning++;
          } else {
            healthCounts.ok++;
          }

          totalRuns += job.total_runs || 0;
          totalSuccess += job.success_count || 0;
          totalFailed += job.failed_count || 0;
        });

        const successRate = totalRuns > 0 ? ((totalSuccess / totalRuns) * 100).toFixed(1) : 0;

        html += `<div class="summary-group" onclick="scrollToGroup('${group.id}')">`;
        html += '<div class="summary-group-header">';
        html += `<div class="summary-group-title">`;
        html += `<span class="summary-group-icon">${group.icon}</span>`;
        html += `<span>${group.name}</span>`;
        html += `</div>`;
        html += `<div class="summary-group-traffic-light ${groupHealth}"></div>`;
        html += `</div>`;
        
        html += '<div class="summary-group-stats">';
        html += `<div class="summary-group-stat">`;
        html += `<div class="summary-group-stat-label">Jobs</div>`;
        html += `<div class="summary-group-stat-value">${groupJobs.length}</div>`;
        html += `</div>`;
        html += `<div class="summary-group-stat">`;
        html += `<div class="summary-group-stat-label">Success Rate</div>`;
        html += `<div class="summary-group-stat-value">${successRate}%</div>`;
        html += `</div>`;
        html += `<div class="summary-group-stat">`;
        html += `<div class="summary-group-stat-label">Total Runs</div>`;
        html += `<div class="summary-group-stat-value">${totalRuns}</div>`;
        html += `</div>`;
        html += `</div>`;

        html += '<div class="summary-group-jobs">';
        groupJobs.forEach(job => {
          const nextRunInMinutes = job.next_run_minutes || calculateNextRunInMinutes(job);
          const health = getJobHealth(job, nextRunInMinutes);
          const healthClass = health.level === 'error' ? 'red' : health.level === 'warning' ? 'amber' : 'green';
          const displayName = jobDisplayNames[job.jobid] || `Job ${job.jobid}`;
          
          html += `<div class="summary-job-indicator ${healthClass}" title="${health.reason}">`;
          html += `<span class="summary-job-indicator-dot ${healthClass}"></span>`;
          html += `<span>${displayName}</span>`;
          html += `</div>`;
        });
        html += '</div>';

        html += '</div>';
      });

      html += '</div>'; // summary-groups

      // Heat map of all jobs
      html += '<div class="summary-heatmap">';
      html += '<div class="summary-heatmap-title">🔥 Heat Map - All Jobs</div>';
      html += '<div class="summary-heatmap-grid">';
      
      // Sort jobs by ID for consistent display
      const sortedJobs = [...jobs].sort((a, b) => a.jobid - b.jobid);
      
      sortedJobs.forEach(job => {
        const nextRunInMinutes = job.next_run_minutes || calculateNextRunInMinutes(job);
        const health = getJobHealth(job, nextRunInMinutes);
        const healthClass = health.level === 'error' ? 'red' : health.level === 'warning' ? 'amber' : 'green';
        const inactiveClass = job.status !== 'active' ? 'inactive' : '';
        const displayName = jobDisplayNames[job.jobid] || `J${job.jobid}`;
        
        html += `<div class="summary-heatmap-cell ${healthClass} ${inactiveClass}" title="Job ${job.jobid}: ${displayName} - ${health.reason}" onclick="scrollToJob(${job.jobid})">`;
        html += `<span>${job.jobid}</span>`;
        html += `</div>`;
      });

      html += '</div>'; // summary-heatmap-grid
      html += '</div>'; // summary-heatmap
      html += '</div>'; // summary-dashboard

      return html;
    }

    function scrollToGroup(groupId) {
      const groupElement = document.querySelector(`.job-section-header.${groupId}`);
      if (groupElement) {
        groupElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
    }

    function scrollToJob(jobId) {
      const jobCard = document.querySelector(`[data-job-card-id="${jobId}"]`);
      if (jobCard) {
        jobCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
        // Highlight the card briefly
        jobCard.style.boxShadow = '0 0 20px rgba(102, 126, 234, 0.6)';
        setTimeout(() => {
          jobCard.style.boxShadow = '';
        }, 2000);
      }
    }

    async function renderJobs(jobs) {
      const container = document.getElementById('jobsContainer');
      
      if (jobs.length === 0) {
        container.innerHTML = '<div class="loading">No cron jobs found.</div>';
        return;
      }

      // Render summary dashboard first
      let html = renderSummaryDashboard(jobs);

      // Build a set of all linked job IDs
      const linkedJobSet = new Set();
      Object.keys(linkedJobs).forEach(jobId => {
        linkedJobSet.add(parseInt(jobId));
        const links = Array.isArray(linkedJobs[jobId]) ? linkedJobs[jobId] : [linkedJobs[jobId]];
        links.forEach(linkId => linkedJobSet.add(linkId));
      });

      // Define job groups
      const analyticsJobs = [13, 19, 20, 22];
      const refreshBatches = [26, 27, 28];
      const dataMaintenanceJobs = [29, 30, 31];
      const contentHealthJobs = [33, 34, 35];
      const systemHealthJobs = [36, 37];
      const dbHealthMonitorJob = 39;
      const dbMaintenanceJob = 32; // Database maintenance/vacuum job
      
      // Separate jobs into groups
      const analyticsGroup = jobs.filter(j => analyticsJobs.includes(j.jobid)).sort((a, b) => a.jobid - b.jobid);
      const refreshGroup = jobs.filter(j => refreshBatches.includes(j.jobid)).sort((a, b) => a.jobid - b.jobid);
      const dataMaintenanceGroup = jobs.filter(j => dataMaintenanceJobs.includes(j.jobid)).sort((a, b) => a.jobid - b.jobid);
      const contentHealthGroup = jobs.filter(j => contentHealthJobs.includes(j.jobid)).sort((a, b) => a.jobid - b.jobid);
      const systemHealthGroup = jobs.filter(j => systemHealthJobs.includes(j.jobid)).sort((a, b) => a.jobid - b.jobid);
      const otherJobs = jobs.filter(j => 
        !analyticsJobs.includes(j.jobid) && 
        !refreshBatches.includes(j.jobid) &&
        !dataMaintenanceJobs.includes(j.jobid) &&
        !contentHealthJobs.includes(j.jobid) &&
        !systemHealthJobs.includes(j.jobid) &&
        j.jobid !== dbHealthMonitorJob &&
        j.jobid !== dbMaintenanceJob
      ).sort((a, b) => a.jobid - b.jobid);

      // Render Database Health Section with db-health-monitor job and db-maintenance job
      // Use global database health data if available, otherwise load it
      const healthData = globalDatabaseHealthData || await loadDatabaseHealth();
      const dbHealthJob = jobs.find(j => j.jobid === dbHealthMonitorJob);
      const dbMaintenanceJobObj = jobs.find(j => j.jobid === dbMaintenanceJob);
      
      if (healthData || dbHealthJob || dbMaintenanceJobObj) {
        html += '<div class="job-section">';
        // Check if extended data is available (header is rendered inside tile if extended)
        const actualData = healthData?.db_health_extended || healthData;
        if (!actualData?.risk_scores) {
          html += '<div class="job-section-header db-health">💾 Database Health</div>';
        }
        html += '<div class="job-section-content">';
        html += '<div class="jobs-grid" style="grid-template-columns: 2fr 1fr; gap: 20px; align-items: start;">';
        
        // Database Health Tile - spans 2 columns (left side)
        if (healthData) {
          html += '<div>';
          html += renderDatabaseHealthTile(healthData);
          html += '</div>';
        }
        
        // Right column: Job 39 on top, Job 32 underneath
        html += '<div style="display: flex; flex-direction: column; gap: 20px;">';
        
        // db-health-monitor Job Card (top right)
        if (dbHealthJob) {
          html += renderJobCard(dbHealthJob, false, 'db-health');
        }
        
        // db-maintenance Job Card (bottom right, underneath Job 39)
        if (dbMaintenanceJobObj) {
          html += renderJobCard(dbMaintenanceJobObj, false, 'db-health');
        }
        
        html += '</div>'; // End right column
        html += '</div></div></div>'; // End grid and section
      }

      // Render Analytics Jobs Section
      if (analyticsGroup.length > 0) {
        html += '<div class="job-section">';
        html += '<div class="job-section-header analytics">📊 Chat Quality Analytics Jobs</div>';
        html += '<div class="job-section-content">';
        html += '<div class="jobs-grid" style="grid-template-columns: repeat(4, 1fr);">';
        
        analyticsGroup.forEach((job) => {
          html += renderJobCard(job, true, 'analytics');
        });
        
        html += '</div></div></div>';
      }

      // Render Refresh Batches Section
      if (refreshGroup.length > 0) {
        html += '<div class="job-section">';
        html += '<div class="job-section-header refresh">🔄 Website Pages Refresh Batches</div>';
        html += '<div class="job-section-content">';
        html += '<div class="jobs-grid" style="grid-template-columns: repeat(3, 1fr);">';
        
        refreshGroup.forEach((job) => {
          html += renderJobCard(job, true, 'refresh');
        });
        
        html += '</div></div></div>';
      }

      // Render Data Maintenance & Cleanup Section
      if (dataMaintenanceGroup.length > 0) {
        html += '<div class="job-section">';
        html += '<div class="job-section-header maintenance">🧹 Data Maintenance & Cleanup Jobs</div>';
        html += '<div class="job-section-content">';
        html += '<div class="jobs-grid" style="grid-template-columns: repeat(3, 1fr);">';
        
        dataMaintenanceGroup.forEach((job) => {
          html += renderJobCard(job, false, 'maintenance');
        });
        
        html += '</div></div></div>';
      }


      // Render Content Health & Monitoring Section
      if (contentHealthGroup.length > 0) {
        html += '<div class="job-section">';
        html += '<div class="job-section-header health">🏥 Content Health & Monitoring Jobs</div>';
        html += '<div class="job-section-content">';
        html += '<div class="jobs-grid" style="grid-template-columns: repeat(3, 1fr);">';
        
        contentHealthGroup.forEach((job) => {
          html += renderJobCard(job, false, 'health');
        });
        
        html += '</div></div></div>';
      }

      // Render System Health & Backup Section
      if (systemHealthGroup.length > 0) {
        html += '<div class="job-section">';
        html += '<div class="job-section-header system">🛡️ System Health & Backup Jobs</div>';
        html += '<div class="job-section-content">';
        html += '<div class="jobs-grid" style="grid-template-columns: repeat(2, 1fr);">';
        
        systemHealthGroup.forEach((job) => {
          html += renderJobCard(job, false, 'system');
        });
        
        html += '</div></div></div>';
      }

      // Render Other Jobs
      if (otherJobs.length > 0) {
        html += '<div class="jobs-grid">';
        otherJobs.forEach(job => {
          html += renderJobCard(job, false, '');
        });
        html += '</div>';
      }

      container.innerHTML = html;
      
      // Fetch run history and render sparklines for each job
      for (const job of jobs) {
        try {
        const logRes = await fetch(`${API_BASE}/api/admin?action=get_job_logs&jobid=${job.jobid}&_t=${Date.now()}`, {
          headers: buildAuthHeaders(),
          cache: 'no-store'
        });
          const { logs } = await logRes.json();
          
          if (logs && logs.length > 0) {
            // Build recent_runs array for sparkline
            const recentRuns = logs.slice(0, 14).map(log => {
              // Check for success - status can be 'succeeded', 'success', or 'failed'
              const isSuccess = log.status === 'succeeded' || log.status === 'success' || (log.status !== 'failed' && log.status !== 'error');
              return {
                date: log.start_time || log.end_time || new Date().toISOString(),
                success: isSuccess,
                status: log.status,
                return_message: log.return_message || null
              };
            });
            
            // Update job with recent_runs
            job.recent_runs = recentRuns;
            
            // Render sparkline
            renderSparkline(job.jobid, recentRuns);
          }
        } catch (error) {
          console.error(`Error fetching logs for job ${job.jobid}:`, error);
        }
      }
      
      // Setup event handlers for view logs buttons (inline drawer)
      document.querySelectorAll('.view-logs-btn').forEach(btn => {
        btn.addEventListener('click', async function() {
          const jobid = parseInt(this.dataset.jobid);
          await toggleLogDrawer(jobid);
        });
      });
      
      
      // Restore active log drawer if it was open
      if (activeLogJobId !== null) {
        const drawer = document.getElementById(`log-drawer-${activeLogJobId}`);
        const btn = document.querySelector(`.view-logs-btn[data-jobid="${activeLogJobId}"]`);
        if (drawer && btn) {
          drawer.style.display = 'block';
          btn.textContent = 'Hide Logs';
          // Re-render logs if cached
          if (jobLogsCache.has(activeLogJobId)) {
            const cached = jobLogsCache.get(activeLogJobId);
            if (cached.entries) {
              renderLogDrawer(activeLogJobId, cached.entries);
            }
          }
        }
      }
    }
    
    

    // Parse cron schedule to human-readable frequency
    function parseCronFrequency(cron) {
      const parts = cron.trim().split(/\s+/);
      if (parts.length !== 5) return cron;
      
      const [minute, hour, dayOfMonth, month, dayOfWeek] = parts;
      
      // Every minute
      if (minute === '*' && hour === '*' && dayOfMonth === '*' && month === '*' && dayOfWeek === '*') {
        return 'Every minute';
      }
      
      // Every hour at specific minute (e.g., "0 * * * *")
      if (minute !== '*' && hour === '*' && dayOfMonth === '*' && month === '*' && dayOfWeek === '*') {
        if (minute === '0') {
          return 'Every hour';
        }
        return `Every hour (at :${minute.padStart(2, '0')})`;
      }
      
      // Every N hours (e.g., "0 */4 * * *" or "1 */4 * * *")
      if (hour.startsWith('*/') && dayOfMonth === '*' && month === '*' && dayOfWeek === '*') {
        const hours = hour.substring(2);
        const minText = minute !== '0' ? ` at :${minute.padStart(2, '0')}` : '';
        return `Every ${hours} hour${hours !== '1' ? 's' : ''}${minText}`;
      }
      
      // Daily at specific time (e.g., "0 2 * * *")
      if (minute !== '*' && hour !== '*' && dayOfMonth === '*' && month === '*' && dayOfWeek === '*') {
        const h = parseInt(hour);
        const m = minute.padStart(2, '0');
        const ampm = h >= 12 ? 'PM' : 'AM';
        const h12 = h > 12 ? h - 12 : (h === 0 ? 12 : h);
        return `Daily at ${h12}:${m} ${ampm}`;
      }
      
      // Weekly (specific day of week, e.g., "0 2 * * 1")
      if (dayOfWeek !== '*' && dayOfWeek !== '0' && dayOfWeek !== '7' && dayOfMonth === '*' && month === '*') {
        const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
        const day = parseInt(dayOfWeek);
        const dayName = days[day] || dayOfWeek;
        if (hour !== '*' && minute !== '*') {
          const h = parseInt(hour);
          const m = minute.padStart(2, '0');
          const ampm = h >= 12 ? 'PM' : 'AM';
          const h12 = h > 12 ? h - 12 : (h === 0 ? 12 : h);
          return `Every ${dayName} at ${h12}:${m} ${ampm}`;
        }
        return `Every ${dayName}`;
      }
      
      // Monthly
      if (dayOfMonth !== '*' && dayOfMonth !== '0' && month === '*' && dayOfWeek === '*') {
        if (hour !== '*' && minute !== '*') {
          const h = parseInt(hour);
          const m = minute.padStart(2, '0');
          const ampm = h >= 12 ? 'PM' : 'AM';
          const h12 = h > 12 ? h - 12 : (h === 0 ? 12 : h);
          return `Monthly on day ${dayOfMonth} at ${h12}:${m} ${ampm}`;
        }
        return `Monthly on day ${dayOfMonth}`;
      }
      
      // Fallback: return the cron expression
      return cron;
    }

    function formatBytesToMB(bytes = 0) {
      const mb = Number(bytes || 0) / (1024 * 1024);
      return mb.toFixed(1);
    }

    function formatNumber(value = 0) {
      return Number(value || 0).toLocaleString('en-GB');
    }

    function formatDateTime(value) {
      if (!value) return '—';
      const date = new Date(value);
      if (Number.isNaN(date.getTime())) return value;
      return date.toLocaleString();
    }

    // Calculate next scheduled run time from cron expression
    function getNextScheduledTime(cron, jobActive = true, lastRun = null) {
      if (!cron || !jobActive) return null;
      
      try {
        const parts = cron.trim().split(/\s+/);
        if (parts.length !== 5) return null;
        
        const [minute, hour, dayOfMonth, month, dayOfWeek] = parts;
        const now = new Date();
        const nextRun = new Date(now);
        nextRun.setSeconds(0);
        nextRun.setMilliseconds(0);
        
        // Helper to check if a value matches cron pattern
        const matches = (value, pattern) => {
          if (pattern === '*') return true;
          if (pattern.startsWith('*/')) {
            const interval = parseInt(pattern.substring(2));
            return value % interval === 0;
          }
          return parseInt(pattern) === value;
        };
        
        // Every hour at specific minute
        if (minute !== '*' && hour === '*' && dayOfMonth === '*' && month === '*' && dayOfWeek === '*') {
          const targetMinute = parseInt(minute);
          nextRun.setMinutes(targetMinute);
          if (nextRun <= now) {
            nextRun.setHours(nextRun.getHours() + 1);
          }
          return nextRun;
        }
        
        // Every N hours
        if (hour.startsWith('*/') && dayOfMonth === '*' && month === '*' && dayOfWeek === '*') {
          const hours = parseInt(hour.substring(2));
          const targetMinute = minute === '*' ? 0 : parseInt(minute);
          
          // Set to current hour with target minute
          nextRun.setMinutes(targetMinute);
          
          // If the minute has passed this hour, move to next interval
          if (nextRun <= now) {
            const currentHour = now.getHours();
            const currentMinute = now.getMinutes();
            
            // Calculate how many hours until next run
            const hoursSinceLastRun = currentHour % hours;
            let hoursToAdd = hours - hoursSinceLastRun;
            
            // If we're at the exact hour but minute hasn't passed, don't add hours
            if (hoursSinceLastRun === 0 && currentMinute < targetMinute) {
              hoursToAdd = 0;
            }
            
            nextRun.setHours(currentHour + hoursToAdd);
            
            // If we've gone past midnight, adjust
            if (nextRun.getHours() < currentHour) {
              nextRun.setDate(nextRun.getDate() + 1);
            }
          }
          
          return nextRun;
        }
        
        // Daily at specific time
        if (minute !== '*' && hour !== '*' && dayOfMonth === '*' && month === '*' && dayOfWeek === '*') {
          const targetHour = parseInt(hour);
          const targetMinute = parseInt(minute);
          nextRun.setHours(targetHour);
          nextRun.setMinutes(targetMinute);
          
          if (nextRun <= now) {
            nextRun.setDate(nextRun.getDate() + 1);
          }
          return nextRun;
        }
        
        // Weekly (specific day of week)
        if (dayOfWeek !== '*' && dayOfWeek !== '0' && dayOfWeek !== '7' && dayOfMonth === '*' && month === '*') {
          const targetDay = parseInt(dayOfWeek);
          const targetHour = hour === '*' ? 0 : parseInt(hour);
          const targetMinute = minute === '*' ? 0 : parseInt(minute);
          
          const currentDay = now.getDay();
          let daysUntilNext = (targetDay - currentDay + 7) % 7;
          if (daysUntilNext === 0) {
            // Same day - check if time has passed
            nextRun.setHours(targetHour);
            nextRun.setMinutes(targetMinute);
            if (nextRun <= now) {
              daysUntilNext = 7;
            }
          }
          
          nextRun.setDate(now.getDate() + daysUntilNext);
          nextRun.setHours(targetHour);
          nextRun.setMinutes(targetMinute);
          return nextRun;
        }
        
        // For other patterns, try a simple increment approach
        // This is a fallback and may not be 100% accurate for all cron patterns
        return null;
      } catch (e) {
        console.error('Error calculating next scheduled time:', e);
        return null;
      }
    }

    // Format next scheduled time for display
    function formatNextScheduledTime(cron, jobActive, lastRun = null) {
      if (!jobActive) return 'Paused';
      
      const nextRun = getNextScheduledTime(cron, jobActive, lastRun);
      if (!nextRun) return 'Unknown';
      
      const now = new Date();
      const diffMs = nextRun - now;
      const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
      const diffMinutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
      
      // If less than 24 hours away, show relative time
      if (diffMs < 24 * 60 * 60 * 1000) {
        if (diffHours > 0) {
          return `In ${diffHours}h ${diffMinutes}m`;
        } else if (diffMinutes > 0) {
          return `In ${diffMinutes}m`;
        } else {
          return 'Now';
        }
      }
      
      // Otherwise show date and time
      return nextRun.toLocaleString();
    }

    // Risky jobs that have regression testing
    const riskyJobs = [21, 26, 27, 28, 31];
    const regressionTestData = {};

    async function loadRegressionTestData(jobid) {
      if (!riskyJobs.includes(jobid)) return null;
      
      try {
        const response = await fetch(`${API_BASE}/api/admin?action=regression_test_results&jobid=${jobid}`, {
          headers: buildAuthHeaders()
        });
        
        if (response.ok) {
          const data = await response.json();
          if (data.ok && data.has_results) {
            return data;
          }
        }
      } catch (error) {
        console.error(`Error loading regression data for job ${jobid}:`, error);
      }
      return null;
    }

    async function loadFixedBaselineInfo(jobid) {
      if (!riskyJobs.includes(jobid)) return null;
      
      try {
        const response = await fetch(`${API_BASE}/api/admin?action=get_fixed_baseline&jobid=${jobid}`, {
          headers: buildAuthHeaders()
        });
        
        if (response.ok) {
          const data = await response.json();
          if (data.ok && data.has_fixed_baseline) {
            return data.fixed_baseline;
          }
        }
      } catch (error) {
        console.error(`Error loading fixed baseline info for job ${jobid}:`, error);
      }
      return null;
    }

    function renderRegressionTestSummary(regressionData, jobId = null, mirroredFromJobId = null) {
      const isMirrored = mirroredFromJobId && mirroredFromJobId !== jobId;
      const mirrorLabel = isMirrored
        ? `<div class="regression-mirror-note" style="margin-bottom:6px;font-size:11px;color:#7f8c8d;">Mirrors Job ${mirroredFromJobId} regression results</div>`
        : '';

      if (!regressionData || !regressionData.has_results) {
        return `<div class="regression-test-section"><em>No regression test results yet</em>${mirrorLabel}</div>`;
      }

      const { baseline, after, comparison, test_run } = regressionData;
      
      // Calculate stats
      const baselineStats = baseline ? {
        success_rate: baseline.total_questions > 0 
          ? ((baseline.successful_tests / baseline.total_questions) * 100).toFixed(1)
          : 0,
        avg_confidence: (parseFloat(baseline.avg_confidence || 0) * 100).toFixed(1),
        total_questions: baseline.total_questions || 40
      } : null;
      
      const afterStats = after ? {
        success_rate: after.total_questions > 0 
          ? ((after.successful_tests / after.total_questions) * 100).toFixed(1)
          : 0,
        avg_confidence: (parseFloat(after.avg_confidence || 0) * 100).toFixed(1),
        total_questions: after.total_questions || 40
      } : null;
      
      // Show baseline only if no after test yet
      if (baseline && !after) {
        // Check if this is the master baseline (is_fixed_baseline = true, shared across all jobs)
        const isFixed = baseline.is_fixed_baseline === true;
        const fixedBadge = isFixed 
          ? '<span style="background: #28a745; color: white; padding: 2px 6px; border-radius: 4px; font-size: 10px; font-weight: bold; margin-left: 8px;">🔒 MASTER BASELINE</span>'
          : '<span style="background: #ffc107; color: #000; padding: 2px 6px; border-radius: 4px; font-size: 10px; font-weight: bold; margin-left: 8px;">⚠️ NOT FIXED</span>';
        
        const baselineDate = new Date(baseline.test_timestamp);
        const formattedDate = baselineDate.toLocaleDateString('en-GB', { 
          day: '2-digit', 
          month: '2-digit', 
          year: 'numeric' 
        });
        const formattedTime = baselineDate.toLocaleTimeString('en-GB', { 
          hour: '2-digit', 
          minute: '2-digit',
          second: '2-digit',
          hour12: false
        });
        
        return `
          <div class="regression-test-section ${isFixed ? 'no-regression' : ''}" ${isFixed ? 'style="background: #d4edda; border: 2px solid #28a745;"' : ''}>
            ${mirrorLabel}
            <div style="font-weight: bold; margin-bottom: 8px; display: flex; align-items: center; ${isFixed ? 'color: #155724;' : ''}">
              ${isFixed ? '🔒' : '📊'} ${isFixed ? 'Master Fixed Baseline' : 'Baseline Test Complete'} ${fixedBadge}
            </div>
            <div style="margin-bottom: 8px; font-size: 12px; color: ${isFixed ? '#155724' : '#666'}; font-weight: 600;">
              Created: ${formattedDate} at ${formattedTime} (Test ID: #${baseline.id}${baseline.job_id !== jobId ? `, from Job ${baseline.job_id}` : ''})
            </div>
            <div class="regression-summary">
              <div class="regression-stat">
                <div class="regression-stat-label">Baseline Success Rate</div>
                <div class="regression-stat-value">${baselineStats.success_rate}%</div>
              </div>
              <div class="regression-stat">
                <div class="regression-stat-label">Baseline Confidence</div>
                <div class="regression-stat-value">${baselineStats.avg_confidence}%</div>
              </div>
              <div class="regression-stat">
                <div class="regression-stat-label">Total Questions</div>
                <div class="regression-stat-value">${baselineStats.total_questions}</div>
              </div>
              <div class="regression-stat">
                <div class="regression-stat-label">Status</div>
                <div class="regression-stat-value" style="font-size: 12px;">Waiting for job run</div>
              </div>
            </div>
            <div style="margin-top: 8px; font-size: 11px; color: ${isFixed ? '#155724' : '#856404'}; ${isFixed ? 'background: #c3e6cb; padding: 8px; border-radius: 4px; border: 1px solid #28a745;' : ''}">
              ${isFixed 
                ? `🔒 <strong>This is the MASTER FIXED BASELINE</strong> (created ${formattedDate} at ${formattedTime}, Test ID: #${baseline.id}). All jobs use this same baseline for comparisons to prevent regression creep. This baseline will never be automatically deleted.`
                : `⚠️ This baseline is NOT fixed. Set it as the master baseline so ALL jobs use the same reference point. Click "Set as Fixed Baseline" to make this the master baseline for all jobs.`}
            </div>
            <div style="margin-top: 10px;">
              ${isFixed 
                ? `<button class="btn btn-warning btn-small" onclick="unsetFixedBaseline(${baseline.job_id}, ${baseline.id})" title="Unset this as the master baseline">🔓 Unset Master Baseline</button>`
                : `<button class="btn btn-success btn-small" onclick="setFixedBaseline(${baseline.job_id}, ${baseline.id})" title="Set this as the master baseline for ALL jobs">🔒 Set as Master Baseline</button>`}
            </div>
          </div>
        `;
      }
      
      // Show both baseline and latest run results
      if (baseline && after) {
        const severity = comparison ? (comparison.regression_severity || 'none') : 'none';
        const detected = comparison ? (comparison.regression_detected || false) : false;
        const details = comparison ? (comparison.regression_details || {}) : {};
        const comparisonBaselineStats = comparison ? (comparison.baseline_stats || {}) : {};
        const comparisonCurrentStats = comparison ? (comparison.current_stats || {}) : {};
        
        const severityClass = detected ? severity : 'no-regression';
        const severityIcon = detected 
          ? (severity === 'severe' ? '🔴' : severity === 'moderate' ? '🟡' : '🟠')
          : '✅';
        
        // Use passed jobId parameter
        const displayJobId = jobId || (regressionData && regressionData.test_run ? regressionData.test_run.job_id : 
                     (regressionData && regressionData.baseline ? regressionData.baseline.job_id : null));
        const detailsJobId = mirroredFromJobId || displayJobId;
        
        const isFixed = baseline.is_fixed_baseline === true;
        const fixedBadge = isFixed 
          ? '<span style="background: #28a745; color: white; padding: 2px 6px; border-radius: 4px; font-size: 10px; font-weight: bold; margin-left: 8px;">🔒 MASTER BASELINE</span>'
          : '<span style="background: #ffc107; color: #000; padding: 2px 6px; border-radius: 4px; font-size: 10px; font-weight: bold; margin-left: 8px;">⚠️ NOT FIXED</span>';
        
        const baselineDate = new Date(baseline.test_timestamp);
        const formattedDate = baselineDate.toLocaleDateString('en-GB', { 
          day: '2-digit', 
          month: '2-digit', 
          year: 'numeric' 
        });
        const formattedTime = baselineDate.toLocaleTimeString('en-GB', { 
          hour: '2-digit', 
          minute: '2-digit',
          second: '2-digit',
          hour12: false
        });
        
        return `
          <div class="regression-test-section ${severityClass}" ${isFixed ? 'style="background: #d4edda; border: 2px solid #28a745;"' : ''}>
            ${mirrorLabel}
            <div style="font-weight: bold; margin-bottom: 8px; display: flex; align-items: center; ${isFixed ? 'color: #155724;' : ''}">
              ${isFixed ? '🔒' : ''} ${comparison ? `${severityIcon} Regression Test: ${detected ? severity.toUpperCase() + ' REGRESSION DETECTED' : 'No Regression'}` : '📊 Baseline vs Latest Run'} ${fixedBadge}
            </div>
            <div style="margin-bottom: 8px; font-size: 12px; color: ${isFixed ? '#155724' : '#666'}; font-weight: 600;">
              Master Baseline Created: ${formattedDate} at ${formattedTime} (Test ID: #${baseline.id}${baseline.job_id !== jobId ? `, from Job ${baseline.job_id}` : ''})
            </div>
            <div class="regression-summary">
              <div class="regression-stat">
                <div class="regression-stat-label">Baseline Success Rate</div>
                <div class="regression-stat-value">${comparison ? parseFloat(comparisonBaselineStats.success_rate || baselineStats.success_rate || 0).toFixed(1) : baselineStats.success_rate}%</div>
              </div>
              <div class="regression-stat">
                <div class="regression-stat-label">Latest Run Success Rate</div>
                <div class="regression-stat-value">${comparison ? parseFloat(comparisonCurrentStats.success_rate || afterStats.success_rate || 0).toFixed(1) : afterStats.success_rate}%</div>
              </div>
              <div class="regression-stat">
                <div class="regression-stat-label">Baseline Confidence</div>
                <div class="regression-stat-value">${comparison 
                  ? (comparisonBaselineStats.avg_confidence !== undefined 
                      ? (parseFloat(comparisonBaselineStats.avg_confidence) * 100).toFixed(1)
                      : baselineStats.avg_confidence)
                  : baselineStats.avg_confidence}%</div>
              </div>
              <div class="regression-stat">
                <div class="regression-stat-label">Latest Run Confidence</div>
                <div class="regression-stat-value">${comparison 
                  ? (comparisonCurrentStats.avg_confidence !== undefined 
                      ? (parseFloat(comparisonCurrentStats.avg_confidence) * 100).toFixed(1)
                      : afterStats.avg_confidence)
                  : afterStats.avg_confidence}%</div>
              </div>
              ${comparison ? `
              <div class="regression-stat">
                <div class="regression-stat-label">Article Changes</div>
                <div class="regression-stat-value">${details.article_change_count || 0} queries</div>
              </div>
              <div class="regression-stat">
                <div class="regression-stat-label">Severe Changes</div>
                <div class="regression-stat-value">${details.severe_article_changes || 0}</div>
              </div>
              ` : `
              <div class="regression-stat">
                <div class="regression-stat-label">Baseline Questions</div>
                <div class="regression-stat-value">${baselineStats.total_questions}</div>
              </div>
              <div class="regression-stat">
                <div class="regression-stat-label">Latest Run Questions</div>
                <div class="regression-stat-value">${afterStats.total_questions}</div>
              </div>
              `}
            </div>
            ${comparison && detected ? `<div style="margin-top: 8px; font-size: 11px; color: #721c24;"><strong>Action:</strong> ${severity === 'severe' || severity === 'moderate' ? 'ROLLBACK RECOMMENDED' : 'Review recommended'}</div>` : ''}
            ${!comparison ? `<div style="margin-top: 8px; font-size: 11px; color: #155724;">Comparison analysis pending...</div>` : ''}
            <div style="margin-top: 10px; display: flex; gap: 8px; flex-wrap: wrap;">
              ${comparison && detailsJobId ? `<button class="btn btn-primary btn-small" onclick="showRegressionDetails(${detailsJobId})">View Details</button>` : ''}
              ${isFixed 
                ? `<button class="btn btn-warning btn-small" onclick="unsetFixedBaseline(${baseline.job_id}, ${baseline.id})" title="Unset this as the fixed baseline">🔓 Unset Fixed Baseline</button>`
                : `<button class="btn btn-success btn-small" onclick="setFixedBaseline(${baseline.job_id}, ${baseline.id})" title="Set this as the fixed baseline to prevent regression creep">🔒 Set as Fixed Baseline</button>`}
            </div>
            ${isFixed ? `<div style="margin-top: 8px; font-size: 11px; color: #155724; background: #c3e6cb; padding: 8px; border-radius: 4px; border: 1px solid #28a745;">🔒 <strong>Master Fixed Baseline</strong> (created ${formattedDate} at ${formattedTime}, Test ID: #${baseline.id}). ALL jobs use this same baseline for comparisons to prevent regression creep.</div>` : `<div style="margin-top: 8px; font-size: 11px; color: #856404;">⚠️ This baseline is not fixed. Set it as the master baseline so ALL jobs use the same reference point.</div>`}
          </div>
        `;
      }
      
      if (!baseline) {
        // Check if there's a fixed baseline info even if no recent test run
        const fixedBaselineInfo = regressionData?.fixed_baseline_info;
        
        if (fixedBaselineInfo) {
          const fixedBaselineStats = {
            success_rate: fixedBaselineInfo.total_questions > 0 
              ? ((fixedBaselineInfo.successful_tests / fixedBaselineInfo.total_questions) * 100).toFixed(1)
              : 0,
            avg_confidence: (fixedBaselineInfo.avg_confidence * 100).toFixed(1),
            total_questions: fixedBaselineInfo.total_questions || 40,
            test_timestamp: fixedBaselineInfo.test_timestamp
          };
          
          const baselineDate = new Date(fixedBaselineStats.test_timestamp);
          const formattedDate = baselineDate.toLocaleDateString('en-GB', { 
            day: '2-digit', 
            month: '2-digit', 
            year: 'numeric' 
          });
          const formattedTime = baselineDate.toLocaleTimeString('en-GB', { 
            hour: '2-digit', 
            minute: '2-digit',
            second: '2-digit',
            hour12: false
          });
          
          return `<div class="regression-test-section" style="background: #d4edda; border: 2px solid #28a745;">
            ${mirrorLabel}
            <div style="font-weight: bold; margin-bottom: 8px; display: flex; align-items: center; color: #155724;">
              🔒 Master Fixed Baseline
            </div>
            <div style="margin-bottom: 8px; font-size: 12px; color: #155724; font-weight: 600;">
              Created: ${formattedDate} at ${formattedTime}
            </div>
            <div class="regression-summary">
              <div class="regression-stat">
                <div class="regression-stat-label">Baseline Success Rate</div>
                <div class="regression-stat-value">${fixedBaselineStats.success_rate}%</div>
              </div>
              <div class="regression-stat">
                <div class="regression-stat-label">Baseline Confidence</div>
                <div class="regression-stat-value">${fixedBaselineStats.avg_confidence}%</div>
              </div>
              <div class="regression-stat">
                <div class="regression-stat-label">Total Questions</div>
                <div class="regression-stat-value">${fixedBaselineStats.total_questions}</div>
              </div>
              <div class="regression-stat">
                <div class="regression-stat-label">Test ID</div>
                <div class="regression-stat-value" style="font-size: 10px;">#${fixedBaselineInfo.id}</div>
              </div>
            </div>
            <div style="margin-top: 8px; font-size: 11px; color: #155724; background: #c3e6cb; padding: 8px; border-radius: 4px; border: 1px solid #28a745;">
              🔒 <strong>This is the MASTER FIXED BASELINE.</strong> All future regression tests will compare against this baseline (created ${formattedDate} at ${formattedTime}) to prevent regression creep. This baseline will never be automatically deleted.
            </div>
            <div style="margin-top: 8px; font-size: 11px; color: #856404;">
              <strong>Status:</strong> Waiting for next job run to compare against this baseline.
            </div>
          </div>`;
        }
        
        return `<div class="regression-test-section">
          <em>No baseline test found for job ${jobId}.</em>
          <div style="margin-top: 8px; font-size: 11px; color: #856404;">
            <strong>To create a baseline:</strong> The baseline test is automatically created the first time this job runs with regression testing enabled. 
            If no baseline exists, it means the job hasn't been run with regression testing yet, or the baseline test wasn't created properly.
            <br><br>
            <strong>Note:</strong> The wrapper function <code>refresh_v_products_unified_with_regression_test()</code> should create a baseline test automatically on the first run.
            <br><br>
            <strong>After creating a baseline:</strong> You can set it as the "Fixed Baseline" (master baseline) using the button that will appear. The fixed baseline will always be used for comparisons and will never be automatically deleted.
          </div>
        </div>`;
      }
      
      return '<div class="regression-test-section"><em>Regression test in progress...</em></div>';
    }

    async function showRegressionDetails(jobId) {
      const modal = document.getElementById('regressionDetailsModal');
      const modalContent = document.getElementById('regressionDetailsContent');
      
      if (!modal || !modalContent) return;
      
      // Load fresh comparison data
      try {
        const response = await fetch(`${API_BASE}/api/admin?action=regression_test_results&jobid=${jobId}`, {
          headers: buildAuthHeaders()
        });
        
        if (!response.ok) {
          modalContent.innerHTML = '<p>Error loading regression details.</p>';
          modal.style.display = 'block';
          return;
        }
        
        const data = await response.json();
        if (!data.ok || !data.has_results || !data.comparison) {
          modalContent.innerHTML = '<p>No comparison data available.</p>';
          modal.style.display = 'block';
          return;
        }
        
        const comparison = data.comparison;
        const articleChanges = comparison.article_changes || [];
        const answerQualityChanges = comparison.answer_quality_changes || [];
        const queryRegressions = comparison.query_regressions || [];
        const details = comparison.regression_details || {};
        
        let html = `
          <h2>Regression Test Details - Job ${jobId}</h2>
          <div class="details-section">
            <h3>Overall Summary</h3>
            <p><strong>Regression Detected:</strong> ${comparison.regression_detected ? 'Yes' : 'No'}</p>
            <p><strong>Severity:</strong> ${comparison.regression_severity || 'none'}</p>
            <p><strong>Success Rate Change:</strong> ${parseFloat(details.success_rate_diff || 0).toFixed(2)}%</p>
            <p><strong>Confidence Change:</strong> ${parseFloat(details.confidence_diff || 0).toFixed(3)}</p>
            <p><strong>Total Article Changes:</strong> ${details.article_change_count || 0} queries</p>
            <p><strong>Severe Article Changes:</strong> ${details.severe_article_changes || 0}</p>
            <p><strong>Answer Quality Degradations:</strong> ${details.answer_quality_degradations || 0}</p>
          </div>
        `;
        
        if (queryRegressions.length > 0) {
          html += `
            <div class="details-section">
              <h3>Query-Specific Regressions (${queryRegressions.length})</h3>
          `;
          
          queryRegressions.forEach(qr => {
            const severity = qr.severity || 'minor';
            html += `
              <div class="query-change ${severity}">
                <strong>Query:</strong> ${qr.query || 'Unknown'}<br>
                <strong>Severity:</strong> ${severity}<br>
                <strong>Article Changes:</strong> ${qr.article_changes || 0}<br>
                <strong>Answer Degradation:</strong> ${qr.answer_degradation ? 'Yes' : 'No'}
              </div>
            `;
          });
          
          html += `</div>`;
        }
        
        if (articleChanges.length > 0) {
          html += `
            <div class="details-section">
              <h3>Article Changes by Query (${articleChanges.length})</h3>
          `;
          
          articleChanges.forEach(ac => {
            const removed = ac.removed_articles || [];
            const added = ac.added_articles || [];
            
            html += `
              <div class="query-change">
                <strong>Query:</strong> ${ac.query || 'Unknown'}<br>
                <strong>Baseline Articles:</strong> ${ac.baseline_article_count || 0}<br>
                <strong>Current Articles:</strong> ${ac.current_article_count || 0}<br>
            `;
            
            if (removed.length > 0) {
              html += `<div class="article-list"><strong>Removed Articles (${ac.removed_count || 0}):</strong><ul>`;
              removed.forEach(article => {
                html += `<li class="article-removed">${article.title || article.id || 'Unknown'} (ID: ${article.id || 'N/A'})</li>`;
              });
              html += `</ul></div>`;
            }
            
            if (added.length > 0) {
              html += `<div class="article-list"><strong>Added Articles (${ac.added_count || 0}):</strong><ul>`;
              added.forEach(article => {
                html += `<li class="article-added">${article.title || article.id || 'Unknown'} (ID: ${article.id || 'N/A'})</li>`;
              });
              html += `</ul></div>`;
            }
            
            html += `</div>`;
          });
          
          html += `</div>`;
        }
        
        if (answerQualityChanges.length > 0) {
          html += `
            <div class="details-section">
              <h3>Answer Quality Changes (${answerQualityChanges.length})</h3>
          `;
          
          answerQualityChanges.forEach(aq => {
            html += `
              <div class="query-change">
                <strong>Query:</strong> ${aq.query || 'Unknown'}<br>
                <strong>Baseline Answer Length:</strong> ${aq.baseline_answer_length || 0} chars<br>
                <strong>Current Answer Length:</strong> ${aq.current_answer_length || 0} chars<br>
                <strong>Length Difference:</strong> ${aq.answer_length_diff || 0} chars<br>
                <strong>Baseline Confidence:</strong> ${parseFloat(aq.baseline_confidence || 0).toFixed(3)}<br>
                <strong>Current Confidence:</strong> ${parseFloat(aq.current_confidence || 0).toFixed(3)}<br>
                <strong>Confidence Difference:</strong> ${parseFloat(aq.confidence_diff || 0).toFixed(3)}
              </div>
            `;
          });
          
          html += `</div>`;
        }
        
        modalContent.innerHTML = html;
        modal.style.display = 'block';
      } catch (error) {
        modalContent.innerHTML = `<p>Error loading details: ${error.message}</p>`;
        modal.style.display = 'block';
      }
    }

    function closeRegressionDetails() {
      const modal = document.getElementById('regressionDetailsModal');
      if (modal) {
        modal.style.display = 'none';
      }
    }

    // Set Fixed Baseline
    async function setFixedBaseline(jobId, testResultId) {
      if (!confirm(`Set this baseline as the FIXED baseline for Job ${jobId}?\n\nThis will:\n- Unset any existing fixed baseline for this job\n- Make this baseline the permanent reference point\n- Prevent regression creep by always comparing against this baseline\n\nOnly do this when the system is in a verified good state.`)) {
        return;
      }

      try {
        const response = await fetch(`${API_BASE}/api/admin?action=set_fixed_baseline`, {
          method: 'POST',
          headers: buildAuthHeaders(),
          body: JSON.stringify({
            job_id: jobId,
            test_result_id: testResultId
          })
        });

        const data = await response.json();
        
        if (!response.ok || !data.ok) {
          throw new Error(data.error || 'Failed to set fixed baseline');
        }

        showMessage(`✅ Fixed baseline set successfully for Job ${jobId}`, 'success');
        
        // Reload jobs to refresh the display
        setTimeout(() => {
          loadJobs();
        }, 500);
      } catch (error) {
        showMessage(`❌ Failed to set fixed baseline: ${error.message}`, 'error');
        console.error('Error setting fixed baseline:', error);
      }
    }

    // Unset Fixed Baseline
    async function unsetFixedBaseline(jobId, testResultId) {
      if (!confirm(`Unset the fixed baseline for Job ${jobId}?\n\nThis will remove the fixed baseline marker. Future comparisons will use the latest baseline, which may allow regression creep.`)) {
        return;
      }

      try {
        const response = await fetch(`${API_BASE}/api/admin?action=unset_fixed_baseline`, {
          method: 'POST',
          headers: buildAuthHeaders(),
          body: JSON.stringify({
            job_id: jobId
          })
        });

        const data = await response.json();
        
        if (!response.ok || !data.ok) {
          throw new Error(data.error || 'Failed to unset fixed baseline');
        }

        showMessage(`✅ Fixed baseline unset for Job ${jobId}`, 'success');
        
        // Reload jobs to refresh the display
        setTimeout(() => {
          loadJobs();
        }, 500);
      } catch (error) {
        showMessage(`❌ Failed to unset fixed baseline: ${error.message}`, 'error');
        console.error('Error unsetting fixed baseline:', error);
      }
    }

    async function runJobNow(jobId, jobName) {
      addDebugLog(`Run job now requested: ${jobName} (ID: ${jobId})`, 'info', { jobId, jobName });
      const jobIdInt = parseInt(jobId);
      
      // Reset progress and show queued state for all jobs (all jobs now have progress containers)
      const resetTargets = new Set([jobIdInt]);
      if (jobIdInt === 26 && Array.isArray(linkedJobs[26])) {
        linkedJobs[26].forEach(id => resetTargets.add(id));
      }
      for (const targetId of resetTargets) {
        try {
          await fetch(`${API_BASE}/api/admin?action=reset_job_progress&jobid=${targetId}`, {
            method: 'GET',
            headers: buildAuthHeaders()
          });
        } catch (err) {
          console.warn(`Failed to reset progress for job ${targetId}:`, err);
        }
        const container = getProgressContainer(targetId);
        if (container) {
          showProgressContainer(targetId, targetId === jobIdInt ? 'Queued...' : 'Auto-chained batch queued...');
        }
      }
      
      const modal = document.getElementById('jobExecutionModal');
      const modalContent = document.getElementById('jobExecutionContent');
      
      if (!modal || !modalContent) {
        addDebugLog('Modal elements not found', 'error');
        return;
      }
      
      // Show loading state
      modalContent.innerHTML = `
        <h2>Running Job: ${jobName} (ID: ${jobId})</h2>
        <div style="text-align: center; padding: 40px;">
          <div style="font-size: 18px; margin-bottom: 20px;">⏳ Executing job...</div>
          <div style="color: #7f8c8d;">This may take a few moments</div>
        </div>
      `;
      modal.style.display = 'block';
      
      try {
        addDebugLog(`Sending run job request for job ${jobId}`, 'info');
        const response = await fetch(`${API_BASE}/api/admin?action=run_cron_job`, {
          method: 'POST',
          headers: buildAuthHeaders(),
          body: JSON.stringify({ jobid: jobId })
        });
        
        addDebugLog(`Run job API response: ${response.status} ${response.statusText}`, 'info');
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        addDebugLog('Run job API response data received', 'info', data);
        
        if (!data.ok) {
          throw new Error(data.error || 'Job execution failed');
        }
        
        const { job, execution, regression_test } = data;
        
        // Store execution result for copying
        lastExecutionResult = execution.result || execution;
        
        addDebugLog(`Job execution completed: success=${execution.success}, duration=${execution.duration}s`, 
          execution.success ? 'success' : 'error', { execution });
        
        // Start progress tracking for all jobs after successful execution
        if (execution.success) {
          // For very quick jobs (< 2 seconds), show completion status immediately
          if (execution.duration && execution.duration < 2) {
            const container = getProgressContainer(jobIdInt);
            if (container) {
              showProgressContainer(jobIdInt, `Completed in ${execution.duration.toFixed(2)}s`);
              const bar = container.querySelector('.progress-bar');
              if (bar) bar.style.width = '100%';
              // Hide after 3 seconds
              setTimeout(() => {
                container.style.display = 'none';
              }, 3000);
            }
          } else {
            // For longer jobs, start polling
            const pollTargets = new Set([jobIdInt]);
            if (jobIdInt === 26 && Array.isArray(linkedJobs[26])) {
              linkedJobs[26].forEach(id => pollTargets.add(id));
            }
            let index = 0;
            pollTargets.forEach(targetId => {
              addDebugLog(`Starting progress polling for job ${targetId}`, 'info');
              setTimeout(() => {
                addDebugLog(`Polling progress for job ${targetId}`, 'info');
                pollJobProgress(targetId);
              }, 500 + (index * 250));
              index += 1;
            });
          }
        }
        loadActiveJobs().then(() => {
          renderActiveJobsBanner();
          startPollingForActiveJobs();
        });
        
        const isRiskyJob = [21, 26, 27, 28, 31].includes(jobIdInt);
        
        // Override command display for jobs 26, 27, 28 to show wrapper function
        const displayCommand = (
          jobIdInt === 26 ? "SELECT trigger_refresh_master_job();" :
          jobIdInt === 27 ? "SELECT trigger_refresh_batch1_job();" :
          jobIdInt === 28 ? "SELECT trigger_refresh_batch2_job();" :
          job.command
        );
        
        let html = `
          <h2>Job Execution Results: ${job.name || jobName} (ID: ${job.id || jobId})</h2>
          <div class="details-section">
            <h3>Execution Summary</h3>
            <p><strong>Status:</strong> <span style="color: ${execution.success ? '#27ae60' : '#e74c3c'}; font-weight: bold;">
              ${execution.success ? '✅ Success' : '❌ Failed'}
            </span></p>
            <p><strong>Duration:</strong> ${execution.duration ? execution.duration.toFixed(2) : 'N/A'} seconds</p>
            <p><strong>Start Time:</strong> ${new Date(execution.start_time).toLocaleString()}</p>
            <p><strong>End Time:</strong> ${new Date(execution.end_time).toLocaleString()}</p>
        `;
        
        if (execution.error) {
          html += `<p><strong>Error:</strong> <span style="color: #e74c3c;">${execution.error}</span></p>`;
        }
        
        if (execution.result) {
          if (typeof execution.result === 'string') {
            html += `<p><strong>Result:</strong> ${execution.result}</p>`;
          } else if (Array.isArray(execution.result) && execution.result.length > 0) {
            html += `<h4>Results:</h4><pre style="background: #f4f4f4; padding: 10px; border-radius: 4px; overflow-x: auto; max-height: 300px; overflow-y: auto;">${JSON.stringify(execution.result, null, 2)}</pre>`;
          } else if (typeof execution.result === 'object') {
            html += `<h4>Results:</h4><pre style="background: #f4f4f4; padding: 10px; border-radius: 4px; overflow-x: auto; max-height: 300px; overflow-y: auto;">${JSON.stringify(execution.result, null, 2)}</pre>`;
          }
        }
        
        if (execution.records_affected) {
          html += `<h4>Records Affected:</h4>`;
          if (typeof execution.records_affected === 'object') {
            Object.entries(execution.records_affected).forEach(([key, value]) => {
              html += `<p><strong>${key}:</strong> ${value}</p>`;
            });
          } else {
            html += `<p>${execution.records_affected}</p>`;
          }
        }
        
        html += `</div>`;
        
        // Show regression test results for risky jobs
        if (isRiskyJob && regression_test && regression_test.test_run) {
          const testRun = regression_test.test_run;
          const comparison = regression_test.comparison;
          
          html += `
            <div class="details-section">
              <h3>Regression Test Results</h3>
              <p><strong>Test Run Status:</strong> ${testRun.status || 'Unknown'}</p>
              <p><strong>Baseline Test ID:</strong> ${testRun.baseline_test_id || 'N/A'}</p>
              <p><strong>After Test ID:</strong> ${testRun.after_test_id || 'N/A'}</p>
          `;
          
          if (comparison) {
            const detected = comparison.regression_detected || false;
            const severity = comparison.regression_severity || 'none';
            const details = comparison.regression_details || {};
            
            html += `
              <p><strong>Regression Detected:</strong> <span style="color: ${detected ? '#e74c3c' : '#27ae60'};">
                ${detected ? 'Yes' : 'No'}
              </span></p>
              <p><strong>Severity:</strong> ${severity}</p>
              <p><strong>Success Rate Change:</strong> ${parseFloat(details.success_rate_diff || 0).toFixed(2)}%</p>
              <p><strong>Confidence Change:</strong> ${parseFloat(details.confidence_diff || 0).toFixed(3)}</p>
              <p><strong>Article Changes:</strong> ${details.article_change_count || 0} queries</p>
              <p><strong>Severe Changes:</strong> ${details.severe_article_changes || 0}</p>
            `;
            
            if (detected) {
              html += `<p style="color: #e74c3c; font-weight: bold; margin-top: 10px;">
                ${severity === 'severe' || severity === 'moderate' ? '⚠️ ROLLBACK RECOMMENDED' : 'Review recommended'}
              </p>`;
            }
          } else {
            html += `<p>Comparison analysis pending or not available.</p>`;
          }
          
          html += `</div>`;
        }
        
        // Show command executed
        html += `
          <div class="details-section">
            <h3>Command Executed</h3>
            <pre style="background: #f4f4f4; padding: 10px; border-radius: 4px; overflow-x: auto;">${displayCommand || job.command || 'N/A'}</pre>
          </div>
          <div style="margin-top: 15px; text-align: right;">
            <button class="btn btn-secondary" onclick="copyExecutionResults(${jobId})" style="margin-right: 10px;">📋 Copy Results</button>
            <button class="btn btn-primary" onclick="closeJobExecutionModal()">Close</button>
          </div>
        `;
        
        modalContent.innerHTML = html;
        
        // Refresh jobs list to update stats after a short delay to ensure DB insert completes
        addDebugLog('Refreshing jobs after execution to update stats...', 'info');
        setTimeout(() => {
          loadJobs();
        }, 1000);
        
      } catch (error) {
        addDebugLog(`Error running job: ${error.message}`, 'error', { error: error.message, stack: error.stack });
        modalContent.innerHTML = `
          <h2>Error Running Job: ${jobName}</h2>
          <div class="details-section">
            <p style="color: #e74c3c;"><strong>Error:</strong> ${error.message}</p>
            <p>Please check the job configuration and try again.</p>
          </div>
        `;
      }
    }

    function closeJobExecutionModal() {
      const modal = document.getElementById('jobExecutionModal');
      if (modal) {
        modal.style.display = 'none';
      }
    }

    // Store last execution result for copying
    let lastExecutionResult = null;

    function copyExecutionResults(jobId) {
      if (!lastExecutionResult) {
        showMessage('No execution results to copy', 'error');
        return;
      }

      const resultText = JSON.stringify(lastExecutionResult, null, 2);
      
      navigator.clipboard.writeText(resultText).then(() => {
        showMessage('Execution results copied to clipboard!', 'success');
      }).catch(err => {
        console.error('Failed to copy:', err);
        showMessage('Failed to copy results: ' + err.message, 'error');
      });
    }

    /**
     * Map a human-readable schedule description to an approximate interval in minutes.
     * Must match the backend getIntervalMinutesFromSchedule function exactly.
     */
    function getIntervalMinutesFromSchedule(scheduleText) {
      if (!scheduleText || typeof scheduleText !== 'string') return 60;
      const s = scheduleText.trim();

      if (/^Every hour$/i.test(s)) return 60;

      const everyHoursMatch = s.match(/^Every\s+(\d+)\s+hours?/i);
      if (everyHoursMatch) {
        const n = parseInt(everyHoursMatch[1], 10);
        if (Number.isFinite(n) && n > 0) return n * 60;
      }

      if (/^Every\s+(Mon|Tue|Wed|Thu|Fri|Sat|Sun)\s+at\s+/i.test(s)) {
        return 7 * 24 * 60;
      }

      if (/^Every\s+day\s+at\s+/i.test(s) || /^Daily\s+at\s+/i.test(s)) {
        return 24 * 60;
      }

      return 60;
    }

    /**
     * Format next run label from total minutes
     * @param {number} totalMinutes
     * @returns {string}
     */
    function formatNextRunLabel(totalMinutes) {
      if (totalMinutes <= 0) return 'Due now';

      const days = Math.floor(totalMinutes / (60 * 24));
      const hours = Math.floor((totalMinutes % (60 * 24)) / 60);
      const mins = totalMinutes % 60;

      const parts = [];
      if (days) parts.push(`${days}d`);
      if (hours) parts.push(`${hours}h`);
      if (mins || parts.length === 0) parts.push(`${mins}m`);

      return `Next run in ${parts.join(' ')}`;
    }

    /**
     * Calculate next run in minutes from schedule
     * @param {JobSummary} job
     * @param {Date} now
     * @returns {number} Minutes until next run, or 0 if due now
     */
    function calculateNextRunInMinutes(job, now = new Date()) {
      const lastRun = job.last_run ? new Date(job.last_run) : null;

      // Get schedule text (human-readable description)
      const scheduleText = job.schedule_description || job.schedule_label || parseCronFrequency(job.schedule) || '';
      const freqMinutes = getIntervalMinutesFromSchedule(scheduleText);

      if (!lastRun || isNaN(lastRun.getTime())) {
        // If never run before, just say it's due now
        return 0;
      }

      const intervalMs = freqMinutes * 60 * 1000;
      const nextRunTime = new Date(lastRun.getTime() + intervalMs);
      const diffMs = nextRunTime.getTime() - now.getTime();

      const diffMinutes = Math.max(0, Math.round(diffMs / (60 * 1000)));
      return diffMinutes;
    }

    /**
     * Get job health status
     * @param {JobSummary} job
     * @param {number|null} nextRunInMinutes
     * @returns {{ level: 'ok'|'warning'|'error', label: string, reason: string }}
     */
    function getJobHealth(job, nextRunInMinutes) {
      const now = new Date();
      const lastRun = job.last_run ? new Date(job.last_run) : null;
      const minutesSinceLastRun = lastRun ? Math.floor((now - lastRun) / (1000 * 60)) : null;
      const scheduleText = job.schedule_description || job.schedule_label || parseCronFrequency(job.schedule) || '';
      const freqMinutes = getIntervalMinutesFromSchedule(scheduleText);

      // Special handling for Job 39 (db-health-monitor): 
      // Job health should be based on job performance, not database health risk
      // Database health risk is what the job monitors - it's not a reflection of the job's health
      // Only check database health risk as additional context, not as the primary health indicator
      if (job.jobid === 39) {
        // First check job's actual performance
        const hasRuns = job.total_runs > 0;
        const noFailures = job.failed_count === 0;
        const notOverdue = nextRunInMinutes === null || nextRunInMinutes <= 1.5 * freqMinutes;
        
        if (hasRuns && noFailures && notOverdue) {
          // Job is performing well - include database health as context
          if (globalDatabaseHealthData) {
            const actualData = globalDatabaseHealthData.db_health_extended || globalDatabaseHealthData;
            const riskScores = actualData.risk_scores || {};
            const totalRisk = riskScores.total_risk || 0;
            return { level: 'ok', label: 'OK', reason: 'Job running successfully. Monitoring database health (Risk: ' + totalRisk + ')' };
          }
          return { level: 'ok', label: 'OK', reason: 'All runs successful, on schedule' };
        }
        // If job has issues, fall through to standard health checks below
      }

      // Error conditions - check these FIRST before warnings
      if (job.failed_count > 0 && job.success_count === 0) {
        return { level: 'error', label: 'Error', reason: 'Always fails - no successful runs' };
      }
      // Show error if the most recent run failed (check last_run_status if available)
      // This catches cases where a recent cron job failure occurred, even if there are previous successes
      // This MUST be checked before the generic "failed_count > 0" warning below
      if (job.last_run_status && (job.last_run_status.toLowerCase() === 'failed' || job.last_run_status.toLowerCase() === 'error')) {
        const lastRunDate = new Date(job.last_run);
        const minutesSinceLastRun = Math.floor((now - lastRunDate) / (1000 * 60));
        const hoursSinceLastRun = Math.floor(minutesSinceLastRun / 60);
        const daysSinceLastRun = Math.floor(hoursSinceLastRun / 24);
        
        // Format date/time for last run
        const lastRunFormatted = lastRunDate.toLocaleString('en-GB', { 
          day: '2-digit', 
          month: '2-digit', 
          year: 'numeric', 
          hour: '2-digit', 
          minute: '2-digit',
          hour12: false
        });
        
        // Extract error message (first line, truncated if too long)
        let errorDetail = '';
        if (job.last_run_error_message) {
          const errorLines = job.last_run_error_message.split('\n');
          const firstLine = errorLines[0] || '';
          // Clean up common error prefixes
          let cleaned = firstLine.replace(/^ERROR:\s*/i, '').replace(/^CONTEXT:.*$/i, '').trim();
          errorDetail = cleaned.length > 120 ? cleaned.substring(0, 120) + '...' : cleaned;
        }
        
        // Build detailed error message
        let reason = `Last run failed on ${lastRunFormatted} (${minutesSinceLastRun} min ago)`;
        if (errorDetail) {
          reason += `: ${errorDetail}`;
        }
        reason += ` - ${job.failed_count} total failures, ${job.success_count} successes`;
        
        return { level: 'error', label: 'Error', reason: reason };
      }
      if (nextRunInMinutes === 0 && lastRun && minutesSinceLastRun > freqMinutes * 3) {
        return { level: 'error', label: 'Error', reason: 'Severely overdue - last run was ' + Math.floor(minutesSinceLastRun / freqMinutes) + 'x scheduled interval ago' };
      }

      // Warning conditions
      if (job.total_runs === 0 && job.status === 'active') {
        return { level: 'warning', label: 'Warning', reason: 'Never run - job is active but has no execution history' };
      }
      // Show warning if there are ANY failures (but only if last run didn't fail - that's already handled above)
      // This ensures old failures are still visible, but recent failures show as errors
      if (job.failed_count > 0 && (!job.last_run_status || (job.last_run_status.toLowerCase() !== 'failed' && job.last_run_status.toLowerCase() !== 'error'))) {
        const failureRate = job.total_runs > 0 ? ((job.failed_count / job.total_runs) * 100).toFixed(1) : 0;
        return { level: 'warning', label: 'Warning', reason: 'Some failures detected - ' + job.failed_count + ' failed, ' + job.success_count + ' succeeded (' + failureRate + '% failure rate)' };
      }
      if (nextRunInMinutes === 0 && lastRun && minutesSinceLastRun > freqMinutes * 2) {
        return { level: 'warning', label: 'Warning', reason: 'Possibly stuck - overdue by ' + Math.floor(minutesSinceLastRun / freqMinutes) + 'x scheduled interval' };
      }

      // OK conditions (all must be true)
      const hasRuns = job.total_runs > 0;
      const noFailures = job.failed_count === 0;
      const notOverdue = nextRunInMinutes === null || nextRunInMinutes <= 1.5 * freqMinutes;

      if (hasRuns && noFailures && notOverdue) {
        // For Job 39, if database health is good, include that in the reason
        if (job.jobid === 39 && globalDatabaseHealthData) {
          const actualData = globalDatabaseHealthData.db_health_extended || globalDatabaseHealthData;
          const riskScores = actualData.risk_scores || {};
          const totalRisk = riskScores.total_risk || 0;
          return { level: 'ok', label: 'OK', reason: 'All runs successful, on schedule. Database health: ' + totalRisk + ' (Healthy)' };
        }
        return { level: 'ok', label: 'OK', reason: 'All runs successful, on schedule' };
      }

      // Default to warning if conditions not met
      return { level: 'warning', label: 'Warning', reason: 'Check job status' };
    }

    /**
     * Render sparkline chart for job runs (SVG-based for tooltips)
     * @param {string|number} jobId
     * @param {Array<{ date: string, success: boolean }>} runHistory
     */
    function renderSparkline(jobId, runHistory) {
      const container = document.getElementById(`sparkline-${jobId}`);
      if (!container) return;
      
      container.innerHTML = '';
      
      const width = 150;
      const height = 50;
      const barWidth = 6;
      const gap = 2;
      
      const lastRuns = (runHistory || []).slice(-14);
      if (lastRuns.length === 0) return;
      
      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('width', width);
      svg.setAttribute('height', height);
      svg.style.display = 'block';
      
      // Store runHistory in container for tooltip access
      container._runHistory = lastRuns;
      
      lastRuns.forEach((run, index) => {
        // Check for success - explicitly check for failed/error status
        const isSuccess = run.success === true || 
                         (run.success !== false && run.status && 
                          run.status !== 'failed' && run.status !== 'error' && 
                          (run.status === 'succeeded' || run.status === 'success'));
        const barHeight = isSuccess ? 35 : 12;
        const color = isSuccess ? '#5cb85c' : '#d9534f';
        
        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        rect.setAttribute('x', index * (barWidth + gap));
        rect.setAttribute('y', height - barHeight);
        rect.setAttribute('width', barWidth);
        rect.setAttribute('height', barHeight);
        rect.setAttribute('fill', color);
        rect.setAttribute('data-index', index);
        rect.setAttribute('data-success', isSuccess);
        
        svg.appendChild(rect);
      });
      
      container.appendChild(svg);
      
      // Add tooltips after rendering
      addSparklineTooltips(jobId);
    }

    /**
     * Add tooltips on sparkline bar hover
     * @param {string|number} jobId
     */
    function addSparklineTooltips(jobId) {
      const container = document.getElementById(`sparkline-${jobId}`);
      if (!container) return;

      const svg = container.querySelector('svg');
      if (!svg) return;

      const bars = svg.querySelectorAll('rect');

      const lastRuns = container._runHistory || [];
      
      bars.forEach((bar, idx) => {
        const success = bar.getAttribute('fill') === '#5cb85c';
        const runData = lastRuns[idx];
        const runDate = runData?.date ? new Date(runData.date).toLocaleString('en-GB', { 
          day: '2-digit', 
          month: '2-digit', 
          year: 'numeric', 
          hour: '2-digit', 
          minute: '2-digit',
          hour12: false
        }) : 'Unknown date';
        
        let tooltipText = success
          ? `Run #${idx + 1}: Success (${runDate})`
          : `Run #${idx + 1}: Failed (${runDate})`;
        
        // Add error detail if available
        if (!success && runData?.return_message) {
          const errorMsg = runData.return_message.split('\n')[0].substring(0, 80);
          tooltipText += ` - ${errorMsg}${errorMsg.length >= 80 ? '...' : ''}`;
        }

        bar.style.cursor = 'pointer';
        
        bar.addEventListener('mouseenter', (e) => {
          const tooltip = document.createElement('div');
          tooltip.id = `sparkline-tooltip-${jobId}-${idx}`;
          tooltip.textContent = tooltipText;
          tooltip.style.position = 'absolute';
          tooltip.style.background = 'rgba(0,0,0,0.75)';
          tooltip.style.padding = '4px 6px';
          tooltip.style.color = 'white';
          tooltip.style.fontSize = '11px';
          tooltip.style.borderRadius = '4px';
          tooltip.style.pointerEvents = 'none';
          tooltip.style.zIndex = '1000';
          tooltip.style.whiteSpace = 'nowrap';
          
          // Position tooltip near the bar
          const rect = bar.getBoundingClientRect();
          const containerRect = container.getBoundingClientRect();
          tooltip.style.left = (rect.left - containerRect.left + rect.width / 2) + 'px';
          tooltip.style.top = (rect.top - containerRect.top - 25) + 'px';
          tooltip.style.transform = 'translateX(-50%)';
          
          container.appendChild(tooltip);
        });

        bar.addEventListener('mouseleave', () => {
          const tooltip = document.getElementById(`sparkline-tooltip-${jobId}-${idx}`);
          if (tooltip) tooltip.remove();
        });
      });
    }

    function renderDatabaseMaintenanceSummary(job) {
      if (job.jobid !== 32 || !job.maintenanceSummary) return '';
      const s = job.maintenanceSummary;
      const deadRemoved = Math.max((s.deadBefore || 0) - (s.deadAfter || 0), 0);
      const bloatBeforeMB = formatBytesToMB(s.bloatBeforeBytes || 0);
      const bloatAfterMB = formatBytesToMB(s.bloatAfterBytes || 0);
      const diskFreedMB = formatBytesToMB(s.diskFreedBytes || 0);

      return `
        <div class="db-maint-summary">
          <div class="db-maint-summary-grid">
            <div class="db-maint-summary-item">
              <div class="label">Dead tuples removed (last run)</div>
              <div class="value">${formatNumber(deadRemoved)}</div>
            </div>
            <div class="db-maint-summary-item">
              <div class="label">Estimated bloat before → after</div>
              <div class="value">${bloatBeforeMB} MB → ${bloatAfterMB} MB</div>
            </div>
            <div class="db-maint-summary-item">
              <div class="label">Estimated disk freed</div>
              <div class="value">${diskFreedMB} MB</div>
            </div>
            <div class="db-maint-summary-item">
              <div class="label">Tables analysed</div>
              <div class="value">${formatNumber(s.totalTables || 0)}</div>
            </div>
          </div>
        </div>
      `;
    }

    function renderDatabaseMaintenanceTopTables(job) {
      if (job.jobid !== 32 || !Array.isArray(job.maintenanceTopTables) || job.maintenanceTopTables.length === 0) {
        return '';
      }

      const rowsHtml = job.maintenanceTopTables.map((t) => {
        const sizeBefore = formatBytesToMB(t.sizeBeforeBytes || 0);
        const sizeAfter = formatBytesToMB(t.sizeAfterBytes || 0);
        const bloatAfter = formatBytesToMB(t.estBloatAfterBytes || 0);
        const indexMB = formatBytesToMB(t.indexBytes || 0);
        const isBigIndex = Number(t.indexBytes || 0) >= 200 * 1024 * 1024;
        const lastAutovac = formatDateTime(t.lastAutovacuum);
        const lastAutoanalyze = formatDateTime(t.lastAutoanalyze);

        return `
          <tr class="${isBigIndex ? 'db-maint-big-index' : ''}">
            <td class="name">${t.tableName}</td>
            <td>${sizeBefore} → ${sizeAfter}</td>
            <td>${bloatAfter} MB</td>
            <td>${formatNumber(t.deadAfter || 0)}</td>
            <td class="index-size">${indexMB} MB</td>
            <td>${lastAutovac}</td>
            <td>${lastAutoanalyze}</td>
          </tr>
        `;
      }).join('');

      return `
        <div class="db-maint-top-tables">
          <div class="db-maint-top-tables-header">Top bloated tables (last run)</div>
          <table>
            <thead>
              <tr>
                <th>Table</th>
                <th>Size (MB)</th>
                <th>Estimated bloat (MB)</th>
                <th>Dead tuples</th>
                <th>Index size (MB)</th>
                <th>Last autovacuum</th>
                <th>Last auto-analyze</th>
              </tr>
            </thead>
            <tbody>
              ${rowsHtml}
            </tbody>
          </table>
          <div class="db-maint-top-tables-note">
            Estimates from pg_stat_all_tables / pg_stat_user_indexes immediately after the last maintenance run.
          </div>
        </div>
      `;
    }

    /**
     * Render a single job card
     * @param {JobSummary} job
     * @param {boolean} isLinked
     * @param {string} groupType
     * @returns {string}
     */
    function renderJobCard(job, isLinked, groupType) {
      const jobIdNumber = Number(job.jobid);
      const successRate = job.total_runs > 0 
        ? ((job.success_count / job.total_runs) * 100).toFixed(1)
        : 0;
      const failureRate = job.total_runs > 0
        ? ((job.failed_count / job.total_runs) * 100).toFixed(1)
        : 0;
      const lastRun = job.last_run 
        ? new Date(job.last_run).toLocaleString()
        : 'Never';
      const description = jobDescriptions[job.jobid] || 'No description available.';
      const linkedJobIds = linkedJobs[job.jobid];
      const isLinkedJob = linkedJobIds !== undefined;
      const linkedIdsArray = Array.isArray(linkedJobIds) ? linkedJobIds : [linkedJobIds];
      const linkedIdsText = linkedIdsArray.join(', ');
      const displayName = jobDisplayNames[job.jobid] || job.name || `Job ${job.jobid}`;
      const frequency = parseCronFrequency(job.schedule);
      
      // Calculate next run and health
      const nextRunInMinutes = job.next_run_minutes || calculateNextRunInMinutes(job);
      const nextRunText = formatNextRunLabel(nextRunInMinutes);
      
      const health = getJobHealth(job, nextRunInMinutes);
      
      // Load regression test data for risky jobs (use pre-loaded data)
      let regressionSummary = '';
      let hasFixedBaseline = false;
      if (riskyJobs.includes(jobIdNumber)) {
        const regressionSourceId = getRegressionSourceJobId(jobIdNumber);
        const regressionData = regressionTestData[regressionSourceId] || null;
        const mirroredFrom = regressionSourceId !== jobIdNumber ? regressionSourceId : null;
        
        // Check if there's a fixed baseline (either in baseline data or fixed_baseline_info)
        hasFixedBaseline = regressionData?.baseline?.is_fixed_baseline === true || 
                          regressionData?.fixed_baseline_info !== null;
        
        regressionSummary = renderRegressionTestSummary(regressionData, jobIdNumber, mirroredFrom);
      }
      
      const borderColor = 
        groupType === 'analytics' ? '#f5576c' : 
        groupType === 'refresh' ? '#00f2fe' : 
        groupType === 'maintenance' ? '#f5576c' :
        groupType === 'performance' ? '#4facfe' :
        groupType === 'health' ? '#43e97b' :
        groupType === 'system' ? '#fa709a' :
        '#3498db';
      
      const isLogDrawerOpen = activeLogJobId === job.jobid;
      
      return `
        <div class="job-card" data-job-card-id="${job.jobid}" ${isLinkedJob ? `style="border: 2px solid ${borderColor};"` : ''}>
          <div class="job-header">
            <div>
              <div class="job-title">${displayName}${hasFixedBaseline ? ' <span style="background: #28a745; color: white; padding: 2px 6px; border-radius: 4px; font-size: 10px; font-weight: bold; margin-left: 8px;">🔒 MASTER BASELINE</span>' : ''}</div>
              <div class="job-id">ID: ${job.jobid}${isLinkedJob ? ` <span style="color: ${borderColor}; font-size: 16px; font-weight: 700;">↔ Linked to Jobs ${linkedIdsText}</span>` : ''}</div>
            </div>
            <span class="status-badge ${job.status === 'active' ? 'status-active' : 'status-inactive'}">
              ${job.status === 'active' ? 'Active' : 'Inactive'}
            </span>
          </div>
          <div class="health-status health-${health.level}" title="${health.reason}">${health.label}</div>
          <div style="margin-bottom: 15px;">
            <div class="frequency-pill">⏰ ${frequency}</div>
            <div class="next-run-badge">${nextRunText}</div>
          </div>
          ${regressionSummary}
          <div class="job-description">${description}</div>
          <div class="job-schedule">Schedule: ${job.schedule}</div>
          <div class="job-stats">
            <div class="stat-item">
              <div class="stat-label">Last Run</div>
              <div class="stat-value" style="font-size: 12px;">${lastRun}</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">Total Runs</div>
              <div class="stat-value">${job.total_runs}</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">Success Rate</div>
              <div class="stat-value success-rate">${successRate > 50 ? `<span class="badge-success">${successRate}%</span>` : `<span class="badge-failure">${successRate}%</span>`}</div>
              <div style="font-size: 11px; color: #7f8c8d;">${job.success_count} succeeded</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">Failure Rate</div>
              <div class="stat-value failure-rate">${failureRate > 50 ? `<span class="badge-failure">${failureRate}%</span>` : `<span class="badge-success">${failureRate}%</span>`}</div>
              <div style="font-size: 11px; color: #7f8c8d;">${job.failed_count} failed</div>
            </div>
          </div>
          ${renderDatabaseMaintenanceSummary(job)}
          ${renderDatabaseMaintenanceTopTables(job)}
          <div class="job-progress" id="progress-${job.jobid}" style="display:none;">
            <div class="progress-bar-container">
              <div class="progress-bar"></div>
            </div>
            <span class="progress-message"></span>
          </div>
          <div class="sparkline-section">
            <div style="font-size: 12px; font-weight: 600; margin-bottom: 5px; color: #666;">Last runs</div>
            <div class="sparkline-container" id="sparkline-${job.jobid}"></div>
          </div>
          <button class="view-logs-btn" data-jobid="${job.jobid}">${isLogDrawerOpen ? 'Hide Logs' : 'View Logs'}</button>
          <div id="log-drawer-${job.jobid}" class="log-drawer" style="display: ${isLogDrawerOpen ? 'block' : 'none'};"></div>
          <div class="job-actions">
            <button class="btn btn-primary btn-small" onclick="runJobNow(${job.jobid}, '${displayName}')">▶ Run Now</button>
            ${isJobActive(job.jobid) ? `<button class="btn btn-danger btn-small" onclick="stopJob(${job.jobid}, '${displayName}')" title="Stop currently running job">⏹ Stop</button>` : ''}
            <button class="btn btn-secondary btn-small" onclick="editSchedule(${job.jobid}, '${job.schedule}', '${displayName}')">Edit Schedule</button>
            <button class="btn btn-secondary btn-small" onclick="resetJobStats(${job.jobid}, '${displayName}')" title="Reset success/fail counts">🔄 Reset Stats</button>
            <button class="btn ${job.status === 'active' ? 'btn-warning' : 'btn-success'} btn-small" onclick="toggleJob(${job.jobid}, ${job.status !== 'active'}, '${displayName}')">
              ${job.status === 'active' ? '⏸ Pause' : '▶ Resume'}
            </button>
          </div>
        </div>
      `;
    }

    function showMessage(message, type = 'success') {
      const messageDiv = document.getElementById('message');
      messageDiv.className = type;
      messageDiv.textContent = message;
      messageDiv.style.display = 'block';
      setTimeout(() => {
        messageDiv.style.display = 'none';
      }, 5000);
    }

    /**
     * Toggle inline log drawer for a job
     * @param {number} jobid
     */
    async function toggleLogDrawer(jobid) {
      const drawer = document.getElementById(`log-drawer-${jobid}`);
      const btn = document.querySelector(`.view-logs-btn[data-jobid="${jobid}"]`);
      
      if (!drawer || !btn) return;
      
      // If same job is already active, toggle (collapse)
      if (activeLogJobId === jobid) {
        activeLogJobId = null;
        drawer.style.display = 'none';
        btn.textContent = 'View Logs';
        return;
      }
      
      // Close any other open drawer
      if (activeLogJobId !== null) {
        const prevDrawer = document.getElementById(`log-drawer-${activeLogJobId}`);
        const prevBtn = document.querySelector(`.view-logs-btn[data-jobid="${activeLogJobId}"]`);
        if (prevDrawer) prevDrawer.style.display = 'none';
        if (prevBtn) prevBtn.textContent = 'View Logs';
      }
      
      // Open this drawer
      activeLogJobId = jobid;
      drawer.style.display = 'block';
      btn.textContent = 'Hide Logs';
      
      // Check cache
      if (jobLogsCache.has(jobid)) {
        const cached = jobLogsCache.get(jobid);
        if (cached.entries) {
          renderLogDrawer(jobid, cached.entries);
          return;
        }
      }
      
      // Fetch logs
      drawer.innerHTML = '<div class="log-loading">Loading logs...</div>';
      jobLogsCache.set(jobid, { loading: true, error: null, entries: null });
      
      try {
        const response = await fetch(`${API_BASE}/api/admin?action=get_job_logs&jobid=${jobid}&_t=${Date.now()}`, {
          headers: buildAuthHeaders(),
          cache: 'no-store'
        });
        
        const { logs } = await response.json();
        
        if (!logs || logs.length === 0) {
          drawer.innerHTML = '<div class="log-empty">No logs found for this job.</div>';
          jobLogsCache.set(jobid, { loading: false, error: null, entries: [] });
          return;
        }
        
        jobLogsCache.set(jobid, { loading: false, error: null, entries: logs });
        renderLogDrawer(jobid, logs);
      } catch (error) {
        drawer.innerHTML = `
          <div class="log-error">
            Failed to load logs: ${error.message}
            <a href="#" onclick="toggleLogDrawer(${jobid}); return false;" style="color: #3498db; text-decoration: underline; margin-left: 10px;">Retry</a>
          </div>
        `;
        jobLogsCache.set(jobid, { loading: false, error: error.message, entries: null });
      }
    }

    /**
     * Render log entries in the drawer
     * @param {number} jobid
     * @param {Array} logs
     */
    function renderLogDrawer(jobid, logs) {
      const drawer = document.getElementById(`log-drawer-${jobid}`);
      if (!drawer) return;
      
      // Get job name
      const jobCard = document.querySelector(`[data-job-card-id="${jobid}"]`);
      const jobName = jobCard ? (jobCard.querySelector('.job-title')?.textContent || `Job ${jobid}`) : `Job ${jobid}`;
      
      const logsHtml = logs.map(log => {
        const startTime = new Date(log.start_time).toLocaleString();
        const endTime = log.end_time ? new Date(log.end_time).toLocaleString() : 'N/A';
        const duration = log.end_time 
          ? ((new Date(log.end_time) - new Date(log.start_time)) / 1000).toFixed(2) + 's'
          : 'N/A';
        // Check for success - explicitly check for failed/error status
        const isSuccess = log.status === 'succeeded' || log.status === 'success' || 
                         (log.status !== 'failed' && log.status !== 'error');
        const statusClass = isSuccess ? 'status-success' : 'status-failed';
        const statusText = isSuccess ? 'Success' : 'Failed';
        const message = log.return_message || (isSuccess ? 'No message' : 'Error occurred');
        const encodedMessage = encodeURIComponent(message);
        const safeMessage = escapeHtml(message);
        
        return `
          <div class="log-entry">
            <div class="log-entry-header">
              <span class="log-status-badge ${statusClass}">${statusText}</span>
              <span class="log-timestamp">${startTime}</span>
              <span class="log-duration">${duration}</span>
              <button class="log-copy-btn" data-message="${encodedMessage}" onclick="copyLogEntryMessage(this)">📋 Copy</button>
            </div>
            <div class="log-message ${!isSuccess ? 'log-error-message' : ''}">${safeMessage}</div>
          </div>
        `;
      }).join('');
      
      drawer.innerHTML = `
        <div class="log-drawer-header">Recent logs for: ${jobName}</div>
        <div class="log-drawer-content">${logsHtml}</div>
      `;
    }

    function copyLogEntryMessage(button) {
      const encoded = button.getAttribute('data-message') || '';
      let text = '';
      try {
        text = decodeURIComponent(encoded);
      } catch (err) {
        text = encoded;
      }
      navigator.clipboard.writeText(text).then(() => {
        addDebugLog('Log entry copied to clipboard', 'success');
      }).catch((err) => {
        addDebugLog('Failed to copy log entry: ' + err.message, 'error');
      });
    }


    function editSchedule(jobid, currentSchedule, jobname) {
      const modal = document.getElementById('scheduleModal');
      const content = document.getElementById('scheduleModalContent');
      
      const cronPresets = [
        { label: 'Every minute', value: '* * * * *' },
        { label: 'Every 5 minutes', value: '*/5 * * * *' },
        { label: 'Every 15 minutes', value: '*/15 * * * *' },
        { label: 'Every 30 minutes', value: '*/30 * * * *' },
        { label: 'Every hour', value: '0 * * * *' },
        { label: 'Every 4 hours', value: '0 */4 * * *' },
        { label: 'Every 8 hours', value: '0 */8 * * *' },
        { label: 'Every 12 hours', value: '0 */12 * * *' },
        { label: 'Daily at midnight', value: '0 0 * * *' },
        { label: 'Daily at 6 AM', value: '0 6 * * *' },
        { label: 'Weekly (Monday 2 AM)', value: '0 2 * * 1' }
      ];

      content.innerHTML = `
        <h3>${jobname || `Job ${jobid}`}</h3>
        <div class="form-group">
          <label>Current Schedule</label>
          <input type="text" value="${currentSchedule}" readonly style="background: #f5f5f5;" />
        </div>
        <div class="form-group">
          <label>New Schedule (Cron Format)</label>
          <input type="text" id="newSchedule" value="${currentSchedule}" placeholder="* * * * *" />
          <small>Format: minute hour day month weekday (e.g., "0 */8 * * *" for every 8 hours)</small>
          <div class="cron-presets">
            ${cronPresets.map(preset => 
              `<button class="preset-btn" onclick="document.getElementById('newSchedule').value='${preset.value}'">${preset.label}</button>`
            ).join('')}
          </div>
        </div>
        <div class="job-actions">
          <button class="btn btn-primary" onclick="updateSchedule(${jobid})">Update Schedule</button>
          <button class="btn btn-secondary" onclick="closeScheduleModal()">Cancel</button>
        </div>
      `;
      
      modal.classList.add('active');
    }

    function closeScheduleModal() {
      document.getElementById('scheduleModal').classList.remove('active');
    }

    function isJobActive(jobid) {
      // Check if job is in active jobs list
      return activeJobs.some(job => {
        if (!job.job_hint) return false;
        const hintJobId = extractJobIdFromHint(job.job_hint);
        return hintJobId === jobid;
      });
    }

    async function stopJob(jobid, jobname) {
      addDebugLog(`Stop job requested for job ${jobid} (${jobname})`, 'info', { jobid, jobname });
      
      if (!confirm(`Are you sure you want to stop the currently running job "${jobname}" (Job ${jobid})?\n\nThis will terminate the database process immediately.`)) {
        addDebugLog('Stop job cancelled by user', 'warning');
        return;
      }

      try {
        const response = await fetch(`${API_BASE}/api/admin?action=stop_job&jobid=${jobid}`, {
          method: 'GET',
          headers: buildAuthHeaders()
        });

        addDebugLog(`Stop job API response: ${response.status} ${response.statusText}`, 'info');

        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`);
        }

        const data = await response.json();
        addDebugLog('Stop job API response data', 'info', data);

        if (data.ok) {
          showMessage(`Successfully stopped job "${jobname}" (Job ${jobid})`, 'success');
          
          // Hide progress container
          const container = getProgressContainer(jobid);
          if (container) {
            container.style.display = 'none';
          }
          
          // Stop polling for this job
          progressRetryState.delete(jobid);
          activeJobStartTimes.delete(jobid);
          
          // Refresh active jobs and jobs list
          await loadActiveJobs();
          renderActiveJobsBanner();
          await loadJobs();
        } else {
          throw new Error(data.error || 'Failed to stop job');
        }
      } catch (error) {
        addDebugLog(`Error stopping job: ${error.message}`, 'error', { error: error.message, stack: error.stack });
        showMessage(`Failed to stop job "${jobname}": ${error.message}`, 'error');
      }
    }

    async function resetAllJobStats() {
      addDebugLog('Reset all stats requested', 'info');
      
      if (!confirm(`Are you sure you want to reset statistics for ALL jobs?\n\nThis will delete all execution history from public.job_run_details for every job. This action cannot be undone.`)) {
        addDebugLog('Reset all stats cancelled by user', 'warning');
        return;
      }

      try {
        addDebugLog('Sending reset all stats request', 'info');
        const response = await fetch(`${API_BASE}/api/admin?action=reset_all_job_stats`, {
          method: 'POST',
          headers: buildAuthHeaders(),
          body: JSON.stringify({})
        });

        addDebugLog(`Reset all stats API response: ${response.status} ${response.statusText}`, 'info');

        if (!response.ok) {
          const errorText = await response.text();
          let errorData;
          try {
            errorData = JSON.parse(errorText);
          } catch (e) {
            errorData = { error: errorText };
          }
          throw new Error(errorData.error || errorData.detail || `HTTP ${response.status}`);
        }

        const result = await response.json();
        addDebugLog(`Reset all stats successful: ${result.deleted_count} records deleted`, 'success', result);
        showMessage(`Successfully reset all job statistics. Deleted ${result.deleted_count || 0} records.`, 'success');
        
        // Reload jobs to refresh the display
        setTimeout(() => {
          loadJobs();
        }, 500);

      } catch (error) {
        const errorMsg = `Failed to reset all job statistics: ${error.message}`;
        addDebugLog(errorMsg, 'error', { error });
        showMessage(errorMsg, 'error');
        console.error('Error resetting all job stats:', error);
      }
    }

    async function resetJobStats(jobid, jobname) {
      addDebugLog(`Reset stats requested for job ${jobid} (${jobname})`, 'info', { jobid, jobname });
      
      if (!confirm(`Are you sure you want to reset the success/fail statistics for "${jobname}" (Job ${jobid})?\n\nThis will delete all execution history for this job.`)) {
        addDebugLog('Reset stats cancelled by user', 'warning');
        return;
      }

      try {
        addDebugLog(`Sending reset request for job ${jobid}`, 'info');
        const response = await fetch(`${API_BASE}/api/admin?action=reset_job_stats`, {
          method: 'POST',
          headers: buildAuthHeaders(),
          body: JSON.stringify({ jobid: jobid })
        });

        addDebugLog(`Reset API response: ${response.status} ${response.statusText}`, 'info');

        if (!response.ok) {
          const errorText = await response.text();
          let errorData;
          try {
            errorData = JSON.parse(errorText);
          } catch {
            errorData = { message: errorText };
          }
          addDebugLog(`Reset API error response`, 'error', { status: response.status, statusText: response.statusText, error: errorData });
          throw new Error(`HTTP ${response.status}: ${errorData.detail || errorData.error || errorData.message || response.statusText}`);
        }

        const data = await response.json();
        addDebugLog('Reset API response data', 'info', data);
        
        if (!data.ok) {
          throw new Error(data.error || 'Failed to reset job statistics');
        }

        const deletedCount = data.deleted_count || 0;
        const remainingCount = data.remaining_count || 0;
        const beforeCount = data.before_count || 0;
        
        addDebugLog(`Reset stats result: before=${beforeCount}, deleted=${deletedCount}, remaining=${remainingCount}`, 
          remainingCount > 0 ? 'warning' : 'success', data);
        
        if (remainingCount > 0) {
          showMessage(`Warning: Reset completed but ${remainingCount} records still remain for "${jobname}" (Job ${jobid}). Deleted: ${deletedCount}`, 'error');
        } else {
          showMessage(`Successfully reset statistics for "${jobname}" (Job ${jobid}). Deleted ${deletedCount} records.`, 'success');
        }
        
        // Small delay to ensure database has updated before refreshing
        addDebugLog('Waiting 500ms before refreshing jobs...', 'info');
        setTimeout(() => {
          addDebugLog('Refreshing jobs after reset...', 'info');
          loadJobs();
        }, 500);
      } catch (error) {
        addDebugLog(`Error resetting job stats: ${error.message}`, 'error', { error: error.message, stack: error.stack });
        console.error('Error resetting job stats:', error);
        showMessage(`Error resetting statistics: ${error.message}`, 'error');
      }
    }

    async function toggleJob(jobid, active, jobname) {
      const action = active ? 'activate' : 'pause';
      if (!confirm(`Are you sure you want to ${action} "${jobname}" (Job ${jobid})?`)) {
        return;
      }

      try {
        const response = await fetch(`${API_BASE}/api/admin?action=toggle_cron_job`, {
          method: 'POST',
          headers: buildAuthHeaders(),
          body: JSON.stringify({ jobid, active })
        });

        const data = await response.json();
        if (!data.ok) {
          throw new Error(data.error || `Failed to ${action} job`);
        }

        showMessage(`Job ${active ? 'activated' : 'paused'} successfully!`, 'success');
        loadJobs();
      } catch (error) {
        showMessage(`Error ${action}ing job: ${error.message}`, 'error');
      }
    }

    // Helper function to calculate frequency_minutes from cron schedule
    function calculateFrequencyMinutes(cronSchedule) {
      const parts = cronSchedule.trim().split(/\s+/);
      if (parts.length !== 5) return null;
      
      const [minute, hour, dayOfMonth, month, dayOfWeek] = parts;
      
      // Every minute
      if (minute === '*' && hour === '*' && dayOfMonth === '*' && month === '*' && dayOfWeek === '*') {
        return 1;
      }
      
      // Every N minutes
      if (minute.startsWith('*/') && hour === '*' && dayOfMonth === '*' && month === '*' && dayOfWeek === '*') {
        return parseInt(minute.substring(2)) || null;
      }
      
      // Every hour at specific minute
      if (minute !== '*' && hour === '*' && dayOfMonth === '*' && month === '*' && dayOfWeek === '*') {
        return 60;
      }
      
      // Every N hours
      if (hour.startsWith('*/') && dayOfMonth === '*' && month === '*' && dayOfWeek === '*') {
        const hours = parseInt(hour.substring(2)) || 1;
        return hours * 60;
      }
      
      // Daily
      if (dayOfMonth === '*' && month === '*' && dayOfWeek === '*') {
        return 1440; // 24 hours
      }
      
      // Weekly
      if (dayOfWeek !== '*' && dayOfMonth === '*' && month === '*') {
        return 10080; // 7 days
      }
      
      // Monthly
      if (dayOfMonth !== '*' && month === '*' && dayOfWeek === '*') {
        return 43200; // ~30 days
      }
      
      return null;
    }

    async function updateSchedule(jobid) {
      const newSchedule = document.getElementById('newSchedule').value.trim();
      
      if (!newSchedule) {
        showMessage('Please enter a schedule', 'error');
        return;
      }

      try {
        // Update cron schedule
        const scheduleResponse = await fetch(`${API_BASE}/api/admin?action=update_cron_schedule`, {
          method: 'POST',
          headers: buildAuthHeaders(),
          body: JSON.stringify({ jobid, schedule: newSchedule })
        });

        const scheduleData = await scheduleResponse.json();
        if (!scheduleData.ok) {
          throw new Error(scheduleData.error || 'Failed to update schedule');
        }

        // Calculate and update frequency_minutes
        const frequencyMinutes = calculateFrequencyMinutes(newSchedule);
        if (frequencyMinutes !== null) {
          try {
            await fetch(`${API_BASE}/api/admin?action=update_schedule`, {
              method: 'POST',
              headers: buildAuthHeaders(),
              body: JSON.stringify({
                jobId: jobid,
                frequency_minutes: frequencyMinutes
              })
            });
          } catch (freqError) {
            // If frequency update fails, log but don't fail the whole operation
            console.warn('Failed to update frequency_minutes:', freqError);
          }
        }

        showMessage('Schedule updated successfully!', 'success');
        closeScheduleModal();
        loadJobs();
      } catch (error) {
        showMessage(`Error updating schedule: ${error.message}`, 'error');
      }
    }

    // Close modals when clicking outside
    window.onclick = function(event) {
      const scheduleModal = document.getElementById('scheduleModal');
      const logsModal = document.getElementById('logsModal');
      if (event.target === scheduleModal) {
        closeScheduleModal();
      }
      if (event.target === logsModal) {
        closeLogsModal();
      }
    }
  </script>

  <!-- Regression Details Modal -->
  <div id="regressionDetailsModal" class="modal">
    <div class="modal-content">
      <span class="close" onclick="closeRegressionDetails()">&times;</span>
      <div id="regressionDetailsContent"></div>
    </div>
  </div>

  <!-- Job Execution Results Modal -->
  <div id="jobExecutionModal" class="modal">
    <div class="modal-content" style="max-width: 1000px;">
      <span class="close" onclick="closeJobExecutionModal()">&times;</span>
      <div id="jobExecutionContent"></div>
    </div>
  </div>

  <script>
    // Close modals when clicking outside
    window.onclick = function(event) {
      const regressionModal = document.getElementById('regressionDetailsModal');
      const executionModal = document.getElementById('jobExecutionModal');
      
      if (event.target == regressionModal) {
        closeRegressionDetails();
      }
      if (event.target == executionModal) {
        closeJobExecutionModal();
      }
    }
  </script>

  <!-- Log Modal -->
  <div id="logModal" class="modal hidden">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">Run Logs for <span id="logJobName"></span></div>
        <button class="close-btn" onclick="closeLogModal()">&times;</button>
      </div>
      <pre id="logContent"></pre>
      <div style="margin-top: 15px;">
        <button class="btn btn-secondary" id="closeLogModalBtn">Close</button>
      </div>
    </div>
  </div>

  <!-- Debug Log -->
  <div class="debug-log-container" id="debugLogContainer">
    <div class="debug-log-header">
      <div class="debug-log-title">🔍 Debug Log</div>
      <div class="debug-log-controls">
        <button class="btn btn-secondary btn-small" onclick="clearDebugLog()" style="padding: 4px 8px; font-size: 11px;">Clear</button>
        <button class="btn btn-primary btn-small" onclick="copyDebugLog()" style="padding: 4px 8px; font-size: 11px;">📋 Copy Log</button>
        <button class="btn btn-secondary btn-small" onclick="toggleDebugLog()" style="padding: 4px 8px; font-size: 11px;">▼ Hide</button>
      </div>
    </div>
    <div class="debug-log-content" id="debugLogContent"></div>
  </div>

  <script>
    // Global debug log
    const debugLog = [];
    const MAX_LOG_ENTRIES = 500;

    function addDebugLog(message, type = 'info', data = null) {
      const timestamp = new Date().toLocaleTimeString();
      const entry = {
        timestamp,
        message,
        type,
        data
      };
      
      debugLog.push(entry);
      
      // Keep only last MAX_LOG_ENTRIES
      if (debugLog.length > MAX_LOG_ENTRIES) {
        debugLog.shift();
      }
      
      // Update UI
      updateDebugLogDisplay();
    }

    function updateDebugLogDisplay() {
      const content = document.getElementById('debugLogContent');
      if (!content) return;
      
      const html = debugLog.map(entry => {
        const dataStr = entry.data ? `\n${JSON.stringify(entry.data, null, 2)}` : '';
        return `<div class="debug-log-entry ${entry.type}">
          <span class="debug-log-timestamp">[${entry.timestamp}]</span>
          ${entry.message}${dataStr ? `<pre style="margin: 4px 0 4px 20px; color: #808080; font-size: 11px;">${escapeHtml(dataStr)}</pre>` : ''}
        </div>`;
      }).join('');
      
      content.innerHTML = html;
      content.scrollTop = content.scrollHeight;
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function clearDebugLog() {
      debugLog.length = 0;
      updateDebugLogDisplay();
      addDebugLog('Debug log cleared', 'info');
    }

    function copyDebugLog() {
      const logText = debugLog.map(entry => {
        const dataStr = entry.data ? `\n${JSON.stringify(entry.data, null, 2)}` : '';
        return `[${entry.timestamp}] ${entry.type.toUpperCase()}: ${entry.message}${dataStr}`;
      }).join('\n\n');
      
      navigator.clipboard.writeText(logText).then(() => {
        addDebugLog('Debug log copied to clipboard', 'success');
      }).catch(err => {
        addDebugLog('Failed to copy log: ' + err.message, 'error');
      });
    }

    function toggleDebugLog() {
      const container = document.getElementById('debugLogContainer');
      const content = document.getElementById('debugLogContent');
      const btn = event.target;
      
      if (content.style.display === 'none') {
        content.style.display = 'block';
        container.style.maxHeight = '300px';
        btn.textContent = '▼ Hide';
      } else {
        content.style.display = 'none';
        container.style.maxHeight = '40px';
        btn.textContent = '▲ Show';
      }
    }

    // Initialize debug log
    addDebugLog('Debug log initialized', 'info');
  </script>
</body>
</html>



