<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Bulk Ingest</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font: 15px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 20px; }
    h1 { margin: 0 0 16px; }
    input, button, select { font: inherit; }
    input[type="number"] { width: 100px; }
    .row { display: grid; grid-template-columns: 280px 1fr; gap: 12px; margin-bottom: 10px; align-items: center; }
    .actions { display: flex; gap: 8px; }
    .btn { padding: 6px 10px; border: 1px solid #ccc; border-radius: 6px; cursor: pointer; background: #fff; }
    .btn:disabled { opacity: .5; cursor: default; }
    .btn--danger { background: #e74c3c; color: #fff; border-color: #e74c3c; }
    .help { color: #666; font-size: 12px; }
    .panel { border: 1px solid #eee; border-radius: 8px; padding: 10px; margin-top: 12px; }
    table { width: 100%; border-collapse: collapse; margin-top: 10px; }
    th, td { font-size: 13px; padding: 8px; border-bottom: 1px solid #f0f0f0; }
    th { text-align: left; color: #444; background: #fafafa; }
    .ok { color: #2ecc71; font-weight: 600; }
    .fail { color: #e74c3c; font-weight: 600; }
    details { margin-top: 8px; }
    .pill { display: inline-block; padding: 2px 6px; border-radius: 999px; background: #f3f4f6; font-size: 12px; color: #444; }
  </style>
</head>
<body>
  <h1>Bulk Ingest</h1>
  <p class="help">Upload a CSV with a <b>url</b> column (optional <b>title</b>). For each row, we:
    <span class="pill">/api/extract</span> → <span class="pill">/api/ingest-embed</span> (replace per URL).
  </p>

  <div class="panel">
    <div class="row">
      <label for="token">Ingest Token (Bearer)</label>
      <input id="token" type="text" placeholder="paste your ingest token here…" />
      <div class="help" style="grid-column: 2">Saved in your browser only. Sent as <code>Authorization: Bearer …</code> to <code>/api/ingest-embed</code>.</div>
    </div>

    <div class="row">
      <label for="csv">CSV file</label>
      <div class="actions">
        <input id="csv" type="file" accept=".csv" />
        <button id="start" class="btn">Start Ingest</button>
        <button id="stop" class="btn btn--danger" disabled>Stop</button>
      </div>
      <div class="help" style="grid-column: 2">Example header: <code>url,title</code></div>
    </div>

    <div class="row">
      <label for="conc">Concurrency</label>
      <input id="conc" type="number" min="1" max="10" value="3" />
      <label for="delay">Delay between requests (ms)</label>
      <input id="delay" type="number" min="0" max="10000" step="50" value="400" />
    </div>
  </div>

  <details class="panel">
    <summary><b>CSV format</b> (click to expand)</summary>
    <pre>url,title
https://www.example.com/page-1,Example page
https://www.example.com/page-2,</pre>
  </details>

  <div class="panel">
    <div id="summary" class="help">Loaded 0 rows. Waiting…</div>
    <table id="results">
      <thead>
        <tr><th style="width:60px">#</th><th>URL</th><th>Result</th></tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <script>
    // --- Config / storage
    const DEFAULT_TOKEN = 'b6c3f0c9e6f44cce9e1a4f3f2d3a5c76'; // prefill per your request
    const els = {
      token: document.getElementById('token'),
      csv: document.getElementById('csv'),
      start: document.getElementById('start'),
      stop: document.getElementById('stop'),
      conc: document.getElementById('conc'),
      delay: document.getElementById('delay'),
      summary: document.getElementById('summary'),
      tableBody: document.querySelector('#results tbody'),
    };

    // Prefill / persist token locally
    els.token.value = localStorage.getItem('bulk_token') || DEFAULT_TOKEN;
    els.token.addEventListener('input', () => localStorage.setItem('bulk_token', els.token.value.trim()));

    // State
    let abort = false;
    let rows = [];

    // CSV → rows
    function parseCSV(text) {
      const lines = text.replace(/\r/g, '').split('\n').filter(Boolean);
      if (lines.length === 0) return [];
      const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
      const urlIdx = headers.indexOf('url');
      const titleIdx = headers.indexOf('title');

      if (urlIdx === -1) throw new Error('CSV must include a "url" column');

      const out = [];
      for (let i = 1; i < lines.length; i++) {
        const cols = lines[i].split(','); // simple parse (no quoted commas)
        const url = (cols[urlIdx] || '').trim();
        const title = titleIdx >= 0 ? (cols[titleIdx] || '').trim() : '';
        if (url) out.push({ url, title });
      }
      return out;
    }

    function setSummary(ok, fail, total) {
      els.summary.innerHTML =
        `Loaded ${total} rows. <span class="ok">Success: ${ok}</span> &nbsp; <span class="fail">Failed: ${fail}</span>`;
    }

    function addResultRow(idx, url) {
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${idx}</td><td><a href="${url}" target="_blank" rel="noreferrer">${url}</a></td><td id="r-${idx}">…</td>`;
      els.tableBody.appendChild(tr);
      return document.getElementById(`r-${idx}`);
    }

    // Call server-side extractor
    async function extractOnServer(url) {
      const r = await fetch('/api/extract', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ url })
      });
      if (!r.ok) {
        const t = await safeText(r);
        throw new Error(`extract ${r.status}: ${t}`);
      }
      return r.json();
    }

    // POST to ingest-embed (replace per URL)
    async function ingestReplace({ url, title, chunks }, token) {
      const r = await fetch('/api/ingest-embed', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer ' + token
        },
        body: JSON.stringify({ url, title, chunks })
      });
      if (!r.ok) {
        const t = await safeText(r);
        throw new Error(`ingest ${r.status}: ${t}`);
      }
      return r.json();
    }

    async function safeText(resp) {
      try { return await resp.text(); } catch { return '<no body>'; }
    }

    // Work queue with concurrency + delay
    async function runQueue(items, concurrency, delayMs, token) {
      let ok = 0, fail = 0, next = 0;

      const workers = new Array(concurrency).fill(0).map(async () => {
        while (!abort && next < items.length) {
          const i = next++;
          const { url, title } = items[i];
          const cell = addResultRow(i + 1, url);

          try {
            // 1) Extract server-side
            const { chunks, title: extractedTitle } = await extractOnServer(url);

            if (!chunks || !chunks.length) {
              throw new Error('no chunks extracted');
            }

            // 2) Ingest (replace per URL)
            const body = { url, title: (title || extractedTitle || '').slice(0, 200), chunks };
            const resp = await ingestReplace(body, token);

            cell.innerHTML = `<span class="ok">OK</span> — ${chunks.length} chunks`;
            ok++;
          } catch (e) {
            cell.innerHTML = `<span class="fail">FAILED</span> — ${e.message}`;
            fail++;
          }

          setSummary(ok, fail, items.length);
          if (delayMs > 0) await new Promise(r => setTimeout(r, delayMs));
        }
      });

      await Promise.all(workers);
      return { ok, fail, total: items.length };
    }

    // UI handlers
    els.start.addEventListener('click', async () => {
      try {
        const token = els.token.value.trim();
        if (!token) return alert('Please paste your ingest token.');

        const file = els.csv.files[0];
        if (!file) return alert('Please choose a CSV file.');

        const text = await file.text();
        rows = parseCSV(text);
        if (!rows.length) return alert('No rows with a "url" found.');

        // Reset
        abort = false;
        els.tableBody.innerHTML = '';
        setSummary(0, 0, rows.length);
        els.start.disabled = true;
        els.stop.disabled = false;

        const conc = Math.max(1, Math.min(10, parseInt(els.conc.value || '3', 10)));
        const delay = Math.max(0, Math.min(10000, parseInt(els.delay.value || '400', 10)));

        await runQueue(rows, conc, delay, token);
      } catch (e) {
        alert(e.message || e);
      } finally {
        els.start.disabled = false;
        els.stop.disabled = true;
      }
    });

    els.stop.addEventListener('click', () => {
      abort = true;
      els.stop.disabled = true;
    });
  </script>
</body>
</html>
