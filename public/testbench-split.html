<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Split Testbench ‚Äì Chat.js vs RPC RAG</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg:#0b1220; --panel:#0f172a; --line:#1b2540; --text:#dbe4ff; --muted:#9fb3ff;
      --orange:#E57200; --green:#00B67A; --bad:#f87171; --good:#34d399;
      --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif;
    }
    *{box-sizing:border-box}
    body{background:var(--bg);color:var(--text);font:14px/1.5 var(--sans);margin:0;padding:24px}
    a{color:white;text-decoration:underline}
    a:visited{color:#ccc}
    a:hover{color:var(--orange)}
    h1{margin:0 0 8px 0}
    .muted{color:var(--muted)}
    .row{display:flex;gap:16px;align-items:flex-start;flex-wrap:wrap}
    .col{flex:1;min-width:280px}
    .card{background:var(--panel);border:1px solid var(--line);border-radius:10px;padding:16px}
    input,button,select,textarea{background:#0b1220;color:var(--text);border:1px solid var(--line);border-radius:8px;padding:8px}
    button{cursor:pointer}
    table{width:100%;border-collapse:collapse;font-size:13px}
    th,td{border-top:1px solid var(--line);padding:6px 8px;vertical-align:top}
    th{color:var(--muted);text-align:left}
    code, .mono{font-family:var(--mono)}
    .pill{display:inline-block;border:1px solid var(--line);border-radius:999px;padding:6px 10px;margin:4px 6px 0 0;text-decoration:none;color:var(--text);font-weight:600}
    .pill.brand{background:transparent;border-color:var(--orange);color:var(--orange)}
    .grid{display:grid;grid-template-columns:repeat(12,1fr);gap:16px}
    .span-12{grid-column:span 12}
    .span-6{grid-column:span 6}
    .span-4{grid-column:span 4}
    .kpi{display:flex;gap:10px;align-items:center}
    .badge{display:inline-block;padding:2px 6px;border-radius:6px;background:#0b1220;border:1px solid var(--line);font-size:12px}
    .badge.good{border-color:#1e3a2a;color:#86efac}
    .badge.bad{border-color:#3a1e1e;color:#fecaca}
    details.debug{border:1px dashed var(--line);border-radius:8px;padding:10px;margin-top:12px}
    .small{font-size:12px}
    .mb8{margin-bottom:8px}
    .mb16{margin-bottom:16px}
    .orange{color:var(--orange)}
    .flex{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .w100{width:100%}
    .nowrap{white-space:nowrap}
    .table-wrap{max-height:360px;overflow:auto;border:1px solid var(--line);border-radius:8px}
    .hint{color:#94a3b8}
    .conversation{background:var(--panel);border:1px solid var(--line);border-radius:8px;padding:12px;margin-bottom:16px;max-height:300px;overflow-y:auto}
    .message{display:flex;gap:8px;margin-bottom:8px}
    .message.user{flex-direction:row-reverse}
    .message-content{background:var(--bg);border:1px solid var(--line);border-radius:8px;padding:8px;max-width:70%}
    .message.user .message-content{background:var(--orange);color:white}
    .message-time{font-size:11px;color:var(--muted)}
    .api-status{display:flex;gap:8px;align-items:center}
    .status-indicator{width:8px;height:8px;border-radius:50%;background:var(--bad)}
    .status-indicator.connected{background:var(--good)}
    .split-container{display:flex;gap:16px}
    .split-side{flex:1;border:2px solid var(--line);border-radius:8px;padding:16px}
    .split-side.chat{border-color:var(--orange)}
    .split-side.rpc{border-color:var(--green)}
    .side-header{display:flex;gap:8px;align-items:center;margin-bottom:12px;font-weight:bold}
    .side-header.chat{color:var(--orange)}
    .side-header.rpc{color:var(--green)}
    .response-box{background:var(--bg);border:1px solid var(--line);border-radius:8px;padding:12px;margin-bottom:12px;min-height:100px}
    .response-title{font-weight:bold;margin-bottom:8px}
    .response-content{white-space:pre-wrap;font-family:var(--mono);font-size:12px}
    .loading{opacity:0.6}
    .error{color:var(--bad);background:#3a1e1e;border:1px solid var(--bad);padding:8px;border-radius:4px}
    .success{color:var(--good);background:#1e3a2a;border:1px solid var(--good);padding:8px;border-radius:4px}
  </style>
</head>
<body>
  <header class="mb16">
    <h1>Split Testbench ‚Äì <span class="orange">Chat.js</span> vs <span class="green">RPC RAG</span></h1>
    <div class="muted">Compare chat.js API responses with direct Supabase RPC calls</div>
  </header>

  <section class="row mb16">
    <div class="col card">
      <h3 class="mb8">Query Input</h3>
      <input id="queryInput" class="w100 mb8" placeholder="Enter your query here..." value="when is the next bluebell workshop">
      <div class="flex mb8">
        <button id="btnRunBoth">Run Both</button>
        <button id="btnClearResults">Clear Results</button>
        <span class="small">Context: <span id="contextInfo" class="badge">None</span></span>
      </div>
      <div class="flex mb8">
        <button id="btnTestBluebell">Bluebell Workshop</button>
        <button id="btnTestParticipants">How many people?</button>
        <button id="btnTestPrice">How much does it cost?</button>
      </div>
    </div>

    <div class="col card">
      <h3 class="mb8">Connection Status</h3>
      <div class="api-status mb8">
        <div id="chatStatus" class="status-indicator"></div>
        <span id="chatStatusText">Chat.js: Not tested</span>
      </div>
      <div class="api-status mb8">
        <div id="rpcStatus" class="status-indicator"></div>
        <span id="rpcStatusText">Supabase RPC: Not tested</span>
      </div>
      <div class="flex">
        <button id="btnTestConnections">Test Connections</button>
        <button id="btnCopyComparison">Copy Comparison</button>
        <button id="btnDownloadLogs">Download Logs</button>
      </div>
    </div>

    <div class="col card">
      <h3 class="mb8">Quick Tests</h3>
      <div class="flex mb8">
        <button id="btnTestLocation">Where is it?</button>
        <button id="btnTestDates">When is it?</button>
        <button id="btnTestAdvice">Photography tips</button>
      </div>
      <div class="flex mb8">
        <button id="btnTestFitness">Fitness level?</button>
        <button id="btnTestDuration">How long?</button>
        <button id="btnTestBooking">How to book?</button>
      </div>
    </div>
  </section>

  <section class="split-container mb16">
    <div class="split-side chat">
      <div class="side-header chat">
        <span>üîß Chat.js API</span>
        <span id="chatStatusBadge" class="badge">Ready</span>
      </div>
      
      <div id="chatResponse" class="response-box">
        <div class="response-title">Response:</div>
        <div class="response-content">Click "Run Both" to test chat.js API</div>
      </div>
      
      <div class="kpi mb8">
        <h4>Events</h4>
        <span id="chatEventsCount" class="badge">0</span>
      </div>
      <div class="table-wrap"><table id="chatEventsTable">
        <thead><tr><th>Title</th><th>When</th><th>Location</th></tr></thead>
        <tbody></tbody>
      </table></div>
      
      <div class="kpi mb8">
        <h4>Products</h4>
        <span id="chatProductsCount" class="badge">0</span>
      </div>
      <div class="table-wrap"><table id="chatProductsTable">
        <thead><tr><th>Title</th><th>¬£</th><th>Tags</th></tr></thead>
        <tbody></tbody>
      </table></div>
    </div>

    <div class="split-side rpc">
      <div class="side-header rpc">
        <span>‚ö° Direct RPC</span>
        <span id="rpcStatusBadge" class="badge">Ready</span>
      </div>
      
      <div id="rpcResponse" class="response-box">
        <div class="response-title">Response:</div>
        <div class="response-content">Click "Run Both" to test direct RPC calls</div>
      </div>
      
      <div class="kpi mb8">
        <h4>Events</h4>
        <span id="rpcEventsCount" class="badge">0</span>
      </div>
      <div class="table-wrap"><table id="rpcEventsTable">
        <thead><tr><th>Title</th><th>When</th><th>Location</th></tr></thead>
        <tbody></tbody>
      </table></div>
      
      <div class="kpi mb8">
        <h4>Products</h4>
        <span id="rpcProductsCount" class="badge">0</span>
      </div>
      <div class="table-wrap"><table id="rpcProductsTable">
        <thead><tr><th>Title</th><th>¬£</th><th>Tags</th></tr></thead>
        <tbody></tbody>
      </table></div>
    </div>
  </section>

  <section class="span-12">
    <details class="debug" open>
      <summary>Debug & Logs</summary>
      <div id="log" class="mono small"></div>
    </details>
  </section>

  <script>
    // ------- Configuration -------
    const SUPABASE_URL = 'https://igzvwbvgvmzvvzoclufx.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImlnenZ3YnZndm16dnZ6b2NsdWZ4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc2Nzc5MjgsImV4cCI6MjA3MzI1MzkyOH0.A9TCmnXKJhDRYBkrO0mAMPiUQeV9enweeyRWKWQ1SZY';
    
    // ------- State -------
    let lastQuery = null;
    let lastChatResponse = null;
    let lastRpcResponse = null;

    // ------- Utilities -------
    const logEl = document.getElementById('log');
    const log = (...args) => {
      const line = args.map(x => typeof x === 'string' ? x : JSON.stringify(x)).join(' ');
      logEl.textContent += line + "\n";
      logEl.scrollTop = logEl.scrollHeight;
    };

    const $ = sel => document.querySelector(sel);
    const $byId = id => document.getElementById(id);

    // Helper to format Chat.js API response for display, truncating large arrays
    function formatChatJsResponse(response) {
      const MAX_ARRAY_ITEMS = 3; // Display only first N items of large arrays
      const formattedResponse = JSON.parse(JSON.stringify(response)); // Deep copy to avoid modifying original

      if (formattedResponse.structured) {
        ['events', 'products', 'articles'].forEach(key => {
          if (Array.isArray(formattedResponse.structured[key]) && formattedResponse.structured[key].length > MAX_ARRAY_ITEMS) {
            const originalLength = formattedResponse.structured[key].length;
            formattedResponse.structured[key] = formattedResponse.structured[key].slice(0, MAX_ARRAY_ITEMS);
            formattedResponse.structured[key].push(`... (${originalLength - MAX_ARRAY_ITEMS} more items)`);
          }
        });
      }
      return JSON.stringify(formattedResponse, null, 2);
    }

    // Extract keywords from query for RPC functions
    function extractKeywords(query) {
      const stopWords = ['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could', 'should', 'may', 'might', 'must', 'can', 'when', 'where', 'what', 'how', 'why', 'who', 'which', 'next', 'last', 'this', 'that', 'these', 'those'];
      
      return query.toLowerCase()
        .replace(/[^\w\s]/g, ' ') // Remove punctuation
        .split(/\s+/)
        .filter(word => word.length > 2 && !stopWords.includes(word))
        .slice(0, 5); // Limit to 5 keywords
    }

    // Build a contextual query for short follow-ups like "how many/how much/when/where"
    function buildContextualQuery(currentQuery, previousQuery) {
      if (!previousQuery) return currentQuery;

      const q = (currentQuery || '').trim().toLowerCase();
      const prev = (previousQuery || '').trim();

      const followUpStarts = [
        'how many', 'how much', 'when', 'where', 'how long', 'what price', 'price',
        'cost', 'how to book', 'how do i book', 'fitness level', 'how fit'
      ];

      const isShort = q.split(/\s+/).length <= 6;
      const isFollowUp = followUpStarts.some(p => q.startsWith(p));

      // Only merge context for short or follow-up style questions
      if (isFollowUp || isShort) {
        return `${prev} ${currentQuery}`.trim();
      }
      return currentQuery;
    }

    // ------- Chat.js API Functions -------
    async function testChatConnection() {
      // Try multiple possible URLs
      const possibleUrls = [
        'https://alan-chat-proxy.vercel.app/api/chat',
        'https://alan-ranger-chat.vercel.app/api/chat',
        '/api/chat'  // fallback to relative path
      ];
      
      for (const apiUrl of possibleUrls) {
        try {
          // Trying Chat.js API
          const response = await fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ query: 'test', topK: 1 })
          });
        
          if (response.ok) {
            $('#chatStatus').classList.add('connected');
            $('#chatStatusText').textContent = 'Chat.js: Connected';
            $('#chatStatusBadge').textContent = 'Connected';
            $('#chatStatusBadge').classList.add('good');
            // Chat.js API connection successful
            return true;
          } else {
            throw new Error(`HTTP ${response.status}`);
          }
        } catch (error) {
          // Failed with API URL
          continue; // Try next URL
        }
      }
      
      // If we get here, all URLs failed
      $('#chatStatus').classList.remove('connected');
      $('#chatStatusText').textContent = 'Chat.js: Failed';
      $('#chatStatusBadge').textContent = 'Failed';
      $('#chatStatusBadge').classList.remove('good');
      // All Chat.js API URLs failed
      return false;
    }

    async function callChatAPI(query, previousQuery = null) {
      // Calling Chat.js API
      
      // Use the same URL discovery logic as testChatConnection
      const possibleUrls = [
        'https://alan-chat-proxy.vercel.app/api/chat',
        'https://alan-ranger-chat.vercel.app/api/chat',
        '/api/chat'  // fallback to relative path
      ];
      
      for (const apiUrl of possibleUrls) {
        try {
          // Trying Chat.js API
          
          const response = await fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ 
              query, 
              topK: 8, 
              previousQuery 
            })
          });

          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }

          const data = await response.json();
          // Chat.js response received
          return data;
        } catch (error) {
          // Failed with API URL
          continue; // Try next URL
        }
      }
      
      // If we get here, all URLs failed
      throw new Error('All Chat.js API URLs failed');
    }

    // ------- Supabase RPC Functions -------
    async function testRpcConnection() {
      try {
        const { createClient } = await import('https://cdn.skypack.dev/@supabase/supabase-js@2');
        const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        
        // Test with a simple query
        const { data, error } = await supabase.rpc('search_events', { 
          keys: ['test']
        });
        
        if (error) {
          throw error;
        }
        
        $('#rpcStatus').classList.add('connected');
        $('#rpcStatusText').textContent = 'Supabase RPC: Connected';
        $('#rpcStatusBadge').textContent = 'Connected';
        $('#rpcStatusBadge').classList.add('good');
        // Supabase RPC connection successful
        return true;
      } catch (error) {
        $('#rpcStatus').classList.remove('connected');
        $('#rpcStatusText').textContent = 'Supabase RPC: Failed';
        $('#rpcStatusBadge').textContent = 'Failed';
        $('#rpcStatusBadge').classList.remove('good');
        // Supabase RPC connection failed
        return false;
      }
    }

    async function callRpcFunctions(query) {
      log(`üì§ RPC calls: "${query}"`);
      
      try {
        const { createClient } = await import('https://cdn.skypack.dev/@supabase/supabase-js@2');
        const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        
        // Extract keywords from the query for better RPC matching
        const keywords = extractKeywords(query);
        log(`üîç Calling RPC functions with query: "${query}" and keywords: [${keywords.join(', ')}]`);
        const [eventsResult, productsResult, articlesResult] = await Promise.all([
          supabase.rpc('search_events', { keys: keywords }),
          supabase.rpc('search_products', { keys: keywords }),
          supabase.rpc('search_articles', { keys: keywords })
        ]);
        
        // RPC results processed
        
        const response = {
          events: eventsResult.data || [],
          products: productsResult.data || [],
          articles: articlesResult.data || [],
          errors: {
            events: eventsResult.error,
            products: productsResult.error,
            articles: articlesResult.error
          }
        };
        
        log(`üì• RPC response: ${eventsResult.data?.length || 0} events, ${productsResult.data?.length || 0} products, ${articlesResult.data?.length || 0} articles`);
        return response;
      } catch (error) {
        log('‚ùå RPC calls failed:', error.message);
        throw error;
      }
    }

    // ------- Rendering Functions -------
    function renderChatResponse(data) {
      const responseEl = $byId('chatResponse');
      
      if (data.error) {
        responseEl.innerHTML = `
          <div class="response-title">Error:</div>
          <div class="response-content error">${escapeHTML(data.error)}</div>
        `;
        return;
      }
      
      const answer = data.answer_markdown || 'No answer provided';
      const intent = data.structured?.intent || 'unknown';
      const confidence = data.confidence_pct || 0;
      
      responseEl.innerHTML = `
        <div class="response-title">Answer:</div>
        <div class="response-content">${escapeHTML(answer)}</div>
        <div class="response-title">Intent: ${intent} (${confidence}%)</div>
      `;
      
      // Render structured data
      renderChatTables(data.structured || {});
    }

    function renderRpcResponse(data) {
      const responseEl = $byId('rpcResponse');
      
      if (data.errors && (data.errors.events || data.errors.products || data.errors.articles)) {
        const errors = Object.entries(data.errors).filter(([_, error]) => error).map(([type, error]) => `${type}: ${error.message}`).join(', ');
        responseEl.innerHTML = `
          <div class="response-title">RPC Errors:</div>
          <div class="response-content error">${escapeHTML(errors)}</div>
        `;
        return;
      }
      
      const totalResults = (data.events?.length || 0) + (data.products?.length || 0) + (data.articles?.length || 0);
      
      responseEl.innerHTML = `
        <div class="response-title">Direct RPC Results:</div>
        <div class="response-content">Found ${totalResults} total results (${data.events?.length || 0} events, ${data.products?.length || 0} products, ${data.articles?.length || 0} articles)</div>
      `;
      
      // Render tables
      renderRpcTables(data);
    }

    function renderChatTables(structured) {
      const { events = [], products = [] } = structured;
      
      // Events table
      const eventsTbody = $('#chatEventsTable tbody');
      eventsTbody.innerHTML = '';
      events.forEach(event => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td><a href="${event.href || event.page_url}" target="_blank">${escapeHTML(event.title || '')}</a></td>
          <td class="nowrap">${escapeHTML(event.when || event.date_start || '')}</td>
          <td>${escapeHTML(event.location || '')}</td>
        `;
        eventsTbody.appendChild(tr);
      });
      $('#chatEventsCount').textContent = events.length;
      
      // Products table
      const productsTbody = $('#chatProductsTable tbody');
      productsTbody.innerHTML = '';
      products.forEach(product => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td><a href="${product.page_url}" target="_blank">${escapeHTML(product.title || '')}</a></td>
          <td>${product.display_price || product.price ? `¬£${product.display_price || product.price}` : ''}</td>
          <td>${escapeHTML(product.tags || '')}</td>
        `;
        productsTbody.appendChild(tr);
      });
      $('#chatProductsCount').textContent = products.length;
    }

    function renderRpcTables(data) {
      // Events table
      const eventsTbody = $('#rpcEventsTable tbody');
      eventsTbody.innerHTML = '';
      (data.events || []).forEach(event => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td><a href="${event.page_url}" target="_blank">${escapeHTML(event.title || '')}</a></td>
          <td class="nowrap">${escapeHTML(event.date_start || '')}</td>
          <td>${escapeHTML(event.location || '')}</td>
        `;
        eventsTbody.appendChild(tr);
      });
      $('#rpcEventsCount').textContent = (data.events || []).length;
      
      // Products table
      const productsTbody = $('#rpcProductsTable tbody');
      productsTbody.innerHTML = '';
      (data.products || []).forEach(product => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td><a href="${product.page_url}" target="_blank">${escapeHTML(product.title || '')}</a></td>
          <td>${product.display_price ? `¬£${product.display_price}` : ''}</td>
          <td>${escapeHTML(product.tags || '')}</td>
        `;
        productsTbody.appendChild(tr);
      });
      $('#rpcProductsCount').textContent = (data.products || []).length;
    }

    function escapeHTML(s) { 
      return (s || '').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])) 
    }

    // ------- Main Functions -------
    async function runBothTests() {
      const query = $byId('queryInput').value.trim();
      if (!query) {
        // Please enter a query
        return;
      }
      
      // Capture previous query for context before updating lastQuery
      const previousQuery = lastQuery;
      lastQuery = query; // update last asked query
      log(`üöÄ Running both tests for: "${query}"`);
      
      // Build contextual query for RPC keywordization
      const contextualQuery = buildContextualQuery(query, previousQuery);
      if (previousQuery) {
        log(`üß© Contextual query: "${contextualQuery}" (prev: "${previousQuery}")`);
      }

      // Clear previous results
      $byId('chatResponse').innerHTML = '<div class="response-title">Response:</div><div class="response-content">Loading...</div>';
      $byId('rpcResponse').innerHTML = '<div class="response-title">Response:</div><div class="response-content">Loading...</div>';
      
      // Run both tests in parallel
      const [chatResult, rpcResult] = await Promise.allSettled([
        callChatAPI(query, previousQuery),
        callRpcFunctions(contextualQuery)
      ]);
      
      // Handle chat.js result
      if (chatResult.status === 'fulfilled') {
        lastChatResponse = chatResult.value;
        renderChatResponse(chatResult.value);
        log('‚úÖ Chat.js test completed');
      } else {
        lastChatResponse = { error: chatResult.reason.message };
        renderChatResponse(lastChatResponse);
        log('‚ùå Chat.js test failed:', chatResult.reason.message);
      }
      
      // Handle RPC result
      if (rpcResult.status === 'fulfilled') {
        lastRpcResponse = rpcResult.value;
        renderRpcResponse(rpcResult.value);
        log('‚úÖ RPC test completed');
      } else {
        lastRpcResponse = { error: rpcResult.reason.message };
        renderRpcResponse(lastRpcResponse);
        log('‚ùå RPC test failed:', rpcResult.reason.message);
      }
      
      // Update context info
      $byId('contextInfo').textContent = previousQuery ? 'Has context' : 'No context';
    }

    function clearResults() {
      $byId('queryInput').value = '';
      $byId('chatResponse').innerHTML = '<div class="response-title">Response:</div><div class="response-content">Click "Run Both" to test chat.js API</div>';
      $byId('rpcResponse').innerHTML = '<div class="response-title">Response:</div><div class="response-content">Click "Run Both" to test direct RPC calls</div>';
      
      // Clear tables
      $('#chatEventsTable tbody').innerHTML = '';
      $('#chatProductsTable tbody').innerHTML = '';
      $('#rpcEventsTable tbody').innerHTML = '';
      $('#rpcProductsTable tbody').innerHTML = '';
      
      $('#chatEventsCount').textContent = '0';
      $('#chatProductsCount').textContent = '0';
      $('#rpcEventsCount').textContent = '0';
      $('#rpcProductsCount').textContent = '0';
      
      $byId('contextInfo').textContent = 'None';
      lastQuery = null;
      lastChatResponse = null;
      lastRpcResponse = null;
      
      // Results cleared
    }

    async function testConnections() {
      // Testing connections
      await Promise.all([
        testChatConnection(),
        testRpcConnection()
      ]);
    }

    // ------- Export Functions -------
    async function copyComparison() {
      if (!lastChatResponse || !lastRpcResponse) {
        // No results to copy
        return;
      }
      
      const comparison = {
        query: lastQuery,
        timestamp: new Date().toISOString(),
        chat_js: lastChatResponse,
        rpc_direct: lastRpcResponse
      };
      
      await navigator.clipboard.writeText(JSON.stringify(comparison, null, 2));
      // Comparison copied to clipboard
    }

    function downloadLogs() {
      const blob = new Blob([logEl.textContent], {type:'text/plain'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'split-testbench-logs.txt';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    }

    // ------- Quick Test Functions -------
    const quickTests = {
      'btnTestBluebell': 'when is the next bluebell workshop',
      'btnTestParticipants': 'how many people can attend',
      'btnTestPrice': 'how much does it cost',
      'btnTestLocation': 'where is it',
      'btnTestDates': 'when is it',
      'btnTestAdvice': 'photography tips for beginners',
      'btnTestFitness': 'what fitness level is required',
      'btnTestDuration': 'how long does it take',
      'btnTestBooking': 'how do I book'
    };

    // ------- Event Wiring -------
    $byId('btnRunBoth').addEventListener('click', runBothTests);
    $byId('btnClearResults').addEventListener('click', clearResults);
    $byId('btnTestConnections').addEventListener('click', testConnections);
    $byId('btnCopyComparison').addEventListener('click', copyComparison);
    $byId('btnDownloadLogs').addEventListener('click', downloadLogs);

    // Quick test buttons
    Object.entries(quickTests).forEach(([btnId, query]) => {
      $byId(btnId).addEventListener('click', () => {
        $byId('queryInput').value = query;
        runBothTests();
      });
    });

    // Enter key to run
    $byId('queryInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        runBothTests();
      }
    });

    // Auto-test connections on load
    window.addEventListener('load', () => {
      // Split Testbench loaded
      testConnections();
    });
  </script>
</body>
</html>
