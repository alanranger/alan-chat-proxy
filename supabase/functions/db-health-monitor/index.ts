import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

export const main = async (req: Request) => {
  const supabase = createClient(
    Deno.env.get("SUPABASE_URL")!,
    Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!
  );

  async function sendEmail(subject: string, message: string) {
    const SUPABASE_URL = Deno.env.get("SUPABASE_URL")!;
    const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
    
    await fetch(`${SUPABASE_URL}/functions/v1/db-health-email-alert`, {
      method: "POST",
      headers: { 
        "Content-Type": "application/json", 
        "Authorization": `Bearer ${SUPABASE_SERVICE_ROLE_KEY}` 
      },
      body: JSON.stringify({ subject, message })
    });
  }

  try {
    // ---- 1. Pull Table Stats ----
    const { data: stats, error } = await supabase.rpc('exec_sql', {
      query: `
        SELECT table_name, total_bytes, heap_bytes, toast_bytes,
               dead_row_pct, live_rows, dead_rows, last_vacuum, last_autovacuum
        FROM table_stats
        ORDER BY total_bytes DESC
      `
    });

    if (error) throw error;

    // ---- 2. Compute bloat risk ----
    let alerts: string[] = [];

    const BAD_BLOAT = 5;   // 5% = warning
    const CRITICAL_BLOAT = 10; // 10% = red alert

    const topBloated = (stats || [])
      .filter((t: any) => t.dead_row_pct > BAD_BLOAT)
      .sort((a: any, b: any) => b.dead_row_pct - a.dead_row_pct)
      .slice(0, 10);

    if (topBloated.length > 0) {
      alerts.push(`<b>Bloated Tables:</b><br>${topBloated.map((t: any) =>
        `${t.table_name}: ${t.dead_row_pct}% bloat`
      ).join("<br>")}`);
    }

    // ---- 3. Insert health snapshot (keep existing structure) ----
    const { data: healthData } = await supabase.rpc('exec_sql', {
      query: `
        SELECT
          (pg_database_size(current_database())/1024/1024)::int AS db_size_mb,
          (SELECT COUNT(*) FROM information_schema.tables WHERE table_schema='public') AS table_count,
          (SELECT COUNT(*) FROM debug_logs) AS debug_log_count,
          (SELECT COALESCE(dead_tuple_ratio, 0) FROM bloat_summary WHERE table_name='page_html' LIMIT 1) AS table_bloat_pct,
          (SELECT COUNT(*) FROM page_chunks) AS chunk_count
      `
    });

    const h = healthData?.[0] || {};
    const risk_debug = h.debug_log_count > 20000 ? 40 : (h.debug_log_count > 5000 ? 15 : 5);
    const risk_bloat = h.table_bloat_pct > 4 ? 50 : (h.table_bloat_pct > 2.5 ? 25 : 10);
    const risk_chunks = h.chunk_count === 0 ? 80 : (h.chunk_count < 5 ? 40 : 10);
    const risk_total = risk_debug + risk_bloat + risk_chunks;

    await supabase.from("db_health_snapshots").insert({
      db_size_mb: h.db_size_mb,
      table_count: h.table_count,
      debug_log_count: h.debug_log_count,
      table_bloat_pct: h.table_bloat_pct,
      chunk_count: h.chunk_count,
      risk_total,
      risk_debug,
      risk_bloat,
      risk_chunks
    });

    // ---- 4. If alerts exist → send email ----
    if (alerts.length > 0) {
      await sendEmail(
        "⚠️ Database Health Alert – Action Required",
        `
          <h2>Database Health Alert</h2>
          <p>The following issues were detected:</p>
          ${alerts.join("<br><br>")}
          <hr>
          <p>This alert was automatically generated by the AR Database Monitor.</p>
        `
      );
    }

    return new Response(JSON.stringify({ success: true, alerts }), {
      headers: { "Content-Type": "application/json" }
    });

  } catch (e: any) {
    return new Response(JSON.stringify({ error: e.message }), {
      status: 500,
      headers: { "Content-Type": "application/json" }
    });
  }
};

Deno.serve(main);
